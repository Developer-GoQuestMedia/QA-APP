# Project Structure

ğŸ“„ .eslintrc.json
ğŸ“ .git/
ğŸ“„ .gitignore
ğŸ“ .next/
ğŸ“ .notes/
  ğŸ“„ directory_structure.md
  ğŸ“„ project_overview.md
  ğŸ“„ task_list.md
ğŸ“ app/
  ğŸ“ admin/
    ğŸ“ project/
      ğŸ“ [projectId]/
        ğŸ“ progress/
          ğŸ“„ page.tsx
  ğŸ“ allDashboards/
    ğŸ“ admin/
      ğŸ“„ page.tsx
    ğŸ“ director/
      ğŸ“„ page.tsx
      ğŸ“ [projectId]/
        ğŸ“„ page.tsx
    ğŸ“„ page.tsx
    ğŸ“ transcriber/
      ğŸ“„ page.tsx
      ğŸ“ [projectId]/
        ğŸ“„ page.tsx
    ğŸ“ translator/
      ğŸ“„ page.tsx
      ğŸ“ [projectId]/
        ğŸ“„ page.tsx
    ğŸ“ voice-over/
      ğŸ“„ page.tsx
      ğŸ“ [projectId]/
        ğŸ“„ page.tsx
  ğŸ“ api/
    ğŸ“ admin/
      ğŸ“ projects/
        ğŸ“„ route.ts
        ğŸ“ [projectId]/
          ğŸ“ assign/
            ğŸ“„ route.ts
          ğŸ“ episode/
          ğŸ“ progress/
            ğŸ“„ route.ts
          ğŸ“„ route.ts
      ğŸ“ users/
        ğŸ“„ route.ts
        ğŸ“ [userId]/
          ğŸ“„ route.ts
    ğŸ“ auth/
      ğŸ“„ auth.config.ts
      ğŸ“ login/
        ğŸ“„ route.ts
      ğŸ“ [...nextauth]/
        ğŸ“„ route.ts
    ğŸ“ cleanup/
    ğŸ“ dialogues/
      ğŸ“„ route.ts
      ğŸ“ [id]/
        ğŸ“„ route.ts
    ğŸ“ episodes/
      ğŸ“„ route.ts
    ğŸ“ projects/
      ğŸ“„ route.ts
      ğŸ“ [id]/
        ğŸ“ assign/
          ğŸ“„ route.ts
    ğŸ“ upload-audio/
      ğŸ“„ route.ts
    ğŸ“ upload-voice-over/
      ğŸ“„ route.ts
    ğŸ“ users/
      ğŸ“ me/
        ğŸ“„ route.ts
      ğŸ“„ route.ts
    ğŸ“ voice-over/
      ğŸ“ upload/
        ğŸ“„ route.ts
  ğŸ“ components/
    ğŸ“„ Button.tsx
    ğŸ“„ Card.tsx
    ğŸ“„ ThemeToggle.tsx
  ğŸ“„ favicon.ico (binary file - skipped)
  ğŸ“ fonts/
    ğŸ“„ GeistMonoVF.woff (binary file - skipped)
    ğŸ“„ GeistVF.woff (binary file - skipped)
  ğŸ“„ globals.css
  ğŸ“„ layout.tsx
  ğŸ“ login/
    ğŸ“„ page.tsx
  ğŸ“„ page.tsx
  ğŸ“„ providers.tsx
  ğŸ“ styles/
    ğŸ“„ styleLogger.ts
    ğŸ“„ theme.ts
ğŸ“ components/
  ğŸ“„ AdminView.tsx
  ğŸ“ audio/
  ğŸ“„ AudioVisualizer.tsx
  ğŸ“„ Button.tsx
  ğŸ“„ Card.tsx
  ğŸ“ common/
  ğŸ“„ DashboardLayout.tsx
  ğŸ“„ DirectorDialogueView.tsx
  ğŸ“„ DirectorView.tsx
  ğŸ“ layout/
  ğŸ“„ RecordingTimer.tsx
  ğŸ“„ SystemInit.tsx
  ğŸ“„ TranscriberDialogueView.tsx
  ğŸ“„ TranscriberView.tsx
  ğŸ“„ TranslatorDialogueView.tsx
  ğŸ“„ TranslatorView.tsx
  ğŸ“ ui/
    ğŸ“„ alert.tsx
  ğŸ“ views/
  ğŸ“„ VoiceOverDialogueView.tsx
  ğŸ“„ VoiceOverView.tsx
ğŸ“„ components.json
ğŸ“ hooks/
  ğŸ“„ useAudioRecording.ts
  ğŸ“„ useDialogues.ts
  ğŸ“„ useEpisodeDialogues.ts
  ğŸ“„ useEpisodes.ts
  ğŸ“„ useProject.ts
  ğŸ“„ useProjects.ts
ğŸ“„ jest.config.ts
ğŸ“„ jest.setup.ts
ğŸ“ lib/
  ğŸ“„ auth.ts
  ğŸ“„ mongodb.ts
  ğŸ“„ prisma.ts
  ğŸ“„ seed.ts
  ğŸ“„ utils.ts
ğŸ“„ middleware.ts
ğŸ“„ next.config.mjs
ğŸ“„ package.json
ğŸ“„ postcss.config.mjs
ğŸ“ prisma/
  ğŸ“„ schema.prisma
ğŸ“ scripts/
  ğŸ“„ build-success.js
  ğŸ“„ dialougeSample.json
  ğŸ“„ migrate-dialogues.ts
  ğŸ“„ migrate-roles.ts
  ğŸ“„ seed-users.ts
  ğŸ“„ seed.ts
  ğŸ“„ start-app.js
  ğŸ“„ test-db-creation.ts
ğŸ“ src/
  ğŸ“ types/
    ğŸ“„ dialogue.ts
ğŸ“„ tailwind.config.ts
ğŸ“ Tools/
  ğŸ“„ copyandpaste.js
ğŸ“„ tsconfig.json
ğŸ“ types/
  ğŸ“„ dialogue.ts
  ğŸ“„ next-auth.d.ts
  ğŸ“„ project.ts
  ğŸ“„ user.ts
ğŸ“ utils/
  ğŸ“„ audio.ts
  ğŸ“„ cn.ts
  ğŸ“„ formatters.ts
ğŸ“„ vercel.json


# File Contents


## File: .eslintrc.json
```json
{
  "extends": [
    "next/core-web-vitals",
    "plugin:@typescript-eslint/recommended"
  ],
  "plugins": [
    "@typescript-eslint"
  ],
  "rules": {
    "@typescript-eslint/no-unused-vars": [
      "warn",
      {
        "argsIgnorePattern": "^_",
        "varsIgnorePattern": "^(rotate|opacity|scale|animControls|autoResizeTextArea|checkMediaSupport|mediaRecorderRef|playbackRate|handleNext|handlePrevious|rewindFiveSeconds|changePlaybackRate|isLoadingUsers)$"
      }
    ],
    "@typescript-eslint/no-explicit-any": "warn",
    "react/no-unescaped-entities": "off",
    "react-hooks/exhaustive-deps": "warn"
  }
}

```

## File: .gitignore
```gitignore
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js
.yarn/install-state.gz

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local
.env
.env.development
.env.test
.env.production

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

# IDE
.idea/
.vscode/
*.sublime-project
*.sublime-workspace

# Build and Cache
.swc/
.turbo
.cache/
dist/

# Logs
logs/
*.log

# System Files
Thumbs.db
.DS_Store
desktop.ini

```

## File: .notes\directory_structure.md
```md
ï»¿# Current Directory Structure

## Core Components

`
- **.notes/**
    - project_overview.md
    - task_list.md
- **app/**
    - **admin/**
        - **project/**
            - **[projectId]/**
    - **allDashboards/**
        - **admin/**
            - page.tsx
        - **director/**
            - **[projectId]/**
            - page.tsx
        - **transcriber/**
            - **[projectId]/**
            - page.tsx
        - **translator/**
            - **[projectId]/**
            - page.tsx
        - **voice-over/**
            - **[projectId]/**
            - page.tsx
        - page.tsx
    - **api/**
        - **admin/**
            - **projects/**
                - **[projectId]/**
                - route.ts
            - **users/**
                - **[userId]/**
                - route.ts
        - **auth/**
            - **login/**
                - route.ts
            - **[...nextauth]/**
            - auth.config.ts
        - **dialogues/**
            - **[id]/**
            - route.ts
        - **projects/**
            - **[id]/**
            - route.ts
        - **upload-audio/**
            - route.ts
        - **upload-voice-over/**
            - route.ts
        - **users/**
            - **me/**
                - route.ts
            - route.ts
        - **voice-over/**
            - **upload/**
                - route.ts
    - **components/**
        - Button.tsx
        - Card.tsx
        - ThemeToggle.tsx
    - **dashboard/**
        - page.tsx
    - **fonts/**
        - GeistMonoVF.woff
        - GeistVF.woff
    - **login/**
        - page.tsx
    - **styles/**
        - styleLogger.ts
        - theme.ts
    - favicon.ico
    - globals.css
    - layout.tsx
    - page.tsx
    - providers.tsx
- **components/**
    - **audio/**
    - **common/**
    - **layout/**
    - **ui/**
        - alert.tsx
    - **views/**
    - AdminView.tsx
    - AudioVisualizer.tsx
    - Button.tsx
    - Card.tsx
    - DashboardLayout.tsx
    - DirectorDialogueView.tsx
    - DirectorView.tsx
    - RecordingTimer.tsx
    - TranscriberDialogueView.tsx
    - TranscriberView.tsx
    - TranslatorDialogueView.tsx
    - TranslatorView.tsx
    - VoiceOverDialogueView.tsx
    - VoiceOverView.tsx
- **hooks/**
    - useAudioRecording.ts
    - useDialogues.ts
    - useProject.ts
    - useProjects.ts
- **lib/**
    - auth.ts
    - mongodb.ts
    - seed.ts
    - utils.ts
- **scripts/**
    - build-success.js
    - seed-users.ts
    - seed.ts
    - start-app.js
- **src/**
    - **types/**
        - dialogue.ts
- **Tools/**
    - copyandpaste.js
    - project_structure_and_contents.txt
- **types/**
    - dialogue.ts
    - next-auth.d.ts
    - project.ts
    - user.ts
- **utils/**
    - audio.ts
    - cn.ts
    - formatters.ts
- **__tests__/**
    - **components/**
        - TranscriberDialogueView.test.tsx
        - TranscriberView.test.tsx
        - VoiceOverDialogueView.test.tsx
        - VoiceOverView.test.tsx
    - login.test.tsx
    - mongodb.test.ts
- .cursorignore
- .cursorrules
- .env
- .env.local
- .eslintrc.json
- .gitignore
- components.json
- jest.config.ts
- jest.setup.ts
- next-env.d.ts
- next.config.mjs
- package-lock.json
- package.json
- postcss.config.mjs
- README.md
- tailwind.config.ts
- tsconfig.json
- update_directory.ps1
`
```

## File: .notes\project_overview.md
```md
# QA-APP Project Overview

## Project Description
A comprehensive Quality Assurance application for managing multimedia content translation and voice-over production workflow. The application supports multiple user roles and provides specialized interfaces for transcription, translation, voice-over recording, and project management.

## Technical Stack
- **Frontend Framework**: Next.js 14.2.16
- **Language**: TypeScript
- **Styling**: Tailwind CSS with custom theming
- **State Management**: React Query (TanStack Query)
- **Authentication**: NextAuth.js
- **Database**: MongoDB
- **Storage**: AWS S3 (for media files)
- **Testing**: Jest with React Testing Library

## Core Features

### 1. Authentication & Authorization
- Role-based access control (RBAC)
- Supported roles: admin, director, transcriber, translator, voice-over
- Secure session management with JWT
- Protected API routes and client-side navigation

### 2. Project Management
- Project creation and assignment
- Progress tracking
- Multi-language support
- Resource allocation
- Status monitoring

### 3. Workflow Components
- **Transcription Module**
  - Video playback with controls
  - Time-stamped dialogue entry
  - Character assignment
  - Auto-save functionality

- **Translation Module**
  - Original text reference
  - Translation input
  - Adaptation support
  - Cultural notes

- **Voice-Over Module**
  - Audio recording with visualization
  - Playback controls
  - Timing synchronization
  - Quality monitoring

### 4. Technical Features
- Real-time audio processing
- Video playback synchronization
- Automated progress calculation
- File upload/download management
- Responsive design
- Dark/Light theme support

## Project Structure

### Key Directories
- `/app`: Next.js application routes and API endpoints
- `/components`: Reusable React components
- `/hooks`: Custom React hooks
- `/lib`: Core utilities and configurations
- `/types`: TypeScript type definitions
- `/utils`: Helper functions and utilities
- `/tests`: Test suites and configurations

### Main Components
1. **User Interface**
   - AdminView
   - TranscriberView
   - TranslatorView
   - VoiceOverView
   - DirectorView

2. **Dialogue Management**
   - TranscriberDialogueView
   - TranslatorDialogueView
   - VoiceOverDialogueView

3. **Media Handling**
   - AudioVisualizer
   - RecordingTimer
   - VideoPlayer

## Development Guidelines

### Code Standards
- TypeScript strict mode enabled
- ESLint configuration for code quality
- Jest for unit and integration testing
- Component-based architecture
- Responsive design principles

### Security Measures
- API route protection
- Input validation
- Secure file handling
- Session management
- Environment variable usage

### Performance Optimization
- Lazy loading
- Optimized media handling
- Caching strategies
- Query optimization

## Deployment
- Production build optimization
- Environment configuration
- Database seeding support
- Monitoring setup

## Future Enhancements
1. Real-time collaboration features
2. Enhanced progress analytics
3. Batch processing capabilities
4. Advanced search functionality
5. Extended language support

## Documentation
- API documentation
- Component documentation
- Type definitions
- Testing guidelines
- Deployment procedures

```

## File: .notes\task_list.md
```md

```

## File: app\admin\project\[projectId]\progress\page.tsx
```tsx
'use client'

import { useSession } from 'next-auth/react'
import { useRouter } from 'next/navigation'
import { useEffect } from 'react'
import { useQuery } from '@tanstack/react-query'
import axios from 'axios'

interface ProjectProgress {
  transcribed: number
  translated: number
  voiceOver: number
  approved: number
  total: number
  lastUpdated: string
}

export default function ProjectProgressPage({
  params,
}: {
  params: { projectId: string }
}) {
  const { data: session, status } = useSession()
  const router = useRouter()

  const { data: progress, isLoading } = useQuery<ProjectProgress>({
    queryKey: ['project-progress', params.projectId],
    queryFn: async () => {
      const response = await axios.get(`/api/admin/projects/${params.projectId}/progress`)
      return response.data.data
    },
    enabled: !!session && session.user.role === 'admin'
  })

  useEffect(() => {
    if (status === 'unauthenticated' || (session && session.user.role !== 'admin')) {
      router.push('/login')
    }
  }, [status, session, router])

  if (status === 'loading' || isLoading) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="text-center">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary mx-auto"></div>
          <p className="mt-2">Loading...</p>
        </div>
      </div>
    )
  }

  if (!progress) {
    return null
  }

  return (
    <div className="min-h-screen bg-gray-50 dark:bg-gray-900 py-8">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <div className="mb-8">
          <button
            onClick={() => router.back()}
            className="text-blue-500 hover:text-blue-600 transition-colors"
          >
            â† Back
          </button>
        </div>

        <div className="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
          <h1 className="text-2xl font-bold text-gray-900 dark:text-white mb-6">Project Progress</h1>

          <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-4">
            <div className="bg-blue-50 dark:bg-blue-900/50 rounded-lg p-4">
              <h3 className="text-blue-800 dark:text-blue-200 font-medium">Transcribed</h3>
              <div className="mt-2">
                <div className="flex items-center">
                  <div className="flex-1 bg-blue-200 dark:bg-blue-700 rounded-full h-2">
                    <div
                      className="bg-blue-500 h-2 rounded-full"
                      style={{ width: `${progress.transcribed}%` }}
                    />
                  </div>
                  <span className="ml-2 text-blue-800 dark:text-blue-200">
                    {progress.transcribed}%
                  </span>
                </div>
              </div>
            </div>

            <div className="bg-purple-50 dark:bg-purple-900/50 rounded-lg p-4">
              <h3 className="text-purple-800 dark:text-purple-200 font-medium">Translated</h3>
              <div className="mt-2">
                <div className="flex items-center">
                  <div className="flex-1 bg-purple-200 dark:bg-purple-700 rounded-full h-2">
                    <div
                      className="bg-purple-500 h-2 rounded-full"
                      style={{ width: `${progress.translated}%` }}
                    />
                  </div>
                  <span className="ml-2 text-purple-800 dark:text-purple-200">
                    {progress.translated}%
                  </span>
                </div>
              </div>
            </div>

            <div className="bg-green-50 dark:bg-green-900/50 rounded-lg p-4">
              <h3 className="text-green-800 dark:text-green-200 font-medium">Voice Over</h3>
              <div className="mt-2">
                <div className="flex items-center">
                  <div className="flex-1 bg-green-200 dark:bg-green-700 rounded-full h-2">
                    <div
                      className="bg-green-500 h-2 rounded-full"
                      style={{ width: `${progress.voiceOver}%` }}
                    />
                  </div>
                  <span className="ml-2 text-green-800 dark:text-green-200">
                    {progress.voiceOver}%
                  </span>
                </div>
              </div>
            </div>

            <div className="bg-yellow-50 dark:bg-yellow-900/50 rounded-lg p-4">
              <h3 className="text-yellow-800 dark:text-yellow-200 font-medium">Approved</h3>
              <div className="mt-2">
                <div className="flex items-center">
                  <div className="flex-1 bg-yellow-200 dark:bg-yellow-700 rounded-full h-2">
                    <div
                      className="bg-yellow-500 h-2 rounded-full"
                      style={{ width: `${progress.approved}%` }}
                    />
                  </div>
                  <span className="ml-2 text-yellow-800 dark:text-yellow-200">
                    {progress.approved}%
                  </span>
                </div>
              </div>
            </div>
          </div>

          <div className="mt-6 text-sm text-gray-500 dark:text-gray-400">
            <p>Total Dialogues: {progress.total}</p>
            <p>Last Updated: {new Date(progress.lastUpdated).toLocaleString()}</p>
          </div>
        </div>
      </div>
    </div>
  )
} 
```

## File: app\allDashboards\admin\page.tsx
```tsx
'use client'

import { useSession } from 'next-auth/react'
import { useState, useEffect } from 'react'
import AdminView from '@/components/AdminView'
import DashboardLayout from '@/components/DashboardLayout'
import { Project } from '@/types/project'
import axios from 'axios'

export default function Page() {
  const { data: session, status } = useSession()
  const [projects, setProjects] = useState<Project[]>([])

  const fetchProjects = async () => {
    try {
      console.log('Admin dashboard: Fetching projects...', {
        timestamp: new Date().toISOString(),
        userId: session?.user?.id,
        userRole: session?.user?.role
      })

      const { data } = await axios.get('/api/projects')
      const projectsWithDates = data.map((project: Omit<Project, 'updatedAt' | 'createdAt'> & {
        updatedAt: string;
        createdAt?: string;
        _id: string;
      }) => ({
        ...project,
        updatedAt: new Date(project.updatedAt),
        createdAt: project.createdAt ? new Date(project.createdAt) : undefined
      }))

      console.log('Admin dashboard: Projects fetched successfully:', {
        timestamp: new Date().toISOString(),
        projectCount: projectsWithDates.length,
        projectIds: projectsWithDates.map((p: { _id: string }) => p._id),
        userRole: session?.user?.role
      })

      setProjects(projectsWithDates)
    } catch (error) {
      console.error('Admin dashboard: Error fetching projects:', {
        error: error instanceof Error ? error.message : 'Unknown error',
        timestamp: new Date().toISOString(),
        userId: session?.user?.id,
        userRole: session?.user?.role
      })
    }
  }

  useEffect(() => {
    console.log('Admin dashboard: Component mounted', {
      timestamp: new Date().toISOString(),
      sessionStatus: status,
      userRole: session?.user?.role,
      userId: session?.user?.id
    })

    if (status === 'authenticated') {
      fetchProjects()
    }
  }, [status, session])

  if (status === 'loading') {
    console.log('Admin dashboard: Loading state', {
      timestamp: new Date().toISOString(),
      sessionStatus: status
    })
    return <div>Loading...</div>
  }

  if (status === 'unauthenticated') {
    console.log('Admin dashboard: Unauthenticated access attempt', {
      timestamp: new Date().toISOString(),
      pathname: window.location.pathname
    })
    return null
  }

  console.log('Admin dashboard: Rendering dashboard', {
    timestamp: new Date().toISOString(),
    projectCount: projects.length,
    userRole: session?.user?.role,
    userId: session?.user?.id
  })

  return (
    <DashboardLayout title="Admin Dashboard">
      <AdminView projects={projects} refetchProjects={fetchProjects} />
    </DashboardLayout>
  )
} 
```

## File: app\allDashboards\director\page.tsx
```tsx
'use client'

import DirectorView from '@/components/DirectorView'
import { useProjects } from '@/hooks/useProjects'

export default function DirectorDashboard() {
  const { data: projects, isLoading: isLoadingProjects } = useProjects()

  if (isLoadingProjects) {
    return <div>Loading...</div>
  }

  return (
    <div className="min-h-screen bg-background">
      <DirectorView projects={projects || []} />
    </div>
  )
} 
```

## File: app\allDashboards\director\[projectId]\page.tsx
```tsx
'use client'

import { useSession } from 'next-auth/react'
import { useRouter } from 'next/navigation'
import { useDialogues } from '@/hooks/useDialogues'
import DirectorDialogueView from '../../../../components/DirectorDialogueView'

export default function DirectorProjectPage({
  params,
}: {
  params: { projectId: string }
}) {
  const { status } = useSession()
  const router = useRouter()
  const { data: dialogues, isLoading } = useDialogues(params.projectId)

  if (status === 'loading' || isLoading) {
    return (
      <div className="min-h-screen flex items-center justify-center p-4">
        <div className="text-center">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary mx-auto"></div>
          <p className="mt-2 text-foreground">Loading...</p>
        </div>
      </div>
    )
  }

  return (
    <div className="min-h-screen bg-background">
      <div className="w-full max-w-7xl mx-auto py-4 sm:py-6">
        <div className="flex justify-between items-center mb-4 sm:mb-6 px-4">
          <button
            onClick={() => router.push('/allDashboards/director')}
            className="text-primary hover:text-primary/80 transition-colors text-sm sm:text-base"
          >
            â† Back to Projects
          </button>
        </div>
        <DirectorDialogueView dialogues={dialogues || []} projectId={params.projectId} />
      </div>
    </div>
  )
} 
```

## File: app\allDashboards\page.tsx
```tsx
'use client'

import { useSession } from 'next-auth/react'

export default function DashboardRouter() {
  const { status } = useSession()

  if (status === 'loading') {
    return <div>Loading...</div>
  }

  return null
} 
```

## File: app\allDashboards\transcriber\page.tsx
```tsx
'use client'

import { useSession } from 'next-auth/react'
import TranscriberView from '@/components/TranscriberView'
import { useProjects } from '@/hooks/useProjects'

export default function TranscriberDashboard() {
  const { data: session, status } = useSession()
  const { data: projects, isLoading: isLoadingProjects } = useProjects()

  if (status === 'loading' || isLoadingProjects) {
    return <div>Loading...</div>
  }

  return (
    <div className="min-h-screen bg-background">
      <TranscriberView projects={projects || []} />
    </div>
  )
} 
```

## File: app\allDashboards\transcriber\[projectId]\page.tsx
```tsx
'use client'

import { useSession } from 'next-auth/react'
import { useRouter } from 'next/navigation'
import { useDialogues } from '@/hooks/useDialogues'
import { useEpisodes } from '@/hooks/useEpisodes'
import TranscriberDialogueView from '../../../../components/TranscriberDialogueView'

export default function TranscriberProjectPage({
  params,
}: {
  params: { projectId: string }
}) {
  const { status } = useSession()
  const router = useRouter()
  const { data: dialogues, isLoading: isLoadingDialogues } = useDialogues(params.projectId)
  const { data: episodes, isLoading: isLoadingEpisodes } = useEpisodes(params.projectId)

  if (status === 'loading' || isLoadingDialogues || isLoadingEpisodes) {
    return (
      <div className="min-h-screen flex items-center justify-center p-4">
        <div className="text-center">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary mx-auto"></div>
          <p className="mt-2 text-foreground">Loading...</p>
        </div>
      </div>
    )
  }

  return (
    <div className="min-h-screen bg-background">
      <div className="w-full max-w-7xl mx-auto py-4 sm:py-6">
        <div className="flex justify-between items-center mb-4 sm:mb-6 px-4">
          <button
            onClick={() => router.push('/allDashboards/transcriber')}
            className="text-primary hover:text-primary/80 transition-colors text-sm sm:text-base"
          >
            â† Back to Projects
          </button>
        </div>
        <TranscriberDialogueView 
          dialogues={dialogues || []} 
          projectId={params.projectId} 
          episodes={episodes || []}
        />
      </div>
    </div>
  )
} 
```

## File: app\allDashboards\translator\page.tsx
```tsx
'use client'

import { useSession } from 'next-auth/react'
import TranslatorView from '@/components/TranslatorView'
import { useProjects } from '@/hooks/useProjects'

export default function TranslatorDashboard() {
  const { data: session, status } = useSession()
  const { data: projects, isLoading: isLoadingProjects } = useProjects()

  if (status === 'loading' || isLoadingProjects) {
    return <div>Loading...</div>
  }

  return (
    <div className="min-h-screen bg-background">
      <TranslatorView projects={projects || []} />
    </div>
  )
} 
```

## File: app\allDashboards\translator\[projectId]\page.tsx
```tsx
'use client'

import { useSession } from 'next-auth/react'
import { useRouter } from 'next/navigation'
import { useDialogues } from '@/hooks/useDialogues'
import TranslatorDialogueView from '../../../../components/TranslatorDialogueView'

export default function TranslatorProjectPage({
  params,
}: {
  params: { projectId: string }
}) {
  const { status } = useSession()
  const router = useRouter()
  const { data: dialogues, isLoading } = useDialogues(params.projectId)

  if (status === 'loading' || isLoading) {
    return (
      <div className="min-h-screen flex items-center justify-center p-4">
        <div className="text-center">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary mx-auto"></div>
          <p className="mt-2 text-foreground">Loading...</p>
        </div>
      </div>
    )
  }

  return (
    <div className="min-h-screen bg-background">
      <div className="w-full max-w-7xl mx-auto py-4 sm:py-6">
        <div className="flex justify-between items-center mb-4 sm:mb-6 px-4">
          <button
            onClick={() => router.push('/allDashboards/translator')}
            className="text-primary hover:text-primary/80 transition-colors text-sm sm:text-base"
          >
            â† Back to Projects
          </button>
        </div>
        <TranslatorDialogueView dialogues={dialogues || []} projectId={params.projectId} />
      </div>
    </div>
  )
} 
```

## File: app\allDashboards\voice-over\page.tsx
```tsx
'use client'

import { useSession } from 'next-auth/react'
import VoiceOverView from '@/components/VoiceOverView'
import { useProjects } from '@/hooks/useProjects'

export default function VoiceOverDashboard() {
  const { data: session, status } = useSession()
  const { data: projects, isLoading: isLoadingProjects } = useProjects()

  console.log('VoiceOver Dashboard Render:', {
    sessionStatus: status,
    userRole: session?.user?.role,
    username: session?.user?.username,
    projectsLoaded: !!projects,
    projectCount: projects?.length
  })

  if (status === 'loading' || isLoadingProjects) {
    console.log('Dashboard loading state:', {
      sessionLoading: status === 'loading',
      projectsLoading: isLoadingProjects
    })
    return <div>Loading...</div>
  }

  console.log('Dashboard ready to render:', {
    authenticated: !!session,
    role: session?.user?.role
  })

  return (
    <div className="min-h-screen bg-background">
      <VoiceOverView projects={projects || []} />
    </div>
  )
} 
```

## File: app\allDashboards\voice-over\[projectId]\page.tsx
```tsx
'use client'

import { useSession } from 'next-auth/react'
import { useRouter } from 'next/navigation'
import { useDialogues } from '@/hooks/useDialogues'
import VoiceOverDialogueView from '../../../../components/VoiceOverDialogueView'

export default function VoiceOverProjectPage({
  params,
}: {
  params: { projectId: string }
}) {
  const { status } = useSession()
  const router = useRouter()
  const { data: dialogues, isLoading } = useDialogues(params.projectId)

  if (status === 'loading' || isLoading) {
    return (
      <div className="min-h-screen flex items-center justify-center p-4">
        <div className="text-center">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary mx-auto"></div>
          <p className="mt-2 text-foreground">Loading...</p>
        </div>
      </div>
    )
  }

  return (
    <div className="min-h-screen bg-background">
      <div className="w-full max-w-7xl mx-auto py-4 sm:py-6">
        <div className="flex justify-between items-center mb-4 sm:mb-6 px-4">
          <button
            onClick={() => router.push('/allDashboards/voice-over')}
            className="text-primary hover:text-primary/80 transition-colors text-sm sm:text-base"
          >
            â† Back to Projects
          </button>
        </div>
        <VoiceOverDialogueView dialogues={dialogues || []} projectId={params.projectId} />
      </div>
    </div>
  )
} 
```

## File: app\api\admin\projects\route.ts
```ts
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { S3Client, PutObjectCommand, DeleteObjectCommand, ListObjectsV2Command, GetObjectCommand, DeleteObjectsCommand } from '@aws-sdk/client-s3';
import { getSignedUrl } from '@aws-sdk/s3-request-presigner';
import { connectToDatabase } from '@/lib/mongodb';
import { ObjectId, WithId, ClientSession } from 'mongodb';

// Route Segment Config
export const dynamic = 'force-dynamic';
export const maxDuration = 60; // Maximum allowed for hobby plan
export const runtime = 'nodejs';

// Initialize S3 client for R2
const s3Client = new S3Client({
  region: 'auto',
  endpoint: process.env.R2_BUCKET_ENDPOINT,
  credentials: {
    accessKeyId: process.env.R2_ACCESS_KEY_ID || '',
    secretAccessKey: process.env.R2_SECRET_ACCESS_KEY || '',
  },
});

const BUCKET_NAME = process.env.R2_BUCKET_NAME || '';

// Helper function to delete folder and its contents from R2
async function deleteR2Folder(folderPath: string) {
  try {
    // List all objects in the folder
    const listCommand = new ListObjectsV2Command({
      Bucket: BUCKET_NAME,
      Prefix: folderPath,
    });

    const listedObjects = await s3Client.send(listCommand);

    if (!listedObjects.Contents || listedObjects.Contents.length === 0) {
      return;
    }

    // Delete all objects in the folder
    await Promise.all(
      listedObjects.Contents.map(async (object) => {
        if (object.Key) {
          const deleteCommand = new DeleteObjectCommand({
            Bucket: BUCKET_NAME,
            Key: object.Key,
          });
          await s3Client.send(deleteCommand);
        }
      })
    );
  } catch (error) {
    console.error('Error deleting R2 folder:', error);
    throw error;
  }
}

interface Episode {
  name: string;
  collectionName: string;
  videoPath: string;
  videoKey: string;
  status: 'uploaded' | 'processing' | 'error';
  uploadedAt: Date;
}

interface ProjectDocument {
  title: string;
  description: string;
  sourceLanguage: string;
  targetLanguage: string;
  dialogue_collection?: string;
  status: string;
  createdAt: Date;
  updatedAt: Date;
  assignedTo: any[];
  parentFolder: string;
  databaseName: string;
  episodes: Episode[];
  uploadStatus: {
    totalFiles: number;
    completedFiles: number;
    currentFile: number;
    status: string;
  };
}

export async function POST(request: NextRequest) {
  const startTime = Date.now();
  let videoFile: File | null = null;
  let uploadedFiles: Array<{
    name: string;
    videoPath: string;
    videoKey: string;
    collectionName: string;
  }> = [];

  try {
    // Step 0: Authorization check
    const authSession = await getServerSession(authOptions);
    if (!authSession || !authSession.user || authSession.user.role !== 'admin') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const formData = await request.formData();
    videoFile = formData.get('video') as File;

    // Extract project data
    const projectData = {
      title: formData.get('title') as string,
      description: formData.get('description') as string,
      sourceLanguage: formData.get('sourceLanguage') as string,
      targetLanguage: formData.get('targetLanguage') as string,
      status: 'initializing' as const
    };

    // Get metadata
    const metadata = JSON.parse(formData.get('metadata') as string);
    const { currentFile, collections, filePaths } = metadata;
    const { isFirst, isLast, projectId, index } = currentFile;

    // Only proceed with initialization steps if this is the first file
    if (isFirst) {
      console.log(`[${new Date().toISOString()}] Starting new project initialization:`, {
        title: projectData.title,
        totalFiles: collections.length
      });

      // Step 1: Create parent folder name (sanitize title for folder name)
      const parentFolder = projectData.title.replace(/[^a-zA-Z0-9-_]/g, '_');
      console.log(`[${new Date().toISOString()}] Step 1: Created parent folder name: ${parentFolder}`);

      // Step 2: Create project document in MongoDB
      const { db, client } = await connectToDatabase();
      const mongoSession = await client.startSession();

      try {
        await mongoSession.withTransaction(async () => {
          // Check if project already exists
          const existingProject = await db.collection('projects').findOne({
            title: projectData.title,
            parentFolder: parentFolder
          });

          if (existingProject) {
            throw new Error('Project with this title already exists');
          }

          // Create initial project document
          const result = await db.collection<ProjectDocument>('projects').insertOne({
            ...projectData,
            createdAt: new Date(),
            updatedAt: new Date(),
            assignedTo: [],
            parentFolder: parentFolder,
            databaseName: parentFolder,
            episodes: [],
            uploadStatus: {
              totalFiles: collections.length,
              completedFiles: 0,
              currentFile: -1,
              status: 'initializing'
            }
          }, { session: mongoSession });

          console.log(`[${new Date().toISOString()}] Step 2: Created project document:`, {
            projectId: result.insertedId,
            title: projectData.title
          });

          // Step 3: Create database
          if (!/^[a-zA-Z0-9_-]+$/.test(parentFolder)) {
            throw new Error('Invalid database name. Use only letters, numbers, underscores, and hyphens');
          }

          const newDb = client.db(parentFolder);
          console.log(`[${new Date().toISOString()}] Step 3: Created database: ${parentFolder}`);

          // Update project status to ready for upload
          await db.collection<ProjectDocument>('projects').updateOne(
            { _id: result.insertedId },
            { $set: { status: 'uploading' } },
            { session: mongoSession }
          );
        });
      } finally {
        await mongoSession.endSession();
      }
    }

    // Step 4: Upload file to R2 and create folder
    if (videoFile) {
      console.log(`[${new Date().toISOString()}] Step 4: Processing file ${index + 1}/${collections.length}:`, {
        fileName: videoFile.name
      });

      try {
        // Generate folder path using parent folder structure
        const collectionName = videoFile.name.replace(/\.[^/.]+$/, "").replace(/[^a-zA-Z0-9-_]/g, '_');
        const parentFolder = projectData.title.replace(/[^a-zA-Z0-9-_]/g, '_');
        const folderPath = `${parentFolder}/${collectionName}/`;
        const key = `${folderPath}${videoFile.name}`;

        // Upload to R2
        const arrayBuffer = await videoFile.arrayBuffer();
        const buffer = Buffer.from(arrayBuffer);

        const putCommand = new PutObjectCommand({
          Bucket: BUCKET_NAME,
          Key: key,
          Body: buffer,
          ContentType: videoFile.type,
        });

        await s3Client.send(putCommand);
        console.log(`[${new Date().toISOString()}] Uploaded file to R2:`, { key });

        // Generate signed URL
        const getCommand = new GetObjectCommand({
          Bucket: BUCKET_NAME,
          Key: key,
        });

        const signedUrl = await getSignedUrl(s3Client, getCommand, { expiresIn: 3600 });
        
        uploadedFiles.push({
          name: videoFile.name,
          videoPath: signedUrl,
          videoKey: key,
          collectionName
        });

      } catch (uploadError: any) {
        console.error(`[${new Date().toISOString()}] R2 upload error:`, uploadError);
        throw uploadError;
      }
    }

    // Step 5: Update project and create collections if last file
    const { db, client } = await connectToDatabase();
    const mongoSession = await client.startSession();

    try {
      let transactionResult;
      await mongoSession.withTransaction(async () => {
        // Find the project
        const project = await db.collection<ProjectDocument>('projects').findOne({
          title: projectData.title,
          parentFolder: projectData.title.replace(/[^a-zA-Z0-9-_]/g, '_')
        });

        if (!project) {
          throw new Error('Project not found');
        }

        // Update project with new episode
        const result = await db.collection<ProjectDocument>('projects').findOneAndUpdate(
          { _id: project._id },
          {
            $push: {
              episodes: {
                $each: uploadedFiles.map(file => ({
                  name: file.name,
                  collectionName: file.collectionName,
                  videoPath: file.videoPath,
                  videoKey: file.videoKey,
                  status: 'uploaded',
                  uploadedAt: new Date()
                }))
              }
            },
            $set: {
              updatedAt: new Date(),
              uploadStatus: {
                totalFiles: collections.length,
                completedFiles: index + 1,
                currentFile: index,
                status: isLast ? 'completed' : 'uploading'
              },
              status: isLast ? 'pending' : 'uploading'
            }
          },
          { 
            returnDocument: 'after',
            session: mongoSession 
          }
        );

        if (!result) {
          throw new Error('Failed to update project');
        }

        transactionResult = result;

        // If this is the last file, create collections for all episodes
        if (isLast) {
          console.log(`[${new Date().toISOString()}] Creating collections for all episodes`);
          const allEpisodes = result.episodes || [];
          
          for (const episode of allEpisodes) {
            const collectionName = episode.collectionName;
            const newCollection = client.db(project.databaseName).collection(collectionName);
            console.log(`[${new Date().toISOString()}] Created collection: ${collectionName}`);
          }
        }
      });

      return NextResponse.json({
        success: true,
        data: transactionResult
      });
    } catch (error: any) {
      console.error(`[${new Date().toISOString()}] Operation error:`, {
        error: error.message,
        code: error.code,
        stack: error.stack
      });
      throw error;
    } finally {
      await mongoSession.endSession();
    }
  } catch (error: any) {
    console.error(`[${new Date().toISOString()}] Error processing request after ${((Date.now() - startTime) / 1000).toFixed(1)}s:`, {
      error: error.message,
      code: error.code,
      stack: error.stack
    });

    return NextResponse.json(
      { 
        error: 'Failed to process request',
        details: error.message,
        code: error.code,
        file: videoFile?.name || 'unknown'
      },
      { status: 500 }
    );
  }
}

export async function DELETE(request: NextRequest) {
  const startTime = new Date().toISOString();
  const logContext = {
    timestamp: startTime,
    endpoint: 'DELETE /api/admin/projects'
  };

  try {
    console.log('Starting project deletion process...', {
      ...logContext,
      step: 'initialization'
    });
    
    const session = await getServerSession(authOptions);
    if (!session || !session.user || session.user.role !== 'admin') {
      console.log('Unauthorized deletion attempt:', {
        ...logContext,
        step: 'authorization',
        user: session?.user,
        status: 'rejected'
      });
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // Add user info to log context
    Object.assign(logContext, {
      userId: session.user.id,
      userRole: session.user.role
    });

    // Get project ID from the URL
    const { searchParams } = new URL(request.url);
    const projectId = searchParams.get('id');

    if (!projectId) {
      console.log('Missing project ID in delete request', {
        ...logContext,
        step: 'validation',
        status: 'rejected'
      });
      return NextResponse.json({ error: 'Project ID is required' }, { status: 400 });
    }

    Object.assign(logContext, { projectId });

    console.log('Connecting to database...', {
      ...logContext,
      step: 'database_connection'
    });
    const { db, client } = await connectToDatabase();

    // Get project details before deletion
    console.log('Fetching project details...', {
      ...logContext,
      step: 'project_lookup'
    });
    const project = await db.collection('projects').findOne({ _id: new ObjectId(projectId) });

    if (!project) {
      console.log('Project not found', {
        ...logContext,
        step: 'project_lookup',
        status: 'not_found'
      });
      return NextResponse.json({ error: 'Project not found' }, { status: 404 });
    }

    // Add project info to log context
    Object.assign(logContext, {
      projectTitle: project.title,
      databaseName: project.databaseName,
      fileCount: project.filePaths?.length || 0
    });

    console.log('Project found', {
      ...logContext,
      step: 'project_lookup',
      status: 'success',
      project: {
        title: project.title,
        databaseName: project.databaseName,
        collections: project.collections,
        parentFolder: project.parentFolder,
        fileCount: project.filePaths?.length || 0
      }
    });

    // Drop the project's database if it exists
    if (project.databaseName) {
      try {
        console.log('Dropping database...', {
          ...logContext,
          step: 'database_deletion',
          databaseName: project.databaseName
        });
        await client.db(project.databaseName).dropDatabase();
        console.log('Database dropped successfully', {
          ...logContext,
          step: 'database_deletion',
          status: 'success'
        });
      } catch (error: any) {
        console.error('Error dropping database', {
          ...logContext,
          step: 'database_deletion',
          status: 'error',
          error: {
            message: error.message,
            code: error.code
          }
        });
        if (error.code !== 26) {
          throw error;
        }
        console.log('Database not found, continuing deletion', {
          ...logContext,
          step: 'database_deletion',
          status: 'skipped'
        });
      }
    }

    // Delete the project's specific files from R2
    if (project.filePaths && project.filePaths.length > 0) {
      try {
        console.log('Starting R2 file deletion...', {
          ...logContext,
          step: 'file_deletion',
          fileCount: project.filePaths.length
        });

        const deleteObjects = project.filePaths.map((filePath: string) => ({ Key: filePath }));
        
        const deleteCommand = new DeleteObjectsCommand({
          Bucket: BUCKET_NAME,
          Delete: { Objects: deleteObjects }
        });
        
        const deleteResult = await s3Client.send(deleteCommand);
        console.log('R2 deletion completed', {
          ...logContext,
          step: 'file_deletion',
          status: 'success',
          result: {
            deletedCount: deleteResult.Deleted?.length || 0,
            errorCount: deleteResult.Errors?.length || 0,
            errors: deleteResult.Errors
          }
        });
      } catch (error: any) {
        console.error('R2 deletion failed', {
          ...logContext,
          step: 'file_deletion',
          status: 'error',
          error: {
            message: error.message,
            code: error.code
          }
        });
        throw error;
      }
    } else {
      console.log('No files to delete', {
        ...logContext,
        step: 'file_deletion',
        status: 'skipped'
      });
    }

    // Delete the project from MongoDB
    console.log('Deleting project document...', {
      ...logContext,
      step: 'project_deletion'
    });
    const deleteResult = await db.collection('projects').deleteOne({ _id: new ObjectId(projectId) });
    console.log('Project document deleted', {
      ...logContext,
      step: 'project_deletion',
      status: 'success',
      result: {
        acknowledged: deleteResult.acknowledged,
        deletedCount: deleteResult.deletedCount
      }
    });

    const endTime = new Date().toISOString();
    const duration = new Date(endTime).getTime() - new Date(startTime).getTime();

    console.log('Project deletion completed', {
      ...logContext,
      step: 'completion',
      status: 'success',
      duration: `${duration}ms`,
      endTime
    });

    return NextResponse.json({
      success: true,
      message: 'Project, database, and associated files deleted successfully',
      details: {
        projectId,
        title: project.title,
        databaseDropped: true,
        filesDeleted: project.filePaths?.length || 0,
        duration: `${duration}ms`
      }
    });

  } catch (error: any) {
    const endTime = new Date().toISOString();
    const duration = new Date(endTime).getTime() - new Date(startTime).getTime();

    console.error('Project deletion failed', {
      ...logContext,
      step: 'error',
      status: 'failed',
      error: {
        message: error.message,
        code: error.code,
        type: error.constructor.name,
        stack: error.stack
      },
      duration: `${duration}ms`,
      endTime
    });

    return NextResponse.json(
      { 
        error: 'Failed to delete project',
        details: error.message,
        code: error.code,
        type: error.constructor.name
      },
      { status: 500 }
    );
  }
}

export async function GET() {
  try {
    const session = await getServerSession(authOptions);
    if (!session || !session.user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { db } = await connectToDatabase();
    const projects = await db.collection('projects').find({}).toArray();

    return NextResponse.json({
      success: true,
      data: projects,
    });

  } catch (error) {
    console.error('Error fetching projects:', error);
    return NextResponse.json(
      { error: 'Failed to fetch projects' },
      { status: 500 }
    );
  }
} 
```

## File: app\api\admin\projects\[projectId]\assign\route.ts
```ts
import { NextResponse } from 'next/server';
import { connectToDatabase } from '@/lib/mongodb';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { ObjectId, Document } from 'mongodb';

// POST assign users to project
export async function POST(
  request: Request,
  { params }: { params: { projectId: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session || session.user.role !== 'admin') {
      return NextResponse.json(
        { error: 'Unauthorized access' },
        { status: 401 }
      );
    }

    const body = await request.json();
    const { usernames } = body;

    if (!usernames || !Array.isArray(usernames)) {
      return NextResponse.json(
        { error: 'Invalid usernames' },
        { status: 400 }
      );
    }

    const { db } = await connectToDatabase();

    // Get users to assign by username
    const users = await db.collection('users')
      .find(
        { 
          username: { $in: usernames },
          isActive: true 
        },
        { projection: { username: 1, email: 1, role: 1 } }
      )
      .toArray();

    console.log('Users to assign:', users);
    console.log('Mapped users for assignment:', users.map(user => ({
      username: user.username,
      role: user.role
    })));

    if (users.length !== usernames.length) {
      return NextResponse.json(
        { error: 'One or more users not found or inactive' },
        { status: 400 }
      );
    }

    // Update project with assigned users
    const result = await db.collection('projects').updateOne(
      { _id: new ObjectId(params.projectId) },
      { 
        $set: { 
          assignedTo: users.map(user => ({
            username: user.username,
            role: user.role
          })),
          updatedAt: new Date()
        }
      }
    );

    if (result.matchedCount === 0) {
      return NextResponse.json(
        { error: 'Project not found' },
        { status: 404 }
      );
    }

    return NextResponse.json({
      success: true,
      message: 'Users assigned successfully',
      data: { assignedUsers: users }
    });
  } catch (error) {
    console.error('Error assigning users:', error);
    return NextResponse.json(
      { error: 'Failed to assign users' },
      { status: 500 }
    );
  }
}

// DELETE remove users from project
export async function DELETE(
  request: Request,
  { params }: { params: { projectId: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session || session.user.role !== 'admin') {
      return NextResponse.json(
        { error: 'Unauthorized access' },
        { status: 401 }
      );
    }

    const body = await request.json();
    const { usernames } = body;

    if (!usernames || !Array.isArray(usernames)) {
      return NextResponse.json(
        { error: 'Invalid usernames' },
        { status: 400 }
      );
    }

    const { db } = await connectToDatabase();

    // First get the project
    const project = await db.collection('projects').findOne(
      { _id: new ObjectId(params.projectId) }
    );

    if (!project) {
      return NextResponse.json(
        { error: 'Project not found' },
        { status: 404 }
      );
    }

    // Filter out the users to remove
    const updatedAssignedTo = project.assignedTo.filter(
      (user: { username: string }) => !usernames.includes(user.username)
    );

    console.log('Original assigned users:', project.assignedTo);
    console.log('Usernames to remove:', usernames);
    console.log('Updated assigned users:', updatedAssignedTo);

    // Update the project with the filtered users
    const result = await db.collection('projects').updateOne(
      { _id: new ObjectId(params.projectId) },
      { 
        $set: { 
          assignedTo: updatedAssignedTo,
          updatedAt: new Date()
        }
      }
    );

    if (result.matchedCount === 0) {
      return NextResponse.json(
        { error: 'Project not found' },
        { status: 404 }
      );
    }

    return NextResponse.json({
      success: true,
      message: 'Users removed successfully'
    });
  } catch (error) {
    console.error('Error removing users:', error);
    return NextResponse.json(
      { error: 'Failed to remove users' },
      { status: 500 }
    );
  }
} 
```

## File: app\api\admin\projects\[projectId]\progress\route.ts
```ts
import { NextResponse } from 'next/server';
import { connectToDatabase } from '@/lib/mongodb';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { ObjectId } from 'mongodb';

export async function GET(
  request: Request,
  { params }: { params: { projectId: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session || session.user.role !== 'admin') {
      return NextResponse.json(
        { error: 'Unauthorized access' },
        { status: 401 }
      );
    }

    const { db } = await connectToDatabase();
    
    // Get project to verify collection name
    const project = await db.collection('projects').findOne({
      _id: new ObjectId(params.projectId)
    });

    if (!project) {
      return NextResponse.json(
        { error: 'Project not found' },
        { status: 404 }
      );
    }

    // Get dialogues from the project's collection
    const dialogues = await db.collection(project.dialogue_collection)
      .find({ projectId: new ObjectId(params.projectId) })
      .toArray();

    const total = dialogues.length;
    
    // Calculate progress statistics
    const stats = dialogues.reduce((acc, dialogue) => {
      if (dialogue.dialogue?.original) acc.transcribed++;
      if (dialogue.dialogue?.translated) acc.translated++;
      if (dialogue.voiceOverUrl) acc.voiceOver++;
      if (dialogue.status === 'approved') acc.approved++;
      return acc;
    }, {
      transcribed: 0,
      translated: 0,
      voiceOver: 0,
      approved: 0
    });

    // Convert to percentages
    const progress = {
      transcribed: total > 0 ? Math.round((stats.transcribed / total) * 100) : 0,
      translated: total > 0 ? Math.round((stats.translated / total) * 100) : 0,
      voiceOver: total > 0 ? Math.round((stats.voiceOver / total) * 100) : 0,
      approved: total > 0 ? Math.round((stats.approved / total) * 100) : 0,
      total,
      lastUpdated: project.updatedAt
    };

    return NextResponse.json({
      success: true,
      data: progress
    });
  } catch (error) {
    console.error('Error fetching project progress:', error);
    return NextResponse.json(
      { error: 'Failed to fetch project progress' },
      { status: 500 }
    );
  }
} 
```

## File: app\api\admin\projects\[projectId]\route.ts
```ts
import { NextResponse } from 'next/server';
import { connectToDatabase } from '@/lib/mongodb';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { ObjectId } from 'mongodb';

// GET single project
export async function GET(
  request: Request,
  { params }: { params: { projectId: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session || session.user.role !== 'admin') {
      return NextResponse.json(
        { error: 'Unauthorized access' },
        { status: 401 }
      );
    }

    const { db } = await connectToDatabase();
    const project = await db.collection('projects').findOne({
      _id: new ObjectId(params.projectId)
    });

    if (!project) {
      return NextResponse.json(
        { error: 'Project not found' },
        { status: 404 }
      );
    }

    return NextResponse.json({ success: true, data: project });
  } catch (error) {
    console.error('Error fetching project:', error);
    return NextResponse.json(
      { error: 'Failed to fetch project' },
      { status: 500 }
    );
  }
}

// PATCH update project
export async function PATCH(
  request: Request,
  { params }: { params: { projectId: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session || session.user.role !== 'admin') {
      return NextResponse.json(
        { error: 'Unauthorized access' },
        { status: 401 }
      );
    }

    const body = await request.json();
    const updateData = {
      ...body,
      updatedAt: new Date()
    };

    const { db } = await connectToDatabase();
    const result = await db.collection('projects').updateOne(
      { _id: new ObjectId(params.projectId) },
      { $set: updateData }
    );

    if (result.matchedCount === 0) {
      return NextResponse.json(
        { error: 'Project not found' },
        { status: 404 }
      );
    }

    return NextResponse.json({
      success: true,
      message: 'Project updated successfully'
    });
  } catch (error) {
    console.error('Error updating project:', error);
    return NextResponse.json(
      { error: 'Failed to update project' },
      { status: 500 }
    );
  }
}

// DELETE project
export async function DELETE(
  request: Request,
  { params }: { params: { projectId: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session || session.user.role !== 'admin') {
      return NextResponse.json(
        { error: 'Unauthorized access' },
        { status: 401 }
      );
    }

    const { db } = await connectToDatabase();
    const result = await db.collection('projects').deleteOne({
      _id: new ObjectId(params.projectId)
    });

    if (result.deletedCount === 0) {
      return NextResponse.json(
        { error: 'Project not found' },
        { status: 404 }
      );
    }

    return NextResponse.json({
      success: true,
      message: 'Project deleted successfully'
    });
  } catch (error) {
    console.error('Error deleting project:', error);
    return NextResponse.json(
      { error: 'Failed to delete project' },
      { status: 500 }
    );
  }
} 
```

## File: app\api\admin\users\route.ts
```ts
import { NextResponse } from 'next/server';
import { connectToDatabase } from '@/lib/mongodb';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { hash } from 'bcryptjs';

// GET all users
export async function GET() {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session || session.user.role !== 'admin') {
      return NextResponse.json(
        { error: 'Unauthorized access' },
        { status: 401 }
      );
    }

    const { db } = await connectToDatabase();
    const users = await db.collection('users')
      .find({})
      .project({ password: 0 }) // Exclude password field
      .sort({ createdAt: -1 })
      .toArray();

    return NextResponse.json({ success: true, data: users });
  } catch (error) {
    console.error('Error fetching users:', error);
    return NextResponse.json(
      { error: 'Failed to fetch users' },
      { status: 500 }
    );
  }
}

// POST create new user
export async function POST(request: Request) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session || session.user.role !== 'admin') {
      return NextResponse.json(
        { error: 'Unauthorized access' },
        { status: 401 }
      );
    }

    const body = await request.json();
    const { username, email, password, role } = body;

    // Validate required fields
    if (!username || !email || !password || !role) {
      return NextResponse.json(
        { error: 'Missing required fields' },
        { status: 400 }
      );
    }

    const { db } = await connectToDatabase();
    
    // Check if user already exists
    const existingUser = await db.collection('users').findOne({
      $or: [{ email }, { username }]
    });

    if (existingUser) {
      return NextResponse.json(
        { error: 'User with this email or username already exists' },
        { status: 400 }
      );
    }

    // Hash password
    const hashedPassword = await hash(password, 12);

    const newUser = {
      username,
      email,
      password: hashedPassword,
      role,
      isActive: true,
      createdAt: new Date(),
      updatedAt: new Date(),
      createdBy: session.user.id
    };

    const result = await db.collection('users').insertOne(newUser);

    // Remove password from response
    const { password: _, ...userWithoutPassword } = newUser;

    return NextResponse.json({
      success: true,
      data: { ...userWithoutPassword, _id: result.insertedId }
    });
  } catch (error) {
    console.error('Error creating user:', error);
    return NextResponse.json(
      { error: 'Failed to create user' },
      { status: 500 }
    );
  }
} 
```

## File: app\api\admin\users\[userId]\route.ts
```ts
import { NextResponse } from 'next/server';
import { connectToDatabase } from '@/lib/mongodb';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { ObjectId } from 'mongodb';
import bcrypt from 'bcrypt';

// GET single user
export async function GET(
  request: Request,
  { params }: { params: { userId: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session || session.user.role !== 'admin') {
      return NextResponse.json(
        { error: 'Unauthorized access' },
        { status: 401 }
      );
    }

    const { db } = await connectToDatabase();
    const user = await db.collection('users').findOne(
      { _id: new ObjectId(params.userId) },
      { projection: { password: 0 } }
    );

    if (!user) {
      return NextResponse.json(
        { error: 'User not found' },
        { status: 404 }
      );
    }

    // Get assigned projects
    const assignedProjects = await db.collection('projects')
      .find({ 'assignedTo._id': params.userId })
      .toArray();

    return NextResponse.json({
      success: true,
      data: { ...user, assignedProjects }
    });
  } catch (error) {
    console.error('Error fetching user:', error);
    return NextResponse.json(
      { error: 'Failed to fetch user' },
      { status: 500 }
    );
  }
}

// PATCH update user
export async function PATCH(
  request: Request,
  { params }: { params: { userId: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session || session.user.role !== 'admin') {
      return NextResponse.json(
        { error: 'Unauthorized access' },
        { status: 401 }
      );
    }

    const body = await request.json();
    const updateData = {
      ...body,
      updatedAt: new Date()
    };

    // Remove password if it's empty
    if (!updateData.password) {
      delete updateData.password;
    } else if (updateData.password) {
      updateData.password = await bcrypt.hash(updateData.password, 12);
    }

    const { db } = await connectToDatabase();
    const result = await db.collection('users').updateOne(
      { _id: new ObjectId(params.userId) },
      { $set: updateData }
    );

    if (result.matchedCount === 0) {
      return NextResponse.json(
        { error: 'User not found' },
        { status: 404 }
      );
    }

    return NextResponse.json({
      success: true,
      message: 'User updated successfully'
    });
  } catch (error) {
    console.error('Error updating user:', error);
    return NextResponse.json(
      { error: 'Failed to update user' },
      { status: 500 }
    );
  }
}

// DELETE user
export async function DELETE(
  request: Request,
  { params }: { params: { userId: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session || session.user.role !== 'admin') {
      return NextResponse.json(
        { error: 'Unauthorized access' },
        { status: 401 }
      );
    }

    const { db } = await connectToDatabase();
    
    // Remove user from all projects they were assigned to
    await db.collection('projects').updateMany(
      { 'assignedTo._id': params.userId },
      { 
        $pull: { 
          assignedTo: { 
            _id: new ObjectId(params.userId) 
          } 
        } 
      } as any // Type assertion needed due to MongoDB types limitation
    );

    // Delete the user
    const result = await db.collection('users').deleteOne({
      _id: new ObjectId(params.userId)
    });

    if (result.deletedCount === 0) {
      return NextResponse.json(
        { error: 'User not found' },
        { status: 404 }
      );
    }

    return NextResponse.json({
      success: true,
      message: 'User deleted successfully'
    });
  } catch (error) {
    console.error('Error deleting user:', error);
    return NextResponse.json(
      { error: 'Failed to delete user' },
      { status: 500 }
    );
  }
} 
```

## File: app\api\auth\auth.config.ts
```ts
import CredentialsProvider from 'next-auth/providers/credentials'
import { connectToDatabase } from '@/lib/mongodb'
import bcrypt from 'bcryptjs'
import type { NextAuthOptions } from 'next-auth'

if (!process.env.NEXTAUTH_SECRET) {
  throw new Error('Please define the NEXTAUTH_SECRET environment variable')
}

export const authOptions: NextAuthOptions = {
  providers: [
    CredentialsProvider({
      name: 'Credentials',
      credentials: {
        email: { label: "Email", type: "email" },
        password: { label: "Password", type: "password" }
      },
      async authorize(credentials, req) {
        if (!credentials?.email || !credentials?.password) {
          throw new Error('Please enter your email and password')
        }

        try {
          const { db } = await connectToDatabase()
          const user = await db.collection('users').findOne({ 
            email: credentials.email 
          })

          if (!user) {
            throw new Error('Invalid email or password')
          }

          const isPasswordValid = await bcrypt.compare(
            credentials.password,
            user.password
          )

          if (!isPasswordValid) {
            throw new Error('Invalid email or password')
          }

          // Update last login and sessions log
          const sessionLog = {
            loginTime: new Date(),
            userAgent: req.headers?.['user-agent'] || 'unknown'
          }

          await db.collection('users').updateOne(
            { _id: user._id },
            {
              $set: { 
                lastLogin: new Date(),
                'sessionsLog.0': sessionLog
              }
            }
          )

          return {
            id: user._id.toString(),
            email: user.email,
            role: user.role,
            username: user.username,
            name: user.username
          }
        } catch (error) {
          console.error('Authentication error:', error)
          throw error
        }
      }
    })
  ],
  callbacks: {
    async jwt({ token, user }) {
      if (user) {
        token.id = user.id
        token.email = user.email
        token.role = user.role
        token.username = user.username
      }
      return token
    },
    async session({ session, token }) {
      if (token && session.user) {
        session.user.id = token.id as string
        session.user.email = token.email as string
        session.user.role = token.role as string
        session.user.username = token.username as string
        session.user.name = token.name as string
      }
      return session
    }
  },
  pages: {
    signIn: '/login',
  },
  session: {
    strategy: 'jwt',
    maxAge: 30 * 24 * 60 * 60, // 30 days
  },
  secret: process.env.NEXTAUTH_SECRET,
  debug: process.env.NODE_ENV === 'development',
} 
```

## File: app\api\auth\login\route.ts
```ts
import { NextResponse } from 'next/server'
import { connectToDatabase } from '@/lib/mongodb'
import bcrypt from 'bcryptjs'
import { sign } from 'jsonwebtoken'

const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key'

export async function POST(req: Request) {
  try {
    const { email, password } = await req.json()

    const { db } = await connectToDatabase()
    const user = await db.collection('users').findOne({ email })

    if (!user) {
      return NextResponse.json(
        { error: 'Invalid credentials' },
        { status: 401 }
      )
    }

    const isPasswordValid = await bcrypt.compare(password, user.password)
    if (!isPasswordValid) {
      return NextResponse.json(
        { error: 'Invalid credentials' },
        { status: 401 }
      )
    }

    // Update last login and sessions log
    const sessionLog = {
      loginTime: new Date(),
      userAgent: req.headers.get('user-agent') || 'unknown'
    }

    await db.collection('users').updateOne(
      { _id: user._id },
      { 
        $set: { 
          lastLogin: new Date(),
          sessionsLog: [sessionLog, ...(user.sessionsLog || [])]
        }
      }
    )

    // Create token
    const token = sign(
      {
        id: user._id.toString(),
        email: user.email,
        role: user.role,
        username: user.username
      },
      JWT_SECRET,
      { expiresIn: '1d' }
    )

    return NextResponse.json({
      token,
      user: {
        id: user._id.toString(),
        email: user.email,
        role: user.role,
        username: user.username
      }
    })
  } catch (error) {
    console.error('Login error:', error)
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
} 
```

## File: app\api\auth\[...nextauth]\route.ts
```ts
import NextAuth from 'next-auth'
import { authOptions } from '@/lib/auth'

const handler = NextAuth(authOptions)

export { handler as GET, handler as POST }


```

## File: app\api\dialogues\route.ts
```ts
import { NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { connectToDatabase } from '@/lib/mongodb'
import { ObjectId } from 'mongodb'
import { authOptions } from '../../../lib/auth'

export async function GET(request: Request) {
  console.log('=== API Dialogues Route Debug ===');
  
  try {
    // Check authentication
    const session = await getServerSession(authOptions);
    if (!session) {
      console.log('No session found');
      return new NextResponse(
        JSON.stringify({ error: 'Authentication required' }),
        { status: 401 }
      );
    }

    // Get query parameters
    const { searchParams } = new URL(request.url);
    const projectId = searchParams.get('projectId');
    const collection = searchParams.get('collection');

    console.log('Query params:', { projectId, collection });

    if (!projectId) {
      console.log('No projectId provided');
      return new NextResponse(
        JSON.stringify({ error: 'Project ID is required' }),
        { status: 400 }
      );
    }

    // Validate projectId format
    if (!ObjectId.isValid(projectId)) {
      console.log('Invalid projectId format');
      return new NextResponse(
        JSON.stringify({ error: 'Invalid project ID format' }),
        { status: 400 }
      );
    }

    // Connect to database
    const { db } = await connectToDatabase();
    console.log('Connected to database');

    // Get project to verify collection name
    const project = await db.collection('projects').findOne({
      _id: new ObjectId(projectId)
    });

    if (!project) {
      console.log('Project not found');
      return new NextResponse(
        JSON.stringify({ error: 'Project not found' }),
        { status: 404 }
      );
    }

    // Determine collection name from project
    const collectionName = project.dialogue_collection || collection || 'dialogues';
    console.log('Using collection:', collectionName);

    // Fetch dialogues
    const dialogues = await db.collection(collectionName)
      .find({ projectId: new ObjectId(projectId) })
      .sort({ timeStart: 1 })
      .toArray();

    // Transform ObjectIds to strings for JSON serialization
    const serializedDialogues = dialogues.map(dialogue => ({
      ...dialogue,
      _id: dialogue._id.toString(),
      projectId: dialogue.projectId.toString()
    }));

    console.log(`Found ${dialogues.length} dialogues`);
    console.log('=== End Debug ===');

    return new NextResponse(
      JSON.stringify({ 
        data: serializedDialogues,
        collection: collectionName,
        project: {
          title: project.title,
          sourceLanguage: project.sourceLanguage,
          targetLanguage: project.targetLanguage
        }
      }),
      { status: 200 }
    );

  } catch (error) {
    console.error('Error in dialogues route:', error);
    return new NextResponse(
      JSON.stringify({ error: 'Internal server error' }),
      { status: 500 }
    );
  }
}

export async function POST(request: Request) {
  console.log('\n=== POST /api/dialogues - Started ===')
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user) {
      console.error('Unauthorized access attempt to create dialogue')
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const data = await request.json()
    const { projectId, dialogue, collection } = data

    console.log('Creating dialogue:', {
      projectId,
      collection,
      dialoguePreview: dialogue ? {
        timeStart: dialogue.timeStart,
        timeEnd: dialogue.timeEnd,
        character: dialogue.character
      } : 'none'
    })

    if (!projectId || !dialogue) {
      console.error('Missing required fields')
      return NextResponse.json({ error: 'Missing required fields' }, { status: 400 })
    }

    console.log('Connecting to database...')
    const { db } = await connectToDatabase()

    // Get project to verify collection name
    const project = await db.collection('projects').findOne({
      _id: new ObjectId(projectId)
    })

    if (!project) {
      console.error('Project not found:', projectId)
      return NextResponse.json({ error: 'Project not found' }, { status: 404 })
    }

    // Use the collection from request, project, or default
    const dialogueCollection = collection || project.dialogue_collection || 'dialogues'

    console.log('Using collection:', dialogueCollection)

    // Get the next index
    const lastDialogue = await db.collection(dialogueCollection)
      .findOne({ projectId: new ObjectId(projectId) }, { sort: { index: -1 } })
    
    const nextIndex = (lastDialogue?.index || 0) + 1

    const newDialogue = {
      ...dialogue,
      projectId: new ObjectId(projectId),
      index: nextIndex,
      status: 'pending',
      createdAt: new Date(),
      updatedAt: new Date(),
      createdBy: session.user.username
    }

    console.log('Creating new dialogue:', {
      collection: dialogueCollection,
      index: nextIndex,
      projectId
    })

    const result = await db.collection(dialogueCollection).insertOne(newDialogue)

    const response = {
      ...newDialogue,
      _id: result.insertedId.toString(),
      projectId: projectId
    }

    console.log('=== POST /api/dialogues - Completed ===\n')
    return NextResponse.json(response)
  } catch (error) {
    console.error('Error creating dialogue:', error)
    return NextResponse.json(
      { error: 'Failed to create dialogue' },
      { status: 500 }
    )
  }
}


```

## File: app\api\dialogues\[id]\route.ts
```ts
import { NextResponse } from 'next/server'
import { connectToDatabase } from '@/lib/mongodb'
import { ObjectId } from 'mongodb'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/app/api/auth/auth.config'

export async function GET(
  request: Request,
  { params }: { params: { id: string } }
) {
  console.log('GET /api/dialogues/[id] - Started', { id: params.id })
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user) {
      console.error('Unauthorized access attempt to dialogue')
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    if (!ObjectId.isValid(params.id)) {
      console.error('Invalid dialogue ID format:', params.id)
      return NextResponse.json({ error: 'Invalid dialogue ID format' }, { status: 400 })
    }

    console.log('Connecting to database...')
    const { db } = await connectToDatabase()

    // First try to find the dialogue in any collection by checking project's dialogue_collection
    let dialogue = null;

    // Try to find the dialogue in any collection by checking all projects
    const projects = await db.collection('projects').find().toArray();
    
    for (const project of projects) {
      if (project.dialogue_collection) {
        const tempDialogue = await db.collection(project.dialogue_collection).findOne({
          _id: new ObjectId(params.id)
        });
        if (tempDialogue) {
          dialogue = tempDialogue;
          break;
        }
      }
    }

    // If still not found, try the default collection
    if (!dialogue) {
      dialogue = await db.collection('dialogues').findOne({
        _id: new ObjectId(params.id)
      });
    }

    if (!dialogue) {
      console.error('Dialogue not found:', params.id)
      return NextResponse.json({ error: 'Dialogue not found' }, { status: 404 })
    }

    // Check project access
    const project = await db.collection('projects').findOne({
      _id: new ObjectId(dialogue.projectId),
      'assignedTo': {
        $elemMatch: {
          username: session.user.username
        }
      }
    })

    if (!project) {
      console.error('User not authorized for this dialogue')
      return NextResponse.json({ error: 'Not authorized' }, { status: 403 })
    }

    // Transform ObjectIds to strings
    const serializedDialogue = {
      ...dialogue,
      _id: dialogue._id.toString(),
      projectId: dialogue.projectId.toString()
    }

    return NextResponse.json(serializedDialogue)
  } catch (error) {
    console.error('Error fetching dialogue:', error)
    return NextResponse.json(
      { error: 'Failed to fetch dialogue' },
      { status: 500 }
    )
  }
}

export async function PUT(
  request: Request,
  { params }: { params: { id: string } }
) {
  console.log('PUT /api/dialogues/[id] - Started', { id: params.id })
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user) {
      console.error('Unauthorized access attempt to update dialogue')
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    if (!ObjectId.isValid(params.id)) {
      console.error('Invalid dialogue ID format:', params.id)
      return NextResponse.json({ error: 'Invalid dialogue ID format' }, { status: 400 })
    }

    const updates = await request.json()
    console.log('Requested updates:', updates)

    // Handle voice-over deletion
    if (updates.deleteVoiceOver) {
      console.log('Deleting voice-over for dialogue:', params.id);
      updates.voiceOverUrl = null;
      updates.status = 'pending';
    }
    // Validate voiceOverUrl if status is voice-over-added
    else if (updates.status === 'voice-over-added' && !updates.voiceOverUrl) {
      console.error('Missing voiceOverUrl for voice-over-added status');
      return NextResponse.json(
        { error: 'Voice-over URL is required when status is voice-over-added' },
        { status: 400 }
      );
    }

    console.log('Connecting to database...')
    const { db } = await connectToDatabase()

    // First try to find the dialogue in any collection by checking project's dialogue_collection
    let dialogue = null;
    let dialogueCollection = 'dialogues';

    // Try to find the dialogue in any collection by checking all projects
    const projects = await db.collection('projects').find().toArray();
    
    for (const project of projects) {
      if (project.dialogue_collection) {
        const tempDialogue = await db.collection(project.dialogue_collection).findOne({
          _id: new ObjectId(params.id)
        });
        if (tempDialogue) {
          dialogue = tempDialogue;
          dialogueCollection = project.dialogue_collection;
          break;
        }
      }
    }

    // If still not found, try the default collection
    if (!dialogue) {
      dialogue = await db.collection('dialogues').findOne({
        _id: new ObjectId(params.id)
      });
    }

    if (!dialogue) {
      console.error('Dialogue not found:', params.id)
      return NextResponse.json({ error: 'Dialogue not found' }, { status: 404 })
    }

    // Check project access
    const project = await db.collection('projects').findOne({
      _id: new ObjectId(dialogue.projectId),
      'assignedTo': {
        $elemMatch: {
          username: session.user.username,
          role: { $in: ['transcriber', 'voiceOver'] }
        }
      }
    })

    if (!project) {
      console.error('User not authorized to update this dialogue:', {
        username: session.user.username,
        dialogueId: params.id,
        projectId: dialogue.projectId
      })
      return NextResponse.json({ error: 'Not authorized' }, { status: 403 })
    }

    // Prepare update data
    const updateData = {
      ...updates,
      updatedAt: new Date(),
      updatedBy: session.user.username
    }

    // Don't allow updating certain fields
    delete updateData._id
    delete updateData.projectId
    delete updateData.createdAt
    delete updateData.createdBy

    console.log('Applying updates:', updateData)
    const result = await db.collection(dialogueCollection).findOneAndUpdate(
      { _id: new ObjectId(params.id) },
      { $set: updateData },
      { returnDocument: 'after' }
    )

    if (!result) {
      console.error('Failed to update dialogue:', {
        id: params.id,
        collection: dialogueCollection,
        updateData
      });
      return NextResponse.json({ error: 'Failed to update dialogue' }, { status: 500 })
    }

    console.log('Update successful:', {
      id: params.id,
      collection: dialogueCollection,
      status: result.status,
      voiceOverUrl: result.voiceOverUrl
    });

    // Transform ObjectIds to strings
    const serializedDialogue = {
      ...result,
      _id: result._id.toString(),
      projectId: result.projectId.toString()
    }

    return NextResponse.json(serializedDialogue)
  } catch (error) {
    console.error('Error updating dialogue:', error)
    return NextResponse.json(
      { error: 'Failed to update dialogue' },
      { status: 500 }
    )
  }
}

export async function PATCH(
  request: Request,
  { params }: { params: { id: string } }
) {
  console.log('=== PATCH /api/dialogues/[id] Debug ===');
  try {
    // Check authentication
    const session = await getServerSession(authOptions);
    if (!session) {
      console.log('Authentication failed: No session');
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    const { db } = await connectToDatabase();
    const data = await request.json();
    const dialogueId = params.id;

    console.log('Request data:', {
      dialogueId,
      data,
      userEmail: session.user?.email
    });

    // Validate required fields
    if (!data.dialogue || !data.projectId) {
      console.log('Validation failed:', { 
        hasDialogue: !!data.dialogue, 
        hasProjectId: !!data.projectId 
      });
      return NextResponse.json({ error: 'Missing required fields' }, { status: 400 });
    }

    // First try to find the dialogue
    let dialogue = null;
    let dialogueCollection = 'dialogues';

    console.log('Searching for dialogue in collections...');
    
    // Try to find the dialogue in any collection by checking all projects
    const projects = await db.collection('projects').find().toArray();
    
    for (const project of projects) {
      if (project.dialogue_collection) {
        console.log('Checking collection:', project.dialogue_collection);
        const tempDialogue = await db.collection(project.dialogue_collection).findOne({
          _id: new ObjectId(dialogueId)
        });
        if (tempDialogue) {
          dialogue = tempDialogue;
          dialogueCollection = project.dialogue_collection;
          console.log('Found dialogue in collection:', dialogueCollection);
          break;
        }
      }
    }

    // If still not found, try the default collection
    if (!dialogue) {
      dialogue = await db.collection('dialogues').findOne({
        _id: new ObjectId(dialogueId)
      });
      console.log('Dialogue search result:', { found: !!dialogue });
    }

    if (!dialogue) {
      console.log('Dialogue not found:', dialogueId);
      return NextResponse.json({ error: 'Dialogue not found' }, { status: 404 });
    }

    // Get project to verify access
    const project = await db.collection('projects').findOne({
      _id: new ObjectId(dialogue.projectId),
      'assignedTo': {
        $elemMatch: {
          username: session.user.username
        }
      }
    });

    console.log('Project access check:', {
      projectFound: !!project,
      username: session.user.username
    });

    if (!project) {
      return NextResponse.json({ error: 'Not authorized' }, { status: 403 });
    }

    // Prepare update data
    const updateData = {
      dialogue: data.dialogue,
      character: data.character,
      status: data.status,
      timeStart: data.timeStart,
      timeEnd: data.timeEnd,
      index: data.index,
      updatedAt: new Date(),
      updatedBy: session.user.email
    };

    // Update the dialogue in the correct collection
    const result = await db.collection(dialogueCollection).findOneAndUpdate(
      { _id: new ObjectId(dialogueId) },
      { $set: updateData },
      { returnDocument: 'after' }
    );

    if (!result) {
      return NextResponse.json(
        { error: 'Failed to update dialogue' },
        { status: 400 }
      );
    }

    // Transform ObjectIds to strings for response
    const serializedDialogue = {
      ...result,
      _id: result._id.toString(),
      projectId: result.projectId.toString()
    };

    return NextResponse.json(serializedDialogue);
  } catch (error) {
    console.error('Error updating dialogue:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}

export async function DELETE(
  request: Request,
  { params }: { params: { id: string } }
) {
  console.log('DELETE /api/dialogues/[id] - Started', { id: params.id })
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user) {
      console.error('Unauthorized access attempt to delete dialogue')
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    if (!ObjectId.isValid(params.id)) {
      console.error('Invalid dialogue ID format:', params.id)
      return NextResponse.json({ error: 'Invalid dialogue ID format' }, { status: 400 })
    }

    console.log('Connecting to database...')
    const { db } = await connectToDatabase()

    // First try to find the dialogue in any collection by checking project's dialogue_collection
    let dialogue = null;

    // Try to find the dialogue in any collection by checking all projects
    const projects = await db.collection('projects').find().toArray();
    
    for (const project of projects) {
      if (project.dialogue_collection) {
        const tempDialogue = await db.collection(project.dialogue_collection).findOne({
          _id: new ObjectId(params.id)
        });
        if (tempDialogue) {
          dialogue = tempDialogue;
          break;
        }
      }
    }

    // If still not found, try the default collection
    if (!dialogue) {
      dialogue = await db.collection('dialogues').findOne({
        _id: new ObjectId(params.id)
      });
    }

    if (!dialogue) {
      console.error('Dialogue not found:', params.id)
      return NextResponse.json({ error: 'Dialogue not found' }, { status: 404 })
    }

    // Check project access
    const project = await db.collection('projects').findOne({
      _id: new ObjectId(dialogue.projectId),
      'assignedTo': {
        $elemMatch: {
          username: session.user.username
        }
      }
    })

    if (!project) {
      console.error('User not authorized to delete this dialogue')
      return NextResponse.json({ error: 'Not authorized' }, { status: 403 })
    }

    console.log('Deleting dialogue:', params.id)
    const result = await db.collection('dialogues').deleteOne({
      _id: new ObjectId(params.id)
    })

    if (result.deletedCount === 0) {
      console.error('Failed to delete dialogue:', params.id)
      return NextResponse.json({ error: 'Failed to delete dialogue' }, { status: 500 })
    }

    return NextResponse.json({ success: true })
  } catch (error) {
    console.error('Error deleting dialogue:', error)
    return NextResponse.json(
      { error: 'Failed to delete dialogue' },
      { status: 500 }
    )
  }
} 
```

## File: app\api\episodes\route.ts
```ts
import { NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/auth'
import { prisma } from '@/lib/prisma'

export async function GET(request: Request) {
  try {
    const session = await getServerSession(authOptions)
    if (!session) {
      return new NextResponse(
        JSON.stringify({ error: 'Unauthorized' }),
        { status: 401 }
      )
    }

    const { searchParams } = new URL(request.url)
    const projectId = searchParams.get('projectId')

    if (!projectId) {
      return new NextResponse(
        JSON.stringify({ error: 'Project ID is required' }),
        { status: 400 }
      )
    }

    const episodes = await prisma.episode.findMany({
      where: {
        projectId: projectId,
      },
      orderBy: {
        uploadedAt: 'desc',
      },
    })

    return new NextResponse(
      JSON.stringify({ data: episodes }),
      { status: 200 }
    )
  } catch (error) {
    console.error('Episodes fetch error:', error)
    return new NextResponse(
      JSON.stringify({ error: 'Internal Server Error' }),
      { status: 500 }
    )
  }
} 
```

## File: app\api\projects\route.ts
```ts
import { NextResponse } from 'next/server'
import { connectToDatabase } from '@/lib/mongodb'

export async function GET() {
  try {
    const { db } = await connectToDatabase()
    console.log('Connected to database')
    const projects = await db.collection('projects').find({}).toArray()
    console.log('Found projects:', projects)
    return NextResponse.json(projects)
  } catch (error) {
    console.error('Failed to fetch projects:', error)
    return NextResponse.json({ error: 'Failed to fetch projects' }, { status: 500 })
  }
}

export async function POST(req: Request) {
  try {
    const { db } = await connectToDatabase()
    const projectData = await req.json()
    
    // Add assignedTo array if not present
    const projectToCreate = {
      ...projectData,
      assignedTo: [],
      createdAt: new Date(),
      updatedAt: new Date()
    }
    
    const result = await db.collection('projects').insertOne(projectToCreate)
    return NextResponse.json({ success: true, projectId: result.insertedId })
  } catch (error) {
    console.error('Failed to create project:', error)
    return NextResponse.json({ error: 'Failed to create project' }, { status: 500 })
  }
}


```

## File: app\api\projects\[id]\assign\route.ts
```ts
import { NextResponse } from 'next/server'
import { connectToDatabase } from '@/lib/mongodb'
import { ObjectId } from 'mongodb'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/app/api/auth/auth.config'

export async function POST(
  request: Request,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user || session.user.role !== 'admin') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { username, role } = await request.json()
    const projectId = params.id

    if (!username || !role || !projectId) {
      return NextResponse.json(
        { error: 'Missing required fields' },
        { status: 400 }
      )
    }

    const { db } = await connectToDatabase()

    // First get the current project to check if user is already assigned
    const project = await db.collection('projects').findOne({
      _id: new ObjectId(projectId)
    })

    if (!project) {
      return NextResponse.json(
        { error: 'Project not found' },
        { status: 404 }
      )
    }

    // Check if user is already assigned with the same role
    const isAlreadyAssigned = project.assignedTo?.some(
      (assignment: { username: string; role: string }) =>
        assignment.username === username && assignment.role === role
    )

    if (isAlreadyAssigned) {
      return NextResponse.json(
        { error: 'User is already assigned with this role' },
        { status: 400 }
      )
    }

    // Update the project with the new assignment
    const result = await db.collection('projects').findOneAndUpdate(
      { _id: new ObjectId(projectId) },
      {
        $addToSet: { 
          assignedTo: { username, role }
        },
        $set: { updatedAt: new Date() }
      },
      { returnDocument: 'after' }
    )

    if (!result) {
      return NextResponse.json(
        { error: 'Failed to update project' },
        { status: 500 }
      )
    }

    return NextResponse.json({
      message: 'User assigned successfully',
      project: {
        ...result,
        _id: result._id.toString()
      }
    })
  } catch (error) {
    console.error('Error assigning user to project:', error)
    return NextResponse.json(
      { error: 'Failed to assign user to project' },
      { status: 500 }
    )
  }
}


```

## File: app\api\upload-audio\route.ts
```ts
import { NextResponse } from 'next/server'
import { connectToDatabase } from '@/lib/mongodb'
import { ObjectId } from 'mongodb'
import { put } from '@vercel/blob'

export async function POST(req: Request) {
  try {
    const { db } = await connectToDatabase()
    const formData = await req.formData()
    const file = formData.get('audio') as File
    const dialogueId = formData.get('dialogueId') as string

    if (!file) {
      return NextResponse.json({ error: 'No file uploaded' }, { status: 400 })
    }

    const blob = await put(file.name, file, {
      access: 'public',
    })

    // Update the dialogue with the new audio URL
    await db.collection('dialogues').updateOne(
      { _id: new ObjectId(dialogueId) },
      { $set: { audioUrl: blob.url } }
    )

    return NextResponse.json({ success: true, url: blob.url })
  } catch (error) {
    console.error('Failed to upload audio:', error)
    return NextResponse.json({ error: 'Failed to upload audio' }, { status: 500 })
  }
}


```

## File: app\api\upload-voice-over\route.ts
```ts
import { NextResponse } from 'next/server';
import { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';
import { getServerSession } from 'next-auth';
import { authOptions } from '../auth/auth.config';
import { connectToDatabase } from '@/lib/mongodb';
import { ObjectId } from 'mongodb';

// Configure request size limit and parsing
export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';
export const maxDuration = 60;

const s3Client = new S3Client({
  region: 'auto',
  endpoint: process.env.R2_BUCKET_ENDPOINT,
  credentials: {
    accessKeyId: process.env.R2_ACCESS_KEY_ID!,
    secretAccessKey: process.env.R2_SECRET_ACCESS_KEY!,
  },
  forcePathStyle: true,
});

export async function POST(request: Request) {
  console.log('Upload voice-over API called');
  try {
    // Check authentication
    const session = await getServerSession(authOptions);
    if (!session) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    console.log('Session found:', session.user);
    const formData = await request.formData();
    const audio = formData.get('audio') as File;
    const dialogueId = formData.get('dialogueId') as string;
    const projectId = formData.get('projectId') as string;

    if (!audio || !dialogueId || !projectId) {
      console.error('Missing required fields:', { audio: !!audio, dialogueId, projectId });
      return NextResponse.json({ error: 'Missing required fields' }, { status: 400 });
    }

    // Get dialogue from database to ensure correct index
    const { db } = await connectToDatabase();
    
    // First try to find the dialogue in any collection by checking project's dialogue_collection
    let dialogue = null;
    let dialogueCollection = 'dialogues';

    // Try to find the dialogue in any collection by checking all projects
    const projects = await db.collection('projects').find().toArray();
    
    for (const project of projects) {
      if (project.dialogue_collection) {
        const tempDialogue = await db.collection(project.dialogue_collection).findOne({
          _id: new ObjectId(dialogueId)
        });
        if (tempDialogue) {
          dialogue = tempDialogue;
          dialogueCollection = project.dialogue_collection;
          break;
        }
      }
    }

    // If still not found, try the default collection
    if (!dialogue) {
      dialogue = await db.collection('dialogues').findOne({
        _id: new ObjectId(dialogueId)
      });
    }

    if (!dialogue) {
      console.error('Dialogue not found:', dialogueId);
      return NextResponse.json(
        { error: 'Dialogue not found' },
        { status: 404 }
      );
    }

    const project = await db.collection('projects').findOne({
      _id: new ObjectId(projectId)
    });

    if (!project) {
      console.error('Project not found:', projectId);
      return NextResponse.json(
        { error: 'Project not found' },
        { status: 404 }
      );
    }

    console.log('Project from DB:', project);
    console.log('Dialogue from DB:', dialogue);

    if (!project.title) {
      console.error('Project title is missing');
      return NextResponse.json(
        { error: 'Project title is missing' },
        { status: 400 }
      );
    }

    const folderPath = `${project.title}/recordings/`;
    // Use dialogue.index directly from the database
    const paddedIndex = dialogue.index.toString().padStart(2, '0');
    const filename = `${project.title}_Clip_${paddedIndex}.wav`;
    const fullPath = `${folderPath}${filename}`;

    // Convert File to Buffer
    const arrayBuffer = await audio.arrayBuffer();
    const buffer = Buffer.from(arrayBuffer);

    console.log('Upload details:', {
      folderPath,
      filename,
      fullPath,
      audioSize: buffer.length,
      contentType: audio.type
    });

    // Upload to R2
    const uploadParams = {
      Bucket: process.env.R2_BUCKET_NAME!,
      Key: fullPath,
      Body: buffer,
      ContentType: 'audio/wav',
    };

    await s3Client.send(new PutObjectCommand(uploadParams));

    // Generate public URL
    const publicUrl = `https://${process.env.R2_PUBLIC_URL}/${fullPath}`;

    return NextResponse.json({ url: publicUrl });
  } catch (error) {
    console.error('Error uploading voice-over:', error);
    return NextResponse.json(
      { error: 'Failed to upload voice-over' },
      { status: 500 }
    );
  }
} 
```

## File: app\api\users\me\route.ts
```ts
import { NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/app/api/auth/auth.config'

export async function GET() {
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }
    return NextResponse.json(session.user)
  } catch {
    return NextResponse.json(
      { error: 'Failed to fetch user data' },
      { status: 500 }
    )
  }
} 
```

## File: app\api\users\route.ts
```ts
import { NextResponse } from 'next/server'
import { connectToDatabase } from '@/lib/mongodb'
import { getServerSession } from 'next-auth'

// Configure route for dynamic rendering
export const dynamic = 'force-dynamic'
export const runtime = 'nodejs'

export async function GET() {
  try {
    const session = await getServerSession()
    if (!session) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { db } = await connectToDatabase()
    const users = await db.collection('users').find({}, {
      projection: {
        password: 0, // Exclude password from response
        lastLogin: 0,
        lastLogout: 0,
        sessionsLog: 0
      }
    }).toArray()

    return NextResponse.json(users)
  } catch (error) {
    console.error('Failed to fetch users:', error)
    return NextResponse.json({ error: 'Failed to fetch users' }, { status: 500 })
  }
} 
```

## File: app\api\voice-over\upload\route.ts
```ts
import { NextRequest, NextResponse } from 'next/server';
import { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/app/api/auth/auth.config';
import { connectToDatabase } from '@/lib/mongodb';
import { ObjectId } from 'mongodb';

// Configure request size limit and parsing
export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';
export const maxDuration = 60;

const s3Client = new S3Client({
  region: 'auto',
  endpoint: process.env.R2_BUCKET_ENDPOINT,
  credentials: {
    accessKeyId: process.env.R2_ACCESS_KEY_ID!,
    secretAccessKey: process.env.R2_SECRET_ACCESS_KEY!,
  },
  forcePathStyle: true,
});

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const formData = await request.formData();
    const file = formData.get('file') as File;
    if (!file) {
      return NextResponse.json({ error: 'No file uploaded' }, { status: 400 });
    }

    const objectId = new ObjectId();
    const key = `voiceovers/${objectId.toString()}`;

    const arrayBuffer = await file.arrayBuffer();
    const buffer = Buffer.from(arrayBuffer);

    const putObjectCommand = new PutObjectCommand({
      Bucket: process.env.R2_BUCKET_NAME!,
      Key: key,
      Body: buffer,
      ContentType: file.type,
    });

    await s3Client.send(putObjectCommand);
    
    const { db } = await connectToDatabase();
    const voiceover = {
      _id: objectId,
      key,
      userId: session.user.id,
      createdAt: new Date(),
    };
    await db.collection('voiceovers').insertOne(voiceover);

    const publicUrl = `https://${process.env.R2_PUBLIC_URL}/${key}`;
    return NextResponse.json({ url: publicUrl });
  } catch (error) {
    console.error('Error uploading file:', error);
    return NextResponse.json({ error: 'Failed to upload file' }, { status: 500 });
  }
} 
```

## File: app\components\Button.tsx
```tsx
'use client'

import React, { ButtonHTMLAttributes, useEffect } from 'react'
import { lightTheme, logThemeUsage } from '@/app/styles/theme'

interface ButtonProps extends ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'primary' | 'secondary' | 'danger' | 'success'
  size?: 'sm' | 'md' | 'lg'
}

const buttonStyles = {
  base: `
    inline-flex items-center justify-center
    border border-transparent
    rounded-${lightTheme.borderRadius.default}
    font-${lightTheme.typography.weights.medium}
    transition-all ${lightTheme.transitions.default}
    focus:outline-none focus:ring-2 focus:ring-offset-2
  `,
  variants: {
    primary: {
      bg: `bg-${lightTheme.colors.accent.primary} hover:bg-${lightTheme.colors.accent.hover}`,
      text: `text-${lightTheme.colors.background.primary}`,
      ring: `focus:ring-${lightTheme.colors.accent.focus}`
    },
    secondary: {
      bg: `bg-${lightTheme.colors.text.tertiary} hover:bg-${lightTheme.colors.text.secondary}`,
      text: `text-${lightTheme.colors.background.primary}`,
      ring: `focus:ring-${lightTheme.colors.text.secondary}`
    },
    danger: {
      bg: `bg-${lightTheme.colors.status.error} hover:bg-${lightTheme.colors.status.error}/90`,
      text: `text-${lightTheme.colors.background.primary}`,
      ring: `focus:ring-${lightTheme.colors.status.error}`
    },
    success: {
      bg: `bg-${lightTheme.colors.status.success} hover:bg-${lightTheme.colors.status.success}/90`,
      text: `text-${lightTheme.colors.background.primary}`,
      ring: `focus:ring-${lightTheme.colors.status.success}`
    }
  },
  sizes: {
    sm: `px-${lightTheme.spacing[2]} py-${lightTheme.spacing[1]} text-${lightTheme.typography.sizes.sm}`,
    md: `px-${lightTheme.spacing[4]} py-${lightTheme.spacing[2]} text-${lightTheme.typography.sizes.base}`,
    lg: `px-${lightTheme.spacing[6]} py-${lightTheme.spacing[3]} text-${lightTheme.typography.sizes.lg}`
  }
}

export default function Button({
  variant = 'primary',
  size = 'md',
  className = '',
  children,
  onClick,
  ...props
}: ButtonProps) {
  useEffect(() => {
    logThemeUsage('Button', {
      variant,
      size,
      appliedStyles: {
        base: buttonStyles.base,
        variant: buttonStyles.variants[variant],
        size: buttonStyles.sizes[size],
        custom: className
      }
    })
  }, [variant, size, className])

  const handleClick = (e: React.MouseEvent<HTMLButtonElement>) => {
    logThemeUsage('Button', {
      event: 'click',
      variant,
      size,
      styles: {
        variant: buttonStyles.variants[variant],
        size: buttonStyles.sizes[size]
      }
    })
    onClick?.(e)
  }

  const variantStyle = buttonStyles.variants[variant]
  const sizeStyle = buttonStyles.sizes[size]

  return (
    <button
      className={`
        ${buttonStyles.base}
        ${variantStyle.bg}
        ${variantStyle.text}
        ${variantStyle.ring}
        ${sizeStyle}
        ${className}
      `}
      onClick={handleClick}
      {...props}
    >
      {children}
    </button>
  )
} 
```

## File: app\components\Card.tsx
```tsx
'use client'

import React, { ReactNode, useEffect } from 'react'
import { lightTheme, logThemeUsage } from '@/app/styles/theme'

interface CardProps {
  children: ReactNode
  title?: string
  className?: string
  headerAction?: ReactNode
  onClick?: () => void
}

const cardStyles = {
  base: `
    bg-${lightTheme.colors.background.primary}
    rounded-${lightTheme.borderRadius.lg}
    ${lightTheme.shadows.md}
    overflow-hidden
    transition-all ${lightTheme.transitions.default}
  `,
  header: {
    wrapper: `
      px-${lightTheme.spacing[6]}
      py-${lightTheme.spacing[4]}
      border-b border-${lightTheme.colors.border.light}
      flex justify-between items-center
      bg-${lightTheme.colors.background.secondary}
    `,
    title: `
      text-${lightTheme.typography.sizes.lg}
      font-${lightTheme.typography.weights.medium}
      text-${lightTheme.colors.text.primary}
      leading-${lightTheme.typography.lineHeights.normal}
    `
  },
  content: `
    px-${lightTheme.spacing[6]}
    py-${lightTheme.spacing[4]}
  `,
  interactive: `
    cursor-pointer
    hover:${lightTheme.shadows.lg}
    active:${lightTheme.shadows.sm}
    focus:outline-none
    focus:ring-2
    focus:ring-${lightTheme.colors.accent.focus}
    focus:ring-offset-2
  `
}

export default function Card({ children, title, className = '', headerAction, onClick }: CardProps) {
  useEffect(() => {
    logThemeUsage('Card', {
      hasTitle: !!title,
      hasHeaderAction: !!headerAction,
      isClickable: !!onClick,
      appliedStyles: {
        base: cardStyles.base,
        header: cardStyles.header,
        content: cardStyles.content,
        interactive: onClick ? cardStyles.interactive : '',
        customClass: className
      }
    })
  }, [title, headerAction, onClick, className])

  const handleClick = () => {
    if (onClick) {
      logThemeUsage('Card', {
        event: 'click',
        styles: {
          base: cardStyles.base,
          interactive: cardStyles.interactive
        }
      })
      onClick()
    }
  }

  return (
    <div 
      className={`
        ${cardStyles.base}
        ${onClick ? cardStyles.interactive : ''}
        ${className}
      `}
      onClick={handleClick}
      role={onClick ? "button" : undefined}
      tabIndex={onClick ? 0 : undefined}
    >
      {(title || headerAction) && (
        <div className={cardStyles.header.wrapper}>
          {title && (
            <h3 className={cardStyles.header.title}>{title}</h3>
          )}
          {headerAction && <div>{headerAction}</div>}
        </div>
      )}
      <div className={cardStyles.content}>
        {children}
      </div>
    </div>
  )
} 
```

## File: app\components\ThemeToggle.tsx
```tsx
'use client'

import { useEffect, useState } from 'react'
import { Moon, Sun } from 'lucide-react'

export default function ThemeToggle() {
  const [theme, setTheme] = useState('dark')
  const [mounted, setMounted] = useState(false)

  useEffect(() => {
    // Check local storage or use dark as default
    const savedTheme = localStorage.getItem('theme') || 'dark'
    setTheme(savedTheme)
    document.documentElement.classList.toggle('dark', savedTheme === 'dark')
    setMounted(true)
  }, [])

  const toggleTheme = () => {
    const newTheme = theme === 'light' ? 'dark' : 'light'
    setTheme(newTheme)
    localStorage.setItem('theme', newTheme)
    document.documentElement.classList.toggle('dark')
  }

  // Prevent hydration mismatch by not rendering until mounted
  if (!mounted) {
    return null
  }

  return (
    <button
      type="button"
      onClick={toggleTheme}
      className="p-2 rounded-full bg-muted hover:bg-muted/80 transition-colors"
      aria-label="Toggle theme"
      suppressHydrationWarning
    >
      {theme === 'light' ? (
        <Moon className="h-5 w-5" />
      ) : (
        <Sun className="h-5 w-5" />
      )}
    </button>
  )
} 
```

## File: app\globals.css
```css
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --background: 0 0% 100%;
  --foreground: 222.2 84% 4.9%;
  --card: 0 0% 100%;
  --card-foreground: 222.2 84% 4.9%;
  --popover: 0 0% 100%;
  --popover-foreground: 222.2 84% 4.9%;
  --primary: 221.2 83.2% 53.3%;
  --primary-foreground: 210 40% 98%;
  --secondary: 210 40% 96.1%;
  --secondary-foreground: 222.2 47.4% 11.2%;
  --muted: 210 40% 96.1%;
  --muted-foreground: 215.4 16.3% 46.9%;
  --accent: 210 40% 96.1%;
  --accent-foreground: 222.2 47.4% 11.2%;
  --destructive: 0 84.2% 60.2%;
  --destructive-foreground: 210 40% 98%;
  --border: 214.3 31.8% 91.4%;
  --input: 214.3 31.8% 91.4%;
  --ring: 221.2 83.2% 53.3%;
  --radius: 0.5rem;
}

/* Dark theme colors */
.dark {
  --background: 222.2 84% 4.9%;
  --foreground: 210 40% 98%;
  --card: 222.2 84% 4.9%;
  --card-foreground: 210 40% 98%;
  --popover: 222.2 84% 4.9%;
  --popover-foreground: 210 40% 98%;
  --primary: 217.2 91.2% 59.8%;
  --primary-foreground: 222.2 47.4% 11.2%;
  --secondary: 217.2 32.6% 17.5%;
  --secondary-foreground: 210 40% 98%;
  --muted: 217.2 32.6% 17.5%;
  --muted-foreground: 215 20.2% 65.1%;
  --accent: 217.2 32.6% 17.5%;
  --accent-foreground: 210 40% 98%;
  --destructive: 0 62.8% 30.6%;
  --destructive-foreground: 210 40% 98%;
  --border: 217.2 32.6% 17.5%;
  --input: 217.2 32.6% 17.5%;
  --ring: 224.3 76.3% 48%;
}

/* Ensure proper text visibility in dark mode */
.dark body {
  @apply bg-background text-foreground;
}

/* Base styles */
body {
  @apply bg-background text-foreground;
}

/* Ensure text visibility in various contexts */
.text-gray-500 {
  @apply text-muted-foreground;
}

.text-gray-600 {
  @apply text-foreground/70;
}

.text-gray-700 {
  @apply text-foreground/80;
}

/* Ensure proper contrast for form elements */
input, select, textarea {
  @apply bg-background text-foreground border-input;
}

/* Ensure proper contrast for buttons */
button {
  @apply disabled:opacity-50 disabled:cursor-not-allowed;
}

/* Ensure proper contrast for cards and containers */
.bg-gray-50 {
  @apply bg-muted text-muted-foreground;
}

.bg-white {
  @apply bg-background text-foreground;
}

/* Dark mode specific overrides */
.dark .bg-white {
  @apply bg-background text-foreground;
}

.dark .border {
  @apply border-border;
}

.dark .shadow-lg {
  @apply shadow-[0_10px_15px_-3px_rgba(0,0,0,0.3)];
}

.dark input, .dark select, .dark textarea {
  @apply border-input bg-background text-foreground;
}


```

## File: app\layout.tsx
```tsx
import type { Metadata } from 'next'
import { Inter } from 'next/font/google'
import './globals.css'
import { Providers } from './providers'
import dynamic from 'next/dynamic'
import SystemInit from '@/components/SystemInit'

const SpeedInsights = dynamic(() => 
  process.env.NODE_ENV === 'production'
    ? import('@vercel/speed-insights/next').then(mod => mod.SpeedInsights)
    : Promise.resolve(() => null)
, { ssr: false })

const inter = Inter({ subsets: ['latin'] })

export const metadata: Metadata = {
  title: 'QA App',
  description: 'Quality Assurance Application',
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en" suppressHydrationWarning>
      <body className={inter.className}>
        <script
          dangerouslySetInnerHTML={{
            __html: `
              try {
                let theme = localStorage.getItem('theme')
                if (!theme) {
                  localStorage.setItem('theme', 'dark')
                  theme = 'dark'
                }
                if (theme === 'dark') {
                  document.documentElement.classList.add('dark')
                }
              } catch (e) {}
            `,
          }}
        />
        <Providers>
          <SystemInit />
          {children}
        </Providers>
        <SpeedInsights />
      </body>
    </html>
  )
}


```

## File: app\login\page.tsx
```tsx
'use client'

import { useState } from 'react'
import { signIn } from 'next-auth/react'
import ThemeToggle from '../components/ThemeToggle'

export default function Login() {
  const [username, setUsername] = useState('')
  const [password, setPassword] = useState('')
  const [error, setError] = useState('')
  const [isLoading, setIsLoading] = useState(false)

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    console.log('Login attempt initiated:', { 
      username,
      timestamp: new Date().toISOString(),
      userAgent: window.navigator.userAgent
    })
    setIsLoading(true)
    setError('')

    try {
      console.log('Calling NextAuth signIn with credentials')
      const result = await signIn('credentials', {
        username,
        password,
        redirect: true,
        callbackUrl: '/allDashboards'
      })

      console.log('SignIn result:', {
        timestamp: new Date().toISOString(),
        success: !result?.error,
        hasError: !!result?.error,
        error: result?.error,
        callbackUrl: '/allDashboards'
      })

      if (result?.error) {
        console.error('Login error from NextAuth:', {
          error: result.error,
          timestamp: new Date().toISOString()
        })
        setError(result.error)
      } else {
        console.log('Login successful, redirecting to dashboard')
      }
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Unknown error'
      console.error('Unexpected login error:', {
        error: errorMessage,
        timestamp: new Date().toISOString(),
        type: err instanceof Error ? err.constructor.name : typeof err
      })
      setError('An error occurred during login')
    } finally {
      console.log('Login attempt completed:', {
        timestamp: new Date().toISOString(),
        success: !error,
        username
      })
      setIsLoading(false)
    }
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-background">
      <div className="fixed top-4 right-4">
        <ThemeToggle />
      </div>
      
      <div className="bg-card p-8 rounded-lg shadow-lg w-full max-w-md">
        <h1 className="text-2xl font-bold text-center mb-6 text-foreground">Login</h1>
        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <label htmlFor="username" className="block text-sm font-medium text-foreground mb-1">
              Username
            </label>
            <input
              type="text"
              id="username"
              value={username}
              onChange={(e) => setUsername(e.target.value)}
              className="w-full p-2 rounded-md border bg-background text-foreground"
              required
            />
          </div>
          <div>
            <label htmlFor="password" className="block text-sm font-medium text-foreground mb-1">
              Password
            </label>
            <input
              type="password"
              id="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              className="w-full p-2 rounded-md border bg-background text-foreground"
              required
            />
          </div>
          {error && (
            <div className="text-red-500 text-sm text-center">
              {error}
            </div>
          )}
          <button
            type="submit"
            disabled={isLoading}
            className={`w-full py-2 rounded-md text-white transition-colors ${
              isLoading
                ? 'bg-gray-400 cursor-not-allowed'
                : 'bg-primary hover:bg-primary/90'
            }`}
          >
            {isLoading ? 'Logging in...' : 'Login'}
          </button>
        </form>
      </div>
    </div>
  )
}


```

## File: app\page.tsx
```tsx
import { redirect } from "next/navigation"

export default function Home() {
  redirect("/allDashboards")
}


```

## File: app\providers.tsx
```tsx
'use client'

import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { SessionProvider } from 'next-auth/react'
import { useState } from 'react'

export function Providers({ children }: { children: React.ReactNode }) {
  const [queryClient] = useState(() => new QueryClient({
    defaultOptions: {
      queries: {
        staleTime: 5 * 60 * 1000, // 5 minutes
        gcTime: 30 * 60 * 1000, // 30 minutes
        refetchOnWindowFocus: false,
        retry: 1
      }
    }
  }))

  return (
    <QueryClientProvider client={queryClient}>
      <SessionProvider>{children}</SessionProvider>
    </QueryClientProvider>
  )
} 
```

## File: app\styles\styleLogger.ts
```ts
import { CSSProperties } from 'react';

type StyleValue = string | number | CSSProperties;
type StyleMap = Record<string, StyleValue>;

interface LoggerOptions {
  prefix?: string;
  suffix?: string;
  separator?: string;
}

class StyleLogger {
  private styles: StyleMap;
  private options: LoggerOptions;

  constructor(options: LoggerOptions = {}) {
    this.styles = {};
    this.options = {
      prefix: options.prefix || '',
      suffix: options.suffix || '',
      separator: options.separator || ' ',
    };
  }

  log(key: string, value: StyleValue): void {
    this.styles[key] = value;
  }

  logMultiple(styles: StyleMap): void {
    Object.entries(styles).forEach(([key, value]) => {
      this.log(key, value);
    });
  }

  getStyleString(): string {
    return Object.entries(this.styles)
      .map(([key, value]) => {
        if (typeof value === 'object') {
          return Object.entries(value as CSSProperties)
            .map(([prop, val]) => `${key}-${prop}: ${val}`)
            .join(this.options.separator);
        }
        return `${key}: ${value}`;
      })
      .join(this.options.separator);
  }

  getFormattedStyle(customOptions?: Partial<LoggerOptions>): string {
    const options = { ...this.options, ...customOptions };
    const styleString = this.getStyleString();
    return `${options.prefix}${styleString}${options.suffix}`;
  }

  clear(): void {
    this.styles = {};
  }

  getStyles(): StyleMap {
    return { ...this.styles };
  }

  setOptions(options: Partial<LoggerOptions>): void {
    this.options = { ...this.options, ...options };
  }

  getOptions(): LoggerOptions {
    return { ...this.options };
  }
}

export default StyleLogger; 
```

## File: app\styles\theme.ts
```ts
export const lightTheme = {
  colors: {
    background: {
      primary: '#ffffff',
      secondary: '#f9fafb',
      tertiary: '#f3f4f6'
    },
    text: {
      primary: '#111827',
      secondary: '#374151',
      tertiary: '#6b7280'
    },
    accent: {
      primary: '#2563eb',
      hover: '#1d4ed8',
      focus: '#3b82f6'
    },
    border: {
      light: '#e5e7eb',
      default: '#d1d5db',
      dark: '#9ca3af'
    },
    status: {
      success: '#22c55e',
      error: '#ef4444',
      warning: '#f59e0b',
      info: '#3b82f6'
    }
  },
  spacing: {
    0: '0px',
    1: '0.25rem',
    2: '0.5rem',
    3: '0.75rem',
    4: '1rem',
    5: '1.25rem',
    6: '1.5rem',
    8: '2rem',
    10: '2.5rem',
    12: '3rem',
    16: '4rem'
  },
  borderRadius: {
    none: '0px',
    sm: '0.125rem',
    default: '0.25rem',
    md: '0.375rem',
    lg: '0.5rem',
    xl: '0.75rem',
    '2xl': '1rem',
    full: '9999px'
  },
  typography: {
    fonts: {
      sans: 'ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
      mono: 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace'
    },
    sizes: {
      xs: '0.75rem',
      sm: '0.875rem',
      base: '1rem',
      lg: '1.125rem',
      xl: '1.25rem',
      '2xl': '1.5rem',
      '3xl': '1.875rem',
      '4xl': '2.25rem'
    },
    weights: {
      normal: '400',
      medium: '500',
      semibold: '600',
      bold: '700'
    },
    lineHeights: {
      none: '1',
      tight: '1.25',
      normal: '1.5',
      relaxed: '1.75'
    }
  },
  shadows: {
    none: 'none',
    sm: '0 1px 2px 0 rgba(0, 0, 0, 0.05)',
    default: '0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px -1px rgba(0, 0, 0, 0.1)',
    md: '0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1)',
    lg: '0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -4px rgba(0, 0, 0, 0.1)',
    xl: '0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 8px 10px -6px rgba(0, 0, 0, 0.1)'
  },
  transitions: {
    default: '150ms cubic-bezier(0.4, 0, 0.2, 1)',
    fast: '100ms cubic-bezier(0.4, 0, 0.2, 1)',
    slow: '300ms cubic-bezier(0.4, 0, 0.2, 1)'
  }
} as const;

export type Theme = typeof lightTheme;

// Type-safe utility functions
export const styleUtils = {
  getColor: (path: keyof Theme['colors']) => lightTheme.colors[path],
  getSpacing: (size: keyof Theme['spacing']) => lightTheme.spacing[size],
  getRadius: (size: keyof Theme['borderRadius']) => lightTheme.borderRadius[size],
  getShadow: (size: keyof Theme['shadows']) => lightTheme.shadows[size],
  getFontSize: (size: keyof Theme['typography']['sizes']) => lightTheme.typography.sizes[size],
  getFontWeight: (weight: keyof Theme['typography']['weights']) => lightTheme.typography.weights[weight],
  getLineHeight: (height: keyof Theme['typography']['lineHeights']) => lightTheme.typography.lineHeights[height],
  getTransition: (speed: keyof Theme['transitions']) => lightTheme.transitions[speed]
};

// Logging utility
export const logThemeUsage = (component: string, styles: Record<string, unknown>) => {
  console.log(`Theme Usage - ${component}:`, {
    timestamp: new Date().toISOString(),
    component,
    appliedStyles: styles,
    themeTokens: {
      colors: Object.keys(lightTheme.colors),
      spacing: Object.keys(lightTheme.spacing),
      borderRadius: Object.keys(lightTheme.borderRadius),
      typography: {
        sizes: Object.keys(lightTheme.typography.sizes),
        weights: Object.keys(lightTheme.typography.weights),
        lineHeights: Object.keys(lightTheme.typography.lineHeights)
      },
      shadows: Object.keys(lightTheme.shadows),
      transitions: Object.keys(lightTheme.transitions)
    }
  });
}; 
```

## File: components\AdminView.tsx
```tsx
import { Project, ProjectStatus, Episode } from '@/types/project'
import { User, UserRole } from '@/types/user'
import { useState } from 'react'
import { useRouter } from 'next/navigation'
import { useQueryClient, useQuery } from '@tanstack/react-query'
import axios from 'axios'
import { Search, Plus, Filter, MoreVertical, Users, Settings, ChartBar, Trash2, Edit3, UserPlus, UserMinus } from 'lucide-react'

interface AdminViewProps {
  projects: Project[];
  refetchProjects: () => Promise<any>;
}

interface UploadProgressData {
  loaded: number;
  total: number;
  phase: 'pending' | 'uploading' | 'creating-collection' | 'processing' | 'success' | 'error';
  message?: string;
}

const STATUS_COLORS = {
  'pending': 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900/50 dark:text-yellow-300',
  'in-progress': 'bg-blue-100 text-blue-800 dark:bg-blue-900/50 dark:text-blue-300',
  'completed': 'bg-green-100 text-green-800 dark:bg-green-900/50 dark:text-green-300',
  'on-hold': 'bg-red-100 text-red-800 dark:bg-red-900/50 dark:text-red-300'
} as const;

type Tab = 'projects' | 'users';

const formatBytes = (bytes: number, decimals: number = 2) => {
  if (bytes === 0) return '0 MB';
  const k = 1024;
  const dm = decimals < 0 ? 0 : decimals;
  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`;
};

const getTimeStamp = () => {
  return new Date().toISOString();
};

export default function AdminView({ projects, refetchProjects }: AdminViewProps) {
  const [activeTab, setActiveTab] = useState<Tab>('projects');
  const [isCreating, setIsCreating] = useState(false);
  const [isCreatingUser, setIsCreatingUser] = useState(false);
  const [searchTerm, setSearchTerm] = useState('');
  const [filterStatus, setFilterStatus] = useState<ProjectStatus | 'all'>('all');
  const [selectedProject, setSelectedProject] = useState<Project | null>(null);
  const [selectedUser, setSelectedUser] = useState<User | null>(null);
  const [showDeleteConfirm, setShowDeleteConfirm] = useState(false);
  const [showUserDeleteConfirm, setShowUserDeleteConfirm] = useState(false);
  const [isEditing, setIsEditing] = useState(false);
  const [viewMode, setViewMode] = useState<'grid' | 'list'>('grid');
  const [sortBy, setSortBy] = useState<'title' | 'date' | 'status'>('date');
  
  const [newProject, setNewProject] = useState({
    title: '',
    description: '',
    sourceLanguage: '',
    targetLanguage: '',
    status: 'pending' as ProjectStatus,
    videoFiles: [] as File[]
  });

  const [newUser, setNewUser] = useState({
    username: '',
    email: '',
    password: '',
    role: 'transcriber' as UserRole,
    isActive: true
  });
  
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');
  const router = useRouter();
  const queryClient = useQueryClient();
  const [isAssigning, setIsAssigning] = useState(false);
  const [selectedUsernames, setSelectedUsernames] = useState<string[]>([]);

  const [uploadProgress, setUploadProgress] = useState<Record<string, UploadProgressData>>({});
  const [uploadStatus, setUploadStatus] = useState<Record<string, 'pending' | 'uploading' | 'success' | 'error'>>({});

  const [selectedEpisode, setSelectedEpisode] = useState<Episode | null>(null);

  const { data: users = [], isLoading: isLoadingUsers } = useQuery<User[]>({
    queryKey: ['users'],
    queryFn: async () => {
      const response = await axios.get('/api/admin/users');
      return response.data.data;
    }
  });

  // Filter and sort projects
  const filteredProjects = projects
    .filter((project: Project) => {
      const matchesSearch = project.title.toLowerCase().includes(searchTerm.toLowerCase()) ||
                          project.description.toLowerCase().includes(searchTerm.toLowerCase());
      const matchesStatus = filterStatus === 'all' || project.status === filterStatus;
      return matchesSearch && matchesStatus;
    })
    .sort((a: Project, b: Project) => {
      switch (sortBy) {
        case 'title':
          return a.title.localeCompare(b.title);
        case 'status':
          return a.status.localeCompare(b.status);
        case 'date':
        default:
          return new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime();
      }
    });

  // Filter users
  const filteredUsers = users.filter(user =>
    user.username.toLowerCase().includes(searchTerm.toLowerCase()) ||
    user.email.toLowerCase().includes(searchTerm.toLowerCase())
  );

  const handleCreateProject = async (e: React.FormEvent) => {
    e.preventDefault();
    const startTime = Date.now();
    try {
      console.log(`[${getTimeStamp()}] Starting project creation with payload:`, {
        title: newProject.title,
        description: newProject.description,
        sourceLanguage: newProject.sourceLanguage,
        targetLanguage: newProject.targetLanguage,
        totalFiles: newProject.videoFiles.length,
        fileNames: newProject.videoFiles.map(f => f.name),
        totalSize: newProject.videoFiles.reduce((acc, file) => acc + file.size, 0)
      });
      
      // Validate required fields
      const requiredFields = ['title', 'description', 'sourceLanguage', 'targetLanguage'];
      const missingFields = requiredFields.filter(field => !newProject[field as keyof typeof newProject]);
      
      if (missingFields.length > 0) {
        console.error('Validation failed - Missing required fields:', missingFields);
        setError(`Missing required fields: ${missingFields.join(', ')}`);
        return;
      }

      // Validate if files are selected
      if (newProject.videoFiles.length === 0) {
        console.error('Validation failed - No files selected');
        setError('Please select at least one video file');
        return;
      }

      // Initialize upload status for all files
      const initialStatus = {} as Record<string, 'pending' | 'uploading' | 'success' | 'error'>;
      newProject.videoFiles.forEach(file => {
        initialStatus[file.name] = 'pending';
      });
      console.log(`[${getTimeStamp()}] Initializing upload status:`, initialStatus);
      setUploadStatus(initialStatus);

      // Variable to store project ID for subsequent uploads
      let projectId: string | undefined;
      let hasError = false;

      // Create project metadata
      const projectMetadata = {
        title: newProject.title,
        description: newProject.description,
        sourceLanguage: newProject.sourceLanguage,
        targetLanguage: newProject.targetLanguage,
        status: newProject.status,
        databaseName: newProject.title.replace(/[^a-zA-Z0-9-_]/g, '_'),
        collections: [] as string[],
        filePaths: [] as string[]
      };

      console.log('Project metadata created:', projectMetadata);

      // Create parent folder name
      const parentFolder = projectMetadata.databaseName;

      // Prepare all files metadata first
      newProject.videoFiles.forEach((file, index) => {
        const collectionName = file.name.replace(/\.[^/.]+$/, "").replace(/[^a-zA-Z0-9-_]/g, '_');
        const filePath = `${parentFolder}/${collectionName}/${file.name}`;
        projectMetadata.collections.push(collectionName);
        projectMetadata.filePaths.push(filePath);
      });

      // Upload files in parallel with a concurrency limit of 3
      const concurrencyLimit = 3;
      const files = [...newProject.videoFiles];
      const uploadPromises: Promise<any>[] = [];
      let completedUploads = 0;

      const uploadFile = async (file: File, index: number) => {
        const fileStartTime = Date.now();
        console.log(`[${getTimeStamp()}] Starting upload for file ${index + 1}/${newProject.videoFiles.length}:`, {
          fileName: file.name,
          fileSize: formatBytes(file.size),
          fileType: file.type
        });

        setUploadProgress(prev => ({
          ...prev,
          [file.name]: {
            loaded: 0,
            total: file.size,
            phase: 'uploading',
            message: 'Preparing upload...'
          }
        }));

        const formData = new FormData();
        const collectionName = file.name.replace(/\.[^/.]+$/, "").replace(/[^a-zA-Z0-9-_]/g, '_');
        const filePath = `${parentFolder}/${collectionName}/${file.name}`;

        // Add required fields
        formData.append('title', newProject.title);
        formData.append('description', newProject.description);
        formData.append('sourceLanguage', newProject.sourceLanguage);
        formData.append('targetLanguage', newProject.targetLanguage);
        formData.append('dialogue_collection', collectionName);
        formData.append('status', newProject.status);
        formData.append('parentFolder', parentFolder);

        const fileMetadata = {
          databaseName: projectMetadata.databaseName,
          collections: projectMetadata.collections,
          filePaths: projectMetadata.filePaths,
          parentFolder: parentFolder,
          currentFile: {
            index,
            total: newProject.videoFiles.length,
            isFirst: index === 0,
            isLast: index === newProject.videoFiles.length - 1,
            projectId: projectId
          }
        };

        formData.append('metadata', JSON.stringify(fileMetadata));
        formData.append('video', file);

        try {
          console.log(`[${getTimeStamp()}] Initiating upload request for file:`, file.name);
          let lastProgressUpdate = Date.now();
          let uploadStartTime = Date.now();
          let uploadSpeed = 0;

          const response = await axios.post('/api/admin/projects', formData, {
            headers: {
              'Content-Type': 'multipart/form-data',
            },
            maxContentLength: Infinity,
            maxBodyLength: Infinity,
            onUploadProgress: (progressEvent) => {
              if (progressEvent.total) {
                const currentTime = Date.now();
                const timeSinceLastUpdate = (currentTime - lastProgressUpdate) / 1000;
                const bytesSinceLastUpdate = progressEvent.loaded - (uploadProgress[file.name]?.loaded || 0);
                uploadSpeed = bytesSinceLastUpdate / timeSinceLastUpdate;

                const remainingBytes = progressEvent.total - progressEvent.loaded;
                const estimatedTimeRemaining = remainingBytes / uploadSpeed;

                const progress = Math.round((progressEvent.loaded * 100) / progressEvent.total);
                console.log(`[${getTimeStamp()}] Upload progress for ${file.name}: ${progress}%`, {
                  loaded: formatBytes(progressEvent.loaded),
                  total: formatBytes(progressEvent.total),
                  speed: `${formatBytes(uploadSpeed)}/s`,
                  timeElapsed: `${((currentTime - uploadStartTime) / 1000).toFixed(1)}s`,
                  estimatedTimeRemaining: `${estimatedTimeRemaining.toFixed(1)}s`
                });
                
                const newProgressData: UploadProgressData = {
                  loaded: progressEvent.loaded,
                  total: progressEvent.total,
                  phase: 'uploading',
                  message: `Uploading: ${formatBytes(uploadSpeed)}/s â€¢ ${estimatedTimeRemaining.toFixed(1)}s remaining`
                };
                
                setUploadProgress(prev => ({
                  ...prev,
                  [file.name]: newProgressData
                }));

                lastProgressUpdate = currentTime;
              }
            }
          });

          if (!response.data.success) {
            throw new Error(response.data.message || `Failed to upload file ${file.name}`);
          }

          // Store the project ID from the first upload
          if (index === 0) {
            projectId = response.data.data._id;
          }

          completedUploads++;
          const uploadDuration = (Date.now() - fileStartTime) / 1000;
          console.log(`[${getTimeStamp()}] Upload completed for ${file.name}:`, {
            duration: `${uploadDuration.toFixed(1)}s`,
            averageSpeed: `${formatBytes(file.size / uploadDuration)}/s`,
            completedUploads,
            totalFiles: newProject.videoFiles.length
          });

          setUploadProgress(prev => ({
            ...prev,
            [file.name]: {
              ...prev[file.name],
              phase: 'success',
              message: `Completed â€¢ Collection: ${collectionName}`
            }
          }));

          return response;
        } catch (error: any) {
          hasError = true;
          setUploadProgress(prev => ({
            ...prev,
            [file.name]: {
              ...prev[file.name],
              phase: 'error',
              message: error.message
            }
          }));
          throw error;
        }
      };

      // Process files in parallel with concurrency limit
      while (files.length > 0 || uploadPromises.length > 0) {
        while (files.length > 0 && uploadPromises.length < concurrencyLimit) {
          const file = files.shift();
          if (file) {
            const index = newProject.videoFiles.indexOf(file);
            uploadPromises.push(uploadFile(file, index));
          }
        }

        if (uploadPromises.length > 0) {
          await Promise.race(uploadPromises.map((p, i) => 
            p.catch(e => ({ error: e, index: i }))
          ));
          
          // Remove completed promises
          uploadPromises.forEach((promise, index) => {
            Promise.resolve(promise).then(
              () => {
                uploadPromises.splice(index, 1);
              },
              () => {
                uploadPromises.splice(index, 1);
              }
            );
          });
        }
      }

      const totalDuration = (Date.now() - startTime) / 1000;
      console.log(`[${getTimeStamp()}] All files uploaded successfully:`, {
        totalDuration: `${totalDuration.toFixed(1)}s`,
        averageSpeed: `${formatBytes(newProject.videoFiles.reduce((acc, file) => acc + file.size, 0) / totalDuration)}/s`
      });

      if (!hasError) {
        console.log('All files uploaded successfully, cleaning up...');
        setIsCreating(false);
        setNewProject({
          title: '',
          description: '',
          sourceLanguage: '',
          targetLanguage: '',
          status: 'pending',
          videoFiles: []
        });
        
        if (typeof refetchProjects === 'function') {
          console.log('Refetching projects list...');
          await refetchProjects();
        }
        
        setSuccess('Project created successfully');
        setTimeout(() => setSuccess(''), 3000);
      }
      
    } catch (err: any) {
      const failureTime = (Date.now() - startTime) / 1000;
      console.error(`[${getTimeStamp()}] Project creation failed after ${failureTime.toFixed(1)}s:`, {
        error: err.message,
        response: err.response?.data,
        stack: err.stack
      });
      const errorMessage = err.response?.data?.message || err.message || 'Failed to create project';
      setError(errorMessage);
      setTimeout(() => setError(''), 3000);
    }
  };

  const handleCreateUser = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      const response = await axios.post('/api/admin/users', newUser);
      if (response.data.success) {
        setIsCreatingUser(false);
        setNewUser({
          username: '',
          email: '',
          password: '',
          role: 'transcriber',
          isActive: true
        });
        queryClient.invalidateQueries({ queryKey: ['users'] });
        setSuccess('User created successfully');
        setTimeout(() => setSuccess(''), 3000);
      }
    } catch (err) {
      setError('Failed to create user');
      setTimeout(() => setError(''), 3000);
    }
  };

  const handleUpdateStatus = async (projectId: string, newStatus: ProjectStatus) => {
    try {
      await axios.patch(`/api/admin/projects/${projectId}`, { status: newStatus });
      if (typeof refetchProjects === 'function') {
        await refetchProjects();
      }
      setSuccess('Status updated successfully');
      setTimeout(() => setSuccess(''), 3000);
    } catch (err) {
      setError('Failed to update project status');
      setTimeout(() => setError(''), 3000);
    }
  };

  const handleDeleteProject = async (projectId: string) => {
    try {
      await axios.delete(`/api/admin/projects?id=${projectId}`);
      if (typeof refetchProjects === 'function') {
        await refetchProjects();
      }
      setShowDeleteConfirm(false);
      setSelectedProject(null);
      setSuccess('Project and associated files deleted successfully');
      setTimeout(() => setSuccess(''), 3000);
    } catch (err) {
      console.error('Delete project error:', err);
      setError('Failed to delete project');
      setTimeout(() => setError(''), 3000);
    }
  };

  const handleDeleteUser = async (userId: string) => {
    try {
      await axios.delete(`/api/admin/users/${userId}`);
      queryClient.invalidateQueries({ queryKey: ['users'] });
      setShowUserDeleteConfirm(false);
      setSelectedUser(null);
      setSuccess('User deleted successfully');
      setTimeout(() => setSuccess(''), 3000);
    } catch (err) {
      setError('Failed to delete user');
      setTimeout(() => setError(''), 3000);
    }
  };

  const handleToggleUserActive = async (userId: string, isActive: boolean) => {
    try {
      await axios.patch(`/api/admin/users/${userId}`, { isActive });
      queryClient.invalidateQueries({ queryKey: ['users'] });
      setSuccess(`User ${isActive ? 'activated' : 'deactivated'} successfully`);
      setTimeout(() => setSuccess(''), 3000);
    } catch (err) {
      setError(`Failed to ${isActive ? 'activate' : 'deactivate'} user`);
      setTimeout(() => setError(''), 3000);
    }
  };

  const handleAssignUsers = async () => {
    try {
      if (!selectedProject) return;
      
      await axios.post(`/api/admin/projects/${selectedProject._id}/assign`, {
        usernames: selectedUsernames
      });
      
      if (typeof refetchProjects === 'function') {
        await refetchProjects();
      }
      setIsAssigning(false);
      setSelectedUsernames([]);
      setSelectedProject(null);
      setSuccess('Users assigned successfully');
      setTimeout(() => setSuccess(''), 3000);
    } catch (err) {
      setError('Failed to assign users');
      setTimeout(() => setError(''), 3000);
    }
  };

  const handleRemoveUser = async (projectId: string, username: string) => {
    try {
      await axios.delete(`/api/admin/projects/${projectId}/assign`, {
        data: { usernames: [username] }
      });
      
      if (refetchProjects) {
        await refetchProjects();
      }
      setSuccess('User removed successfully');
      setTimeout(() => setSuccess(''), 3000);
    } catch (err) {
      setError('Failed to remove user');
      setTimeout(() => setError(''), 3000);
    }
  };

  const renderProjectDetails = (project: Project) => {
    return (
      <div className="space-y-4">
        <div className="flex justify-between items-center">
          <h3 className="text-lg font-semibold">{project.title}</h3>
          <div className="flex gap-2">
            {/* Existing action buttons */}
          </div>
        </div>

        <div className="bg-white dark:bg-gray-800 rounded-lg p-4 shadow-sm">
          <div className="grid grid-cols-2 gap-4">
            <div>
              <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">Description</label>
              <p className="mt-1 text-sm text-gray-600 dark:text-gray-400">{project.description}</p>
            </div>
            <div>
              <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">Status</label>
              <span className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${STATUS_COLORS[project.status]}`}>
                {project.status}
              </span>
            </div>
          </div>

          <div className="mt-4">
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">Episodes</label>
            <select
              className="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md dark:bg-gray-700 dark:border-gray-600 dark:text-white"
              value={selectedEpisode?.name || ''}
              onChange={(e) => {
                const episode = project.episodes.find(ep => ep.name === e.target.value);
                setSelectedEpisode(episode || null);
              }}
            >
              <option value="">Select an episode</option>
              {project.episodes.map((episode) => (
                <option key={episode.name} value={episode.name}>
                  {episode.name} ({episode.status})
                </option>
              ))}
            </select>
          </div>

          {selectedEpisode && (
            <div className="mt-4 p-4 bg-gray-50 dark:bg-gray-700 rounded-lg">
              <h4 className="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Episode Details</h4>
              <div className="grid grid-cols-2 gap-4 text-sm">
                <div>
                  <label className="block text-xs font-medium text-gray-500 dark:text-gray-400">Name</label>
                  <p className="mt-1 text-gray-900 dark:text-gray-100">{selectedEpisode.name}</p>
                </div>
                <div>
                  <label className="block text-xs font-medium text-gray-500 dark:text-gray-400">Status</label>
                  <p className="mt-1 text-gray-900 dark:text-gray-100">{selectedEpisode.status}</p>
                </div>
                <div>
                  <label className="block text-xs font-medium text-gray-500 dark:text-gray-400">Collection Name</label>
                  <p className="mt-1 text-gray-900 dark:text-gray-100">{selectedEpisode.collectionName}</p>
                </div>
                <div>
                  <label className="block text-xs font-medium text-gray-500 dark:text-gray-400">Uploaded At</label>
                  <p className="mt-1 text-gray-900 dark:text-gray-100">
                    {new Date(selectedEpisode.uploadedAt).toLocaleString()}
                  </p>
                </div>
              </div>
              <div className="mt-4">
                <a
                  href={selectedEpisode.videoPath}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="inline-flex items-center px-3 py-2 border border-transparent text-sm leading-4 font-medium rounded-md shadow-sm text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
                >
                  View Video
                </a>
              </div>
            </div>
          )}
        </div>
      </div>
    );
  };

  return (
    <div className="min-h-screen bg-gray-50 dark:bg-gray-900">
      {/* Top Bar */}
      <div className="bg-white dark:bg-gray-800 shadow">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4">
          <div className="flex items-center justify-between">
            <div className="flex items-center space-x-4">
              <h1 className="text-2xl font-bold text-gray-900 dark:text-white">Admin Dashboard</h1>
              <div className="flex space-x-2">
                <button
                  onClick={() => setActiveTab('projects')}
                  className={`px-4 py-2 rounded-lg transition-colors ${
                    activeTab === 'projects'
                      ? 'bg-blue-500 text-white'
                      : 'text-gray-600 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700'
                  }`}
                >
                  Projects
                </button>
                <button
                  onClick={() => setActiveTab('users')}
                  className={`px-4 py-2 rounded-lg transition-colors ${
                    activeTab === 'users'
                      ? 'bg-blue-500 text-white'
                      : 'text-gray-600 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700'
                  }`}
                >
                  Users
                </button>
              </div>
            </div>
            <div className="flex items-center space-x-4">
              {activeTab === 'projects' && (
                <>
                  <button
                    onClick={() => setViewMode(prev => prev === 'grid' ? 'list' : 'grid')}
                    className="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-700 text-gray-600 dark:text-gray-300"
                  >
                    {viewMode === 'grid' ? 'List View' : 'Grid View'}
                  </button>
                  <button
                    onClick={() => setIsCreating(true)}
                    className="flex items-center px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors"
                  >
                    <Plus className="w-4 h-4 mr-2" />
                    Create Project
                  </button>
                </>
              )}
              {activeTab === 'users' && (
                <button
                  onClick={() => setIsCreatingUser(true)}
                  className="flex items-center px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors"
                >
                  <UserPlus className="w-4 h-4 mr-2" />
                  Create User
                </button>
              )}
            </div>
          </div>
        </div>
      </div>

      {/* Search and Filters */}
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6">
        <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center space-y-4 sm:space-y-0 sm:space-x-4">
          <div className="flex-1 w-full sm:w-auto">
            <div className="relative">
              <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 dark:text-gray-500 w-5 h-5" />
              <input
                type="text"
                placeholder={`Search ${activeTab}...`}
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                className="w-full pl-10 pr-4 py-2 border rounded-lg bg-white dark:bg-gray-800 border-gray-300 dark:border-gray-600 text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-gray-400 focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:border-transparent"
              />
            </div>
          </div>
          {activeTab === 'projects' && (
            <div className="flex items-center space-x-4 w-full sm:w-auto">
              <select
                value={filterStatus}
                onChange={(e) => setFilterStatus(e.target.value as ProjectStatus | 'all')}
                className="px-3 py-2 border rounded-lg bg-white dark:bg-gray-800 border-gray-300 dark:border-gray-600 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:border-transparent"
              >
                <option value="all">All Status</option>
                <option value="pending">Pending</option>
                <option value="in-progress">In Progress</option>
                <option value="completed">Completed</option>
                <option value="on-hold">On Hold</option>
              </select>
              <select
                value={sortBy}
                onChange={(e) => setSortBy(e.target.value as 'title' | 'date' | 'status')}
                className="px-3 py-2 border rounded-lg bg-white dark:bg-gray-800 border-gray-300 dark:border-gray-600 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:border-transparent"
              >
                <option value="date">Sort by Date</option>
                <option value="title">Sort by Title</option>
                <option value="status">Sort by Status</option>
              </select>
            </div>
          )}
        </div>
      </div>

      {/* Notifications */}
      {error && (
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 mb-6">
          <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative">
            {error}
          </div>
        </div>
      )}
      {success && (
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 mb-6">
          <div className="bg-green-100 border border-green-400 text-green-700 px-4 py-3 rounded relative">
            {success}
          </div>
        </div>
      )}

      {/* Content */}
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        {activeTab === 'projects' ? (
          // Projects Grid/List
          <div className={viewMode === 'grid' ? 
            "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6" : 
            "space-y-4"
          }>
            {filteredProjects.map((project) => (
              <div
                key={project._id}
                className={`bg-white dark:bg-gray-800 rounded-lg shadow hover:shadow-lg transition-shadow duration-200 ${
                  viewMode === 'list' ? 'p-4' : 'p-6'
                }`}
              >
                <div className={`${viewMode === 'list' ? 'flex items-center justify-between' : 'space-y-4'}`}>
                  <div className={viewMode === 'list' ? 'flex-1' : ''}>
                    <div className="flex justify-between items-start">
                      <h2 className="text-xl font-semibold text-gray-900 dark:text-white">{project.title}</h2>
                      <div className="flex items-center space-x-2">
                        <select
                          value={project.status}
                          onChange={(e) => handleUpdateStatus(project._id, e.target.value as ProjectStatus)}
                          className={`text-sm px-2 py-1 rounded ${STATUS_COLORS[project.status as keyof typeof STATUS_COLORS]}`}
                        >
                          <option value="pending">Pending</option>
                          <option value="in-progress">In Progress</option>
                          <option value="completed">Completed</option>
                          <option value="on-hold">On Hold</option>
                        </select>
                        <div className="relative">
                          <button
                            onClick={() => setSelectedProject(project)}
                            className="p-1 hover:bg-gray-100 dark:hover:bg-gray-700 rounded text-gray-600 dark:text-gray-300"
                          >
                            <MoreVertical className="w-5 h-5" />
                          </button>
                          {selectedProject?._id === project._id && (
                            <div className="absolute right-0 mt-2 w-48 bg-white dark:bg-gray-800 rounded-lg shadow-lg z-10 border dark:border-gray-700">
                              <div className="py-1">
                                <button
                                  onClick={() => router.push(`/admin/project/${project._id}`)}
                                  className="flex items-center w-full px-4 py-2 text-sm text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-700"
                                >
                                  <Settings className="w-4 h-4 mr-2" />
                                  Manage
                                </button>
                                <button
                                  onClick={() => router.push(`/admin/project/${project._id}/progress`)}
                                  className="flex items-center w-full px-4 py-2 text-sm text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-700"
                                >
                                  <ChartBar className="w-4 h-4 mr-2" />
                                  Progress
                                </button>
                                <button
                                  onClick={() => {
                                    setIsEditing(true);
                                    setSelectedProject(project);
                                  }}
                                  className="flex items-center w-full px-4 py-2 text-sm text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-700"
                                >
                                  <Edit3 className="w-4 h-4 mr-2" />
                                  Edit
                                </button>
                                <button
                                  onClick={() => {
                                    setIsAssigning(true);
                                    setSelectedProject(project);
                                  }}
                                  className="flex items-center w-full px-4 py-2 text-sm text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-700"
                                >
                                  <Users className="w-4 h-4 mr-2" />
                                  Assign Users
                                </button>
                                <button
                                  onClick={() => {
                                    setShowDeleteConfirm(true);
                                    setSelectedProject(project);
                                  }}
                                  className="flex items-center w-full px-4 py-2 text-sm text-red-600 dark:text-red-400 hover:bg-gray-100 dark:hover:bg-gray-700"
                                >
                                  <Trash2 className="w-4 h-4 mr-2" />
                                  Delete
                                </button>
                              </div>
                            </div>
                          )}
                        </div>
                      </div>
                    </div>
                    {viewMode === 'grid' && (
                      <>
                        <p className="text-gray-600 dark:text-gray-300 mt-2">{project.description}</p>
                        <div className="flex flex-col gap-2 mt-4">
                          <div className="flex justify-between text-sm">
                            <span className="text-gray-500 dark:text-gray-400">
                              Language: {project.sourceLanguage} â†’ {project.targetLanguage}
                            </span>
                          </div>
                          <div className="flex justify-between text-sm">
                            <div className="relative">
                              <select 
                                className="block w-full px-3 py-1 text-sm text-gray-500 dark:text-gray-400 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded-md focus:outline-none focus:ring-1 focus:ring-blue-500"
                              >
                                {project.episodes?.map((episode, index) => (
                                  <option key={index} value={episode.name}>
                                    Episode: {episode.name}
                                  </option>
                                )) || (
                                  <option value="">No episodes available</option>
                                )}
                              </select>
                            </div>
                          </div>
                          <div className="flex justify-between text-sm">
                            <span className="text-gray-500 dark:text-gray-400">
                              Folder Path: {project.parentFolder}
                            </span>
                          </div>
                          <div className="flex justify-between text-sm">
                            <span className="text-gray-500 dark:text-gray-400">
                              Last Updated: {new Date(project.updatedAt).toLocaleDateString()}
                            </span>
                          </div>
                        </div>
                      </>
                    )}
                    {project.assignedTo.length > 0 && (
                      <div className={viewMode === 'grid' ? 'mt-4' : 'mt-2'}>
                        <div className="flex flex-wrap gap-2">
                          {project.assignedTo.map((user, index) => (
                            <span
                              key={index}
                              className={`inline-flex items-center px-2 py-1 rounded-full text-xs font-medium ${
                                user.role === 'transcriber' ? 'bg-purple-100 text-purple-800 dark:bg-purple-900/50 dark:text-purple-300' :
                                user.role === 'translator' ? 'bg-blue-100 text-blue-800 dark:bg-blue-900/50 dark:text-blue-300' :
                                user.role === 'voiceOver' ? 'bg-green-100 text-green-800 dark:bg-green-900/50 dark:text-green-300' :
                                user.role === 'director' ? 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900/50 dark:text-yellow-300' :
                                'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300'
                              }`}
                            >
                              {user.username} ({user.role})
                            </span>
                          ))}
                        </div>
                      </div>
                    )}
                  </div>
                </div>
              </div>
            ))}
          </div>
        ) : (
          // Users List
          <div className="bg-white dark:bg-gray-800 shadow rounded-lg overflow-hidden">
            <table className="min-w-full divide-y divide-gray-200 dark:divide-gray-700">
              <thead className="bg-gray-50 dark:bg-gray-900">
                <tr>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                    User
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                    Role
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                    Status
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                    Projects
                  </th>
                  <th className="px-6 py-3 text-right text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                    Actions
                  </th>
                </tr>
              </thead>
              <tbody className="bg-white dark:bg-gray-800 divide-y divide-gray-200 dark:divide-gray-700">
                {filteredUsers.map((user) => (
                  <tr key={user._id}>
                    <td className="px-6 py-4 whitespace-nowrap">
                      <div className="flex items-center">
                        <div>
                          <div className="text-sm font-medium text-gray-900 dark:text-white">
                            {user.username}
                          </div>
                          <div className="text-sm text-gray-500 dark:text-gray-400">
                            {user.email}
                          </div>
                        </div>
                      </div>
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap">
                      <span className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${
                        user.role === 'transcriber' ? 'bg-purple-100 text-purple-800 dark:bg-purple-900/50 dark:text-purple-300' :
                        user.role === 'translator' ? 'bg-blue-100 text-blue-800 dark:bg-blue-900/50 dark:text-blue-300' :
                        user.role === 'voiceOver' ? 'bg-green-100 text-green-800 dark:bg-green-900/50 dark:text-green-300' :
                        user.role === 'director' ? 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900/50 dark:text-yellow-300' :
                        'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300'
                      }`}>
                        {user.role}
                      </span>
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap">
                      <button
                        onClick={() => handleToggleUserActive(user._id, !user.isActive)}
                        className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${
                          user.isActive
                            ? 'bg-green-100 text-green-800 dark:bg-green-900/50 dark:text-green-300'
                            : 'bg-red-100 text-red-800 dark:bg-red-900/50 dark:text-red-300'
                        }`}
                      >
                        {user.isActive ? 'Active' : 'Inactive'}
                      </button>
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400">
                      {user.assignedProjects?.length || 0} projects
                      <div className="text-xs text-gray-400 dark:text-gray-500">
                        Last login: {user.lastLogin ? new Date(user.lastLogin).toLocaleDateString() : 'Never'}
                      </div>
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                      <button
                        onClick={() => {
                          setSelectedUser(user);
                          setShowUserDeleteConfirm(true);
                        }}
                        className="text-red-600 dark:text-red-400 hover:text-red-900 dark:hover:text-red-300"
                      >
                        Delete
                      </button>
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        )}
      </div>

      {/* Create Project Modal */}
      {isCreating && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50 overflow-y-auto">
          <div className="bg-white dark:bg-gray-800 rounded-lg p-4 sm:p-6 w-full max-w-lg mx-auto my-8">
            <h2 className="text-xl font-semibold mb-4 text-gray-900 dark:text-white">Create New Project</h2>
            <form onSubmit={handleCreateProject} className="space-y-4">
              <div className="space-y-4">
                <div>
                  <label className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300">Title</label>
                  <input
                    type="text"
                    value={newProject.title}
                    onChange={(e) => setNewProject(prev => ({ ...prev, title: e.target.value }))}
                    className="w-full p-2 border rounded bg-white dark:bg-gray-800 border-gray-300 dark:border-gray-600 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:border-transparent"
                    required
                  />
                </div>
                <div>
                  <label className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300">Description</label>
                  <textarea
                    value={newProject.description}
                    onChange={(e) => setNewProject(prev => ({ ...prev, description: e.target.value }))}
                    className="w-full p-2 border rounded bg-white dark:bg-gray-800 border-gray-300 dark:border-gray-600 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:border-transparent"
                    rows={3}
                    required
                  />
                </div>
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                  <div>
                    <label className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300">Source Language</label>
                    <input
                      type="text"
                      value={newProject.sourceLanguage}
                      onChange={(e) => setNewProject(prev => ({ ...prev, sourceLanguage: e.target.value }))}
                      className="w-full p-2 border rounded bg-white dark:bg-gray-800 border-gray-300 dark:border-gray-600 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:border-transparent"
                      required
                    />
                  </div>
                  <div>
                    <label className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300">Target Language</label>
                    <input
                      type="text"
                      value={newProject.targetLanguage}
                      onChange={(e) => setNewProject(prev => ({ ...prev, targetLanguage: e.target.value }))}
                      className="w-full p-2 border rounded bg-white dark:bg-gray-800 border-gray-300 dark:border-gray-600 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:border-transparent"
                      required
                    />
                  </div>
                </div>
                <div>
                  <label className="block text-sm font-medium mb-2 text-gray-700 dark:text-gray-300">Video Upload</label>
                  <div className="space-y-4">
                    <div className="flex items-center justify-center w-full">
                      <label className="w-full flex flex-col items-center px-4 py-4 sm:py-6 bg-white dark:bg-gray-800 text-gray-700 dark:text-gray-300 rounded-lg border-2 border-dashed border-gray-300 dark:border-gray-600 cursor-pointer hover:border-blue-500 dark:hover:border-blue-400">
                        <div className="flex flex-col items-center justify-center text-center">
                          <svg className="w-8 h-8 text-gray-400 mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
                          </svg>
                          <p className="text-sm">
                            Click or drag to upload videos
                          </p>
                          <p className="text-xs text-gray-500 mt-1">
                            Multiple files allowed â€¢ No size limit
                          </p>
                        </div>
                        <input
                          type="file"
                          className="hidden"
                          accept="video/*"
                          multiple
                          onChange={(e) => {
                            const files = Array.from(e.target.files || []);
                            setNewProject(prev => ({
                              ...prev,
                              videoFiles: [...prev.videoFiles, ...files]
                            }));
                            
                            // Initialize progress and status for new files
                            const newProgress = { ...uploadProgress };
                            const newStatus = { ...uploadStatus };
                            files.forEach(file => {
                              newProgress[file.name] = { 
                                loaded: 0, 
                                total: file.size,
                                phase: 'pending',
                                message: 'Waiting to start'
                              };
                              newStatus[file.name] = 'pending';
                            });
                            setUploadProgress(newProgress);
                            setUploadStatus(newStatus);
                          }}
                        />
                      </label>
                    </div>
                    {newProject.videoFiles.length > 0 && (
                      <div className="bg-gray-50 dark:bg-gray-700 rounded-lg p-3 sm:p-4">
                        <h4 className="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Selected Files:</h4>
                        <div className="space-y-3 max-h-48 overflow-y-auto">
                          {newProject.videoFiles.map((file, index) => (
                            <div key={index} className="space-y-1">
                              <div className="flex items-center justify-between text-sm">
                                <span className="text-gray-600 dark:text-gray-300 truncate pr-2">
                                  {file.name}
                                  {uploadProgress[file.name] && (
                                    <span 
                                      data-file-name={file.name}
                                      className={`ml-2 text-xs ${
                                        uploadProgress[file.name].phase === 'success' ? 'text-green-500' :
                                        uploadProgress[file.name].phase === 'error' ? 'text-red-500' :
                                        uploadProgress[file.name].phase === 'creating-collection' ? 'text-yellow-500' :
                                        uploadProgress[file.name].phase === 'processing' ? 'text-purple-500' :
                                        uploadProgress[file.name].phase === 'uploading' ? 'text-blue-500' :
                                        'text-gray-500'
                                      }`}
                                    >
                                      {uploadProgress[file.name].phase === 'uploading' && (
                                        ` (${formatBytes(uploadProgress[file.name].loaded)} / ${formatBytes(uploadProgress[file.name].total)})`
                                      )}
                                      {(uploadProgress[file.name].phase === 'pending' || 
                                        uploadProgress[file.name].phase === 'creating-collection' || 
                                        uploadProgress[file.name].phase === 'processing' || 
                                        uploadProgress[file.name].phase === 'success' || 
                                        uploadProgress[file.name].phase === 'error') && (
                                        ` â€¢ ${uploadProgress[file.name].message}`
                                      )}
                                    </span>
                                  )}
                                </span>
                                <button
                                  type="button"
                                  onClick={() => {
                                    setNewProject(prev => ({
                                      ...prev,
                                      videoFiles: prev.videoFiles.filter((_, i) => i !== index)
                                    }));
                                    
                                    const newProgress = { ...uploadProgress };
                                    const newStatus = { ...uploadStatus };
                                    delete newProgress[file.name];
                                    delete newStatus[file.name];
                                    setUploadProgress(newProgress);
                                    setUploadStatus(newStatus);
                                  }}
                                  className="text-red-500 hover:text-red-700 flex-shrink-0"
                                  disabled={uploadProgress[file.name]?.phase === 'uploading' || 
                                           uploadProgress[file.name]?.phase === 'creating-collection' ||
                                           uploadProgress[file.name]?.phase === 'processing'}
                                >
                                  Remove
                                </button>
                              </div>
                              {uploadProgress[file.name] && uploadProgress[file.name].phase !== 'error' && (
                                <div className="w-full bg-gray-200 rounded-full h-2 dark:bg-gray-700">
                                  <div 
                                    className={`h-2 rounded-full transition-all duration-300 ${
                                      uploadProgress[file.name].phase === 'success' ? 'bg-green-600' :
                                      uploadProgress[file.name].phase === 'creating-collection' ? 'bg-yellow-600' :
                                      uploadProgress[file.name].phase === 'processing' ? 'bg-purple-600' :
                                      uploadProgress[file.name].phase === 'uploading' ? 'bg-blue-600' :
                                      'bg-gray-600'
                                    }`}
                                    style={{ 
                                      width: uploadProgress[file.name].phase === 'uploading' ?
                                        `${(uploadProgress[file.name].loaded / uploadProgress[file.name].total) * 100}%` :
                                        uploadProgress[file.name].phase === 'creating-collection' ? '60%' :
                                        uploadProgress[file.name].phase === 'processing' ? '80%' :
                                        uploadProgress[file.name].phase === 'success' ? '100%' : '0%'
                                    }}
                                  ></div>
                                </div>
                              )}
                            </div>
                          ))}
                        </div>
                      </div>
                    )}
                  </div>
                </div>
              </div>
              <div className="flex flex-col-reverse sm:flex-row justify-end gap-2 mt-6">
                <button
                  type="button"
                  onClick={() => setIsCreating(false)}
                  className="w-full sm:w-auto px-4 py-2 text-center text-gray-600 dark:text-gray-400 hover:text-gray-800 dark:hover:text-gray-200 transition-colors"
                >
                  Cancel
                </button>
                <button
                  type="submit"
                  className="w-full sm:w-auto px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:ring-offset-2 dark:focus:ring-offset-gray-800"
                >
                  Create Project
                </button>
              </div>
            </form>
          </div>
        </div>
      )}

      {/* Create User Modal */}
      {isCreatingUser && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
          <div className="bg-white dark:bg-gray-800 rounded-lg p-6 max-w-md w-full">
            <h2 className="text-xl font-semibold mb-4 text-gray-900 dark:text-white">Create New User</h2>
            <form onSubmit={handleCreateUser} className="space-y-4">
              <div>
                <label className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300">Username</label>
                <input
                  type="text"
                  value={newUser.username}
                  onChange={(e) => setNewUser(prev => ({ ...prev, username: e.target.value }))}
                  className="w-full p-2 border rounded bg-white dark:bg-gray-800 border-gray-300 dark:border-gray-600 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:border-transparent"
                  required
                />
              </div>
              <div>
                <label className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300">Email</label>
                <input
                  type="email"
                  value={newUser.email}
                  onChange={(e) => setNewUser(prev => ({ ...prev, email: e.target.value }))}
                  className="w-full p-2 border rounded bg-white dark:bg-gray-800 border-gray-300 dark:border-gray-600 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:border-transparent"
                  required
                />
              </div>
              <div>
                <label className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300">Password</label>
                <input
                  type="password"
                  value={newUser.password}
                  onChange={(e) => setNewUser(prev => ({ ...prev, password: e.target.value }))}
                  className="w-full p-2 border rounded bg-white dark:bg-gray-800 border-gray-300 dark:border-gray-600 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:border-transparent"
                  required
                />
              </div>
              <div>
                <label className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300">Role</label>
                <select
                  value={newUser.role === 'admin' ? 'director' : newUser.role}
                  onChange={(e) => setNewUser(prev => ({ ...prev, role: e.target.value as UserRole }))}
                  className="w-full p-2 border rounded bg-white dark:bg-gray-800 border-gray-300 dark:border-gray-600 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:border-transparent"
                  required
                >
                  <option value="transcriber">Transcriber</option>
                  <option value="translator">Translator</option>
                  <option value="voiceOver">Voice Over</option>
                  <option value="director">Director</option>
                  <option value="admin">Admin</option>
                </select>
              </div>
              <div className="flex justify-end gap-2 mt-4">
                <button
                  type="button"
                  onClick={() => setIsCreatingUser(false)}
                  className="px-4 py-2 text-gray-600 dark:text-gray-400 hover:text-gray-800 dark:hover:text-gray-200 transition-colors"
                >
                  Cancel
                </button>
                <button
                  type="submit"
                  className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:ring-offset-2 dark:focus:ring-offset-gray-800"
                >
                  Create User
                </button>
              </div>
            </form>
          </div>
        </div>
      )}

      {/* Delete User Confirmation Modal */}
      {showUserDeleteConfirm && selectedUser && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
          <div className="bg-white dark:bg-gray-800 rounded-lg p-6 max-w-md w-full">
            <h2 className="text-xl font-semibold mb-4 text-gray-900 dark:text-white">Delete User</h2>
            <p className="text-gray-600 dark:text-gray-300 mb-4">
              Are you sure you want to delete "{selectedUser.username}"? This action cannot be undone.
            </p>
            <div className="flex justify-end gap-2">
              <button
                onClick={() => {
                  setShowUserDeleteConfirm(false);
                  setSelectedUser(null);
                }}
                className="px-4 py-2 text-gray-600 dark:text-gray-400 hover:text-gray-800 dark:hover:text-gray-200 transition-colors"
              >
                Cancel
              </button>
              <button
                onClick={() => handleDeleteUser(selectedUser._id)}
                className="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600 transition-colors focus:ring-2 focus:ring-red-500 dark:focus:ring-red-400 focus:ring-offset-2 dark:focus:ring-offset-gray-800"
              >
                Delete
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Assign Users Modal */}
      {isAssigning && selectedProject && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
          <div className="bg-white dark:bg-gray-800 rounded-lg p-6 max-w-2xl w-full">
            <h2 className="text-xl font-semibold mb-4 text-gray-900 dark:text-white">
              Assign Users to {selectedProject.title}
            </h2>
            <div className="mb-6">
              <h3 className="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Currently Assigned</h3>
              <div className="flex flex-wrap gap-2">
                {selectedProject.assignedTo.map((user) => (
                  <div
                    key={user.username}
                    className={`flex items-center gap-2 px-3 py-1 rounded-full ${
                      user.role === 'transcriber' ? 'bg-purple-100 text-purple-800 dark:bg-purple-900/50 dark:text-purple-300' :
                      user.role === 'translator' ? 'bg-blue-100 text-blue-800 dark:bg-blue-900/50 dark:text-blue-300' :
                      user.role === 'voiceOver' ? 'bg-green-100 text-green-800 dark:bg-green-900/50 dark:text-green-300' :
                      user.role === 'director' ? 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900/50 dark:text-yellow-300' :
                      'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300'
                    }`}
                  >
                    <span className="text-sm">
                      {user.username} ({user.role})
                    </span>
                    <button
                      onClick={() => handleRemoveUser(selectedProject._id, user.username)}
                      className="text-red-500 hover:text-red-700 dark:text-red-400 dark:hover:text-red-300"
                    >
                      Ã—
                    </button>
                  </div>
                ))}
                {selectedProject.assignedTo.length === 0 && (
                  <span className="text-sm text-gray-500 dark:text-gray-400">No users assigned</span>
                )}
              </div>
            </div>
            <div className="mb-6">
              <h3 className="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Available Users</h3>
              <div className="max-h-60 overflow-y-auto border dark:border-gray-700 rounded-lg">
                {users
                  .filter(user => user.isActive && !selectedProject.assignedTo.some(assigned => assigned.username === user.username))
                  .map((user) => (
                    <label
                      key={user._id}
                      className="flex items-center px-4 py-2 hover:bg-gray-50 dark:hover:bg-gray-700 cursor-pointer"
                    >
                      <input
                        type="checkbox"
                        checked={selectedUsernames.includes(user.username)}
                        onChange={(e) => {
                          if (e.target.checked) {
                            setSelectedUsernames(prev => [...prev, user.username]);
                          } else {
                            setSelectedUsernames(prev => prev.filter(name => name !== user.username));
                          }
                        }}
                        className="rounded border-gray-300 dark:border-gray-600 text-blue-500 focus:ring-blue-500 dark:focus:ring-blue-400"
                      />
                      <div className="ml-3">
                        <div className="text-sm font-medium text-gray-900 dark:text-white">{user.username}</div>
                        <div className="text-sm text-gray-500 dark:text-gray-400">
                          {user.email} â€¢ {user.role} â€¢ Last login: {user.lastLogin ? new Date(user.lastLogin).toLocaleDateString() : 'Never'}
                        </div>
                      </div>
                    </label>
                  ))}
              </div>
            </div>
            <div className="flex justify-end gap-2">
              <button
                onClick={() => {
                  setIsAssigning(false);
                  setSelectedProject(null);
                  setSelectedUsernames([]);
                }}
                className="px-4 py-2 text-gray-600 dark:text-gray-400 hover:text-gray-800 dark:hover:text-gray-200 transition-colors"
              >
                Cancel
              </button>
              <button
                onClick={handleAssignUsers}
                disabled={selectedUsernames.length === 0}
                className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:ring-offset-2 dark:focus:ring-offset-gray-800 disabled:opacity-50 disabled:cursor-not-allowed"
              >
                Assign Selected Users
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Edit Project Modal */}
      {isEditing && selectedProject && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
          <div className="bg-white dark:bg-gray-800 rounded-lg p-6 max-w-md w-full">
            <h2 className="text-xl font-semibold mb-4 text-gray-900 dark:text-white">Edit Project</h2>
            <form onSubmit={async (e) => {
              e.preventDefault();
              try {
                await axios.patch(`/api/admin/projects/${selectedProject._id}`, {
                  title: selectedProject.title,
                  description: selectedProject.description,
                  sourceLanguage: selectedProject.sourceLanguage,
                  targetLanguage: selectedProject.targetLanguage,
                  dialogue_collection: selectedProject.dialogue_collection,
                  status: selectedProject.status
                });
                await refetchProjects();
                setIsEditing(false);
                setSelectedProject(null);
                setSuccess('Project updated successfully');
                setTimeout(() => setSuccess(''), 3000);
              } catch (err) {
                setError('Failed to update project');
                setTimeout(() => setError(''), 3000);
              }
            }} className="space-y-4">
              <div>
                <label className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300">Title</label>
                <input
                  type="text"
                  value={selectedProject.title}
                  onChange={(e) => setSelectedProject(prev => prev ? { ...prev, title: e.target.value } : null)}
                  className="w-full p-2 border rounded bg-white dark:bg-gray-800 border-gray-300 dark:border-gray-600 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:border-transparent"
                  required
                />
              </div>
              <div>
                <label className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300">Description</label>
                <textarea
                  value={selectedProject.description}
                  onChange={(e) => setSelectedProject(prev => prev ? { ...prev, description: e.target.value } : null)}
                  className="w-full p-2 border rounded bg-white dark:bg-gray-800 border-gray-300 dark:border-gray-600 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:border-transparent"
                  rows={3}
                  required
                />
              </div>
              <div className="grid grid-cols-2 gap-4">
                <div>
                  <label className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300">Source Language</label>
                  <input
                    type="text"
                    value={selectedProject.sourceLanguage}
                    onChange={(e) => setSelectedProject(prev => prev ? { ...prev, sourceLanguage: e.target.value } : null)}
                    className="w-full p-2 border rounded bg-white dark:bg-gray-800 border-gray-300 dark:border-gray-600 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:border-transparent"
                    required
                  />
                </div>
                <div>
                  <label className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300">Target Language</label>
                  <input
                    type="text"
                    value={selectedProject.targetLanguage}
                    onChange={(e) => setSelectedProject(prev => prev ? { ...prev, targetLanguage: e.target.value } : null)}
                    className="w-full p-2 border rounded bg-white dark:bg-gray-800 border-gray-300 dark:border-gray-600 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:border-transparent"
                    required
                  />
                </div>
              </div>
              <div>
                <label className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300">Collection Name</label>
                <input
                  type="text"
                  value={selectedProject.dialogue_collection}
                  onChange={(e) => setSelectedProject(prev => prev ? { ...prev, dialogue_collection: e.target.value } : null)}
                  className="w-full p-2 border rounded bg-white dark:bg-gray-800 border-gray-300 dark:border-gray-600 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:border-transparent"
                  required
                />
              </div>
              <div className="flex justify-end gap-2 mt-4">
                <button
                  type="button"
                  onClick={() => {
                    setIsEditing(false);
                    setSelectedProject(null);
                  }}
                  className="px-4 py-2 text-gray-600 dark:text-gray-400 hover:text-gray-800 dark:hover:text-gray-200 transition-colors"
                >
                  Cancel
                </button>
                <button
                  type="submit"
                  className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:ring-offset-2 dark:focus:ring-offset-gray-800"
                >
                  Save Changes
                </button>
              </div>
            </form>
          </div>
        </div>
      )}

      {/* Delete Project Confirmation Modal */}
      {showDeleteConfirm && selectedProject && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
          <div className="bg-white dark:bg-gray-800 rounded-lg p-6 max-w-md w-full">
            <h2 className="text-xl font-semibold mb-4 text-gray-900 dark:text-white">Delete Project</h2>
            <p className="text-gray-600 dark:text-gray-300 mb-4">
              Are you sure you want to delete "{selectedProject.title}"? This action cannot be undone.
            </p>
            <div className="flex justify-end gap-2">
              <button
                onClick={() => {
                  setShowDeleteConfirm(false);
                  setSelectedProject(null);
                }}
                className="px-4 py-2 text-gray-600 dark:text-gray-400 hover:text-gray-800 dark:hover:text-gray-200 transition-colors"
              >
                Cancel
              </button>
              <button
                onClick={() => handleDeleteProject(selectedProject._id)}
                className="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600 transition-colors focus:ring-2 focus:ring-red-500 dark:focus:ring-red-400 focus:ring-offset-2 dark:focus:ring-offset-gray-800"
              >
                Delete
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}




```

## File: components\AudioVisualizer.tsx
```tsx
import React, { useEffect, useRef } from 'react';

interface AudioVisualizerProps {
  audioStream: MediaStream;
  maxDuration: number;
}

// Add type for webkitAudioContext
declare global {
  interface Window {
    webkitAudioContext: typeof AudioContext;
  }
}

const AudioVisualizer: React.FC<AudioVisualizerProps> = ({ audioStream, maxDuration }) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const animationFrameId = useRef<number | null>(null);
  const analyserRef = useRef<AnalyserNode | null>(null);

  useEffect(() => {
    if (!audioStream || !canvasRef.current) return;

    const audioContext = new (window.webkitAudioContext || window.AudioContext)();
    const analyser = audioContext.createAnalyser();
    const source = audioContext.createMediaStreamSource(audioStream);
    
    analyser.fftSize = 256;
    source.connect(analyser);
    analyserRef.current = analyser;

    const bufferLength = analyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    const draw = () => {
      animationFrameId.current = requestAnimationFrame(draw);

      analyser.getByteFrequencyData(dataArray);
      
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.beginPath();
      const sliceWidth = (canvas.width * 1.0) / bufferLength;
      let x = 0;

      for (let i = 0; i < bufferLength; i++) {
        const barHeight = (dataArray[i] / 255) * canvas.height;
        const y = canvas.height - barHeight;

        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }

        x += sliceWidth;
      }

      ctx.lineTo(canvas.width, canvas.height);
      ctx.lineTo(0, canvas.height);
      ctx.closePath();
      ctx.fillStyle = 'rgba(34, 198, 94, 0.5)';
      ctx.fill();

      const currentTime = audioContext.currentTime;
      const progress = (currentTime / maxDuration) * canvas.width;
      ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
      ctx.fillRect(0, 0, progress, canvas.height);
    };

    draw();

    return () => {
      if (animationFrameId.current) {
        cancelAnimationFrame(animationFrameId.current);
      }
      audioContext.close();
    };
  }, [audioStream, maxDuration]);

  return (
    <canvas
      ref={canvasRef}
      className="w-full h-16 rounded-md bg-gray-900 shadow-xl"
      width={300}
      height={64}
    />
  );
};

export default AudioVisualizer; 
```

## File: components\Button.tsx
```tsx
'use client'

import React, { ButtonHTMLAttributes } from 'react'

interface ButtonProps extends ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'primary' | 'secondary' | 'danger' | 'success'
  size?: 'sm' | 'md' | 'lg'
}

const variantClasses = {
  primary: 'bg-blue-600 hover:bg-blue-700 text-white',
  secondary: 'bg-gray-600 hover:bg-gray-700 text-white',
  danger: 'bg-red-600 hover:bg-red-700 text-white',
  success: 'bg-green-600 hover:bg-green-700 text-white'
}

const sizeClasses = {
  sm: 'px-2 py-1 text-sm',
  md: 'px-4 py-2',
  lg: 'px-6 py-3 text-lg'
}

export default function Button({
  variant = 'primary',
  size = 'md',
  className = '',
  children,
  ...props
}: ButtonProps) {
  const baseClasses = 'inline-flex items-center justify-center border border-transparent rounded-md font-medium focus:outline-none focus:ring-2 focus:ring-offset-2 transition-colors duration-200'
  const variantClass = variantClasses[variant]
  const sizeClass = sizeClasses[size]
  const focusRingColor = `focus:ring-${variant === 'primary' ? 'blue' : variant === 'secondary' ? 'gray' : variant === 'danger' ? 'red' : 'green'}-500`

  return (
    <button
      className={`${baseClasses} ${variantClass} ${sizeClass} ${focusRingColor} ${className}`}
      {...props}
    >
      {children}
    </button>
  )
} 
```

## File: components\Card.tsx
```tsx
'use client'

import React, { ReactNode } from 'react'

interface CardProps {
  children: ReactNode
  title?: string
  className?: string
  headerAction?: ReactNode
  onClick?: () => void
}

export default function Card({ children, title, className = '', headerAction, onClick }: CardProps) {
  return (
    <div 
      className={`bg-white rounded-lg shadow-md overflow-hidden ${className}`}
      onClick={onClick}
      role={onClick ? "button" : undefined}
      tabIndex={onClick ? 0 : undefined}
    >
      {(title || headerAction) && (
        <div className="px-6 py-4 border-b border-gray-200 flex justify-between items-center">
          {title && <h3 className="text-lg font-medium text-gray-900">{title}</h3>}
          {headerAction && <div>{headerAction}</div>}
        </div>
      )}
      <div className="px-6 py-4">
        {children}
      </div>
    </div>
  )
} 
```

## File: components\DashboardLayout.tsx
```tsx
'use client'

import React, { ReactNode } from 'react'
import { signOut } from 'next-auth/react'

interface DashboardLayoutProps {
  children: ReactNode
  title: string
}

export default function DashboardLayout({ children, title }: DashboardLayoutProps) {
  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-50 to-gray-100">
      {/* Navigation Bar */}
      <nav className="bg-white shadow-lg">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="flex justify-between h-16">
            <div className="flex items-center">
              <span className="text-2xl font-bold text-gray-800">{title}</span>
            </div>
            <div className="flex items-center">
              <button
                onClick={() => signOut({ callbackUrl: '/login' })}
                className="inline-flex items-center px-4 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-red-600 hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 transition-colors duration-200"
              >
                Logout
              </button>
            </div>
          </div>
        </div>
      </nav>

      {/* Main Content */}
      <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <div className="bg-white rounded-lg shadow-md p-6">
          {children}
        </div>
      </main>

      {/* Footer */}
      <footer className="bg-white shadow-lg mt-auto">
        <div className="max-w-7xl mx-auto py-4 px-4 sm:px-6 lg:px-8">
          <p className="text-center text-gray-500 text-sm">
            Â© {new Date().getFullYear()} QA App. All rights reserved.
          </p>
        </div>
      </footer>
    </div>
  )
} 
```

## File: components\DirectorDialogueView.tsx
```tsx
import { useState, useRef, useEffect } from 'react'
import { useQueryClient } from '@tanstack/react-query'
import { motion, useMotionValue, useTransform, useAnimation, type PanInfo } from 'framer-motion'
import axios from 'axios'

interface Dialogue {
  _id: string
  index: number
  timeStart: string
  timeEnd: string
  character: string
  videoUrl: string
  dialogue: {
    original: string
    translated: string
    adapted: string
  }
  status: string
  voiceOverUrl?: string
  voiceOverNotes?: string
  directorNotes?: string
  revisionRequested?: boolean
}

interface DialogueViewProps {
  dialogues: Dialogue[]
  projectId: string
}

type QueryData = {
  data: Dialogue[];
  status: string;
  timestamp: number;
};

export default function DirectorDialogueView({ dialogues: initialDialogues, projectId }: DialogueViewProps) {
  const [dialoguesList, setDialoguesList] = useState(initialDialogues);
  const [currentDialogueIndex, setCurrentDialogueIndex] = useState(0);
  const [isSaving, setIsSaving] = useState(false);
  const [showSaveSuccess, setShowSaveSuccess] = useState(false);
  const [error, setError] = useState<string>('');
  const [directorNotes, setDirectorNotes] = useState('');
  const [revisionRequested, setRevisionRequested] = useState(false);
  const [showConfirmation, setShowConfirmation] = useState(false);
  const videoRef = useRef<HTMLVideoElement>(null);
  const queryClient = useQueryClient();
  const [isPlaying, setIsPlaying] = useState(false);
  const [playbackRate, setPlaybackRate] = useState(1);

  const currentDialogue = dialoguesList[currentDialogueIndex];

  // Check for unsaved changes
  const hasChanges = () => {
    if (!currentDialogue) return false;
    return (
      directorNotes !== (currentDialogue.directorNotes || '') ||
      revisionRequested !== (currentDialogue.revisionRequested || false)
    );
  };

  // Navigation handlers
  const handleNext = () => {
    if (hasChanges()) {
      setShowConfirmation(true);
    } else if (currentDialogueIndex < dialoguesList.length - 1) {
      setCurrentDialogueIndex(prev => prev + 1);
    }
  };

  const handlePrevious = () => {
    if (currentDialogueIndex > 0) {
      if (hasChanges()) {
        setShowConfirmation(true);
      } else {
        setCurrentDialogueIndex(prev => prev - 1);
      }
    }
  };

  // Reset changes and continue navigation
  const handleDiscardChanges = () => {
    setShowConfirmation(false);
    if (currentDialogue) {
      setDirectorNotes(currentDialogue.directorNotes || '');
      setRevisionRequested(currentDialogue.revisionRequested || false);
    }
  };

  // Save changes with approval
  const handleApproveAndSave = async () => {
    if (!currentDialogue) return;
    
    try {
      setIsSaving(true);
      
      const updateData = {
        dialogue: currentDialogue.dialogue,
        character: currentDialogue.character,
        status: revisionRequested ? 'revision-requested' : 'approved',
        timeStart: currentDialogue.timeStart,
        timeEnd: currentDialogue.timeEnd,
        index: currentDialogue.index,
        voiceOverUrl: currentDialogue.voiceOverUrl,
        voiceOverNotes: currentDialogue.voiceOverNotes,
        directorNotes,
        revisionRequested,
      };
      
      const { data: responseData } = await axios.patch(`/api/dialogues/${currentDialogue._id}`, updateData, {
        headers: {
          'Content-Type': 'application/json',
        },
      });
      
      setDialoguesList(prevDialogues => 
        prevDialogues.map(d => 
          d._id === currentDialogue._id ? responseData : d
        )
      );

      queryClient.setQueryData(['dialogues', projectId], (oldData: QueryData | undefined) => {
        if (!oldData?.data) return oldData;
        return {
          ...oldData,
          data: oldData.data.map((d: Dialogue) => 
            d._id === currentDialogue._id ? responseData : d
          )
        };
      });

      setShowSaveSuccess(true);
      setShowConfirmation(false);
      setTimeout(() => setShowSaveSuccess(false), 2000);

      if (currentDialogueIndex < dialoguesList.length - 1) {
        setCurrentDialogueIndex(prev => prev + 1);
      }
    } catch (error) {
      console.error('Error saving review:', error);
      setError(error instanceof Error ? error.message : 'Failed to save review');
      setTimeout(() => setError(''), 3000);
    } finally {
      setIsSaving(false);
    }
  };

  // Motion values for swipe animation
  const x = useMotionValue(0)
  const rotate = useTransform(x, [-200, 200], [-10, 10])
  const opacity = useTransform(x, [-200, -150, 0, 150, 200], [0.5, 1, 1, 1, 0.5])
  const scale = useTransform(x, [-200, -150, 0, 150, 200], [0.8, 0.9, 1, 0.9, 0.8])
  const animControls = useAnimation()

  useEffect(() => {
    if (currentDialogue) {
      setDirectorNotes(currentDialogue.directorNotes || '')
      setRevisionRequested(currentDialogue.revisionRequested || false)
    }
  }, [currentDialogue])

  const handleDragEnd = (event: MouseEvent | TouchEvent | PointerEvent, info: PanInfo) => {
    if (Math.abs(info.offset.x) < 100) {
      animControls.start({ x: 0, opacity: 1 })
    } else {
      const direction = info.offset.x > 0 ? 'right' : 'left'
      if (direction === 'left' && currentDialogueIndex < dialoguesList.length - 1) {
        handleNext();
      } else if (direction === 'right' && currentDialogueIndex > 0) {
        handlePrevious();
      }
    }
  };

  const togglePlayPause = () => {
    if (videoRef.current) {
      if (isPlaying) {
        videoRef.current.pause();
      } else {
        videoRef.current.play();
      }
      setIsPlaying(!isPlaying);
    }
  };

  const rewindFiveSeconds = () => {
    if (videoRef.current) {
      videoRef.current.currentTime = Math.max(0, videoRef.current.currentTime - 5);
    }
  };

  const changePlaybackRate = (rate: number) => {
    if (videoRef.current) {
      videoRef.current.playbackRate = rate;
      setPlaybackRate(rate);
    }
  };

  useEffect(() => {
    const video = videoRef.current;
    if (video) {
      const handlePlay = () => setIsPlaying(true);
      const handlePause = () => setIsPlaying(false);
      
      video.addEventListener('play', handlePlay);
      video.addEventListener('pause', handlePause);
      
      return () => {
        video.removeEventListener('play', handlePlay);
        video.removeEventListener('pause', handlePause);
      };
    }
  }, []);

  if (!currentDialogue) {
    return <div className="text-center p-4">No dialogues available.</div>
  }

  return (
    <div className="w-full max-w-4xl mx-auto px-4 space-y-4 sm:space-y-6">
      {/* Video Player Card */}
      <div className="bg-white border border-gray-200 rounded-lg shadow dark:bg-gray-800 dark:border-gray-700 overflow-hidden">
        <video
          ref={videoRef}
          src={currentDialogue.videoUrl}
          controls
          className="w-full"
        />
        
        {/* Video Controls */}
        <div className="p-3 sm:p-4 border-t border-gray-200 dark:border-gray-700">
          <div className="flex flex-col sm:flex-row items-center justify-center gap-3 sm:gap-4">
            <div className="flex items-center gap-2">
              <button
                onClick={rewindFiveSeconds}
                className="px-3 py-1 bg-blue-500 text-white rounded hover:bg-blue-600 text-sm"
              >
                -5s
              </button>
              <button
                onClick={togglePlayPause}
                className="px-4 py-1 bg-blue-500 text-white rounded hover:bg-blue-600 text-sm"
              >
                {isPlaying ? 'Pause' : 'Play'}
              </button>
            </div>
            <div className="flex items-center gap-2 flex-wrap justify-center">
              <span className="text-sm text-gray-600 dark:text-gray-300">Speed:</span>
              {[0.5, 0.75, 1, 1.25, 1.5].map((rate) => (
                <button
                  key={rate}
                  onClick={() => changePlaybackRate(rate)}
                  className={`px-2 py-1 rounded text-sm ${
                    playbackRate === rate
                      ? 'bg-blue-500 text-white'
                      : 'bg-gray-200 text-gray-700 hover:bg-gray-300 dark:bg-gray-700 dark:text-gray-300'
                  }`}
                >
                  {rate}x
                </button>
              ))}
            </div>
          </div>
        </div>
      </div>

      {/* Dialogue Information Card */}
      <motion.div
        className="bg-white border border-gray-200 rounded-lg shadow dark:bg-gray-800 dark:border-gray-700"
        drag="x"
        dragConstraints={{ left: 0, right: 0 }}
        dragElastic={0.2}
        animate={animControls}
        style={{ x, rotate, opacity, scale }}
        onDragEnd={handleDragEnd}
        whileTap={{ cursor: 'grabbing' }}
        transition={{ 
          type: "spring", 
          stiffness: 300, 
          damping: 30,
          opacity: { duration: 0.2 },
          scale: { duration: 0.2 }
        }}
      >
        <div className="p-5 space-y-4">
          {/* Time Display */}
          <div className="flex items-center gap-4 text-sm">
            <div className="flex items-center gap-2">
              <span className="font-medium text-gray-900 dark:text-white">Start:</span>
              <p className="px-2 py-1 rounded-md border border-gray-300 bg-gray-50 text-gray-900 dark:bg-gray-700 dark:border-gray-600 dark:text-white min-w-[100px] text-center">
                {currentDialogue.timeStart || '00:00.000'}
              </p>
            </div>
            <div className="flex items-center gap-2">
              <span className="font-medium text-gray-900 dark:text-white">End:</span>
              <p className="px-2 py-1 rounded-md border border-gray-300 bg-gray-50 text-gray-900 dark:bg-gray-700 dark:border-gray-600 dark:text-white min-w-[100px] text-center">
                {currentDialogue.timeEnd || '00:00.000'}
              </p>
            </div>
          </div>

          {/* All Text Versions */}
          <div className="grid grid-cols-3 gap-4">
            <div>
              <label className="block text-sm font-medium mb-1 text-gray-900 dark:text-white">
                Original Text
              </label>
              <div className="w-full p-2.5 text-sm rounded-lg border border-gray-300 bg-gray-50 text-gray-900 dark:bg-gray-700 dark:border-gray-600 dark:text-white">
                {currentDialogue.dialogue.original}
              </div>
            </div>
            <div>
              <label className="block text-sm font-medium mb-1 text-gray-900 dark:text-white">
                Translated Text
              </label>
              <div className="w-full p-2.5 text-sm rounded-lg border border-gray-300 bg-gray-50 text-gray-900 dark:bg-gray-700 dark:border-gray-600 dark:text-white">
                {currentDialogue.dialogue.translated}
              </div>
            </div>
            <div>
              <label className="block text-sm font-medium mb-1 text-gray-900 dark:text-white">
                Adapted Text
              </label>
              <div className="w-full p-2.5 text-sm rounded-lg border border-gray-300 bg-gray-50 text-gray-900 dark:bg-gray-700 dark:border-gray-600 dark:text-white">
                {currentDialogue.dialogue.adapted}
              </div>
            </div>
          </div>

          {/* Voice-over Player */}
          {currentDialogue.voiceOverUrl && (
            <div className="flex items-center justify-center">
              <audio controls src={currentDialogue.voiceOverUrl} className="w-64" />
            </div>
          )}

          {/* Voice-over Notes Display */}
          {currentDialogue.voiceOverNotes && (
            <div>
              <label className="block text-sm font-medium mb-1 text-gray-900 dark:text-white">
                Voice-over Notes
              </label>
              <div className="w-full p-2.5 text-sm rounded-lg border border-gray-300 bg-gray-50 text-gray-900 dark:bg-gray-700 dark:border-gray-600 dark:text-white">
                {currentDialogue.voiceOverNotes}
              </div>
            </div>
          )}

          {/* Director Notes */}
          <div>
            <label htmlFor="directorNotes" className="block text-sm font-medium mb-1 text-gray-900 dark:text-white">
              Director Notes
            </label>
            <textarea
              id="directorNotes"
              value={directorNotes}
              onChange={(e) => setDirectorNotes(e.target.value)}
              rows={3}
              className="w-full p-2.5 text-sm rounded-lg border border-gray-300 bg-gray-50 text-gray-900 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white"
              placeholder="Add review notes, suggestions, or requirements..."
            />
          </div>

          {/* Revision Request Toggle */}
          <div className="flex items-center space-x-2">
            <input
              type="checkbox"
              id="revisionRequested"
              checked={revisionRequested}
              onChange={(e) => setRevisionRequested(e.target.checked)}
              className="w-4 h-4 text-blue-600 bg-gray-100 border-gray-300 rounded focus:ring-blue-500 dark:focus:ring-blue-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600"
            />
            <label htmlFor="revisionRequested" className="text-sm font-medium text-gray-900 dark:text-white">
              Request Revision
            </label>
          </div>

          {/* Navigation and Info */}
          <div className="flex items-center justify-center pt-4 mt-4 border-t border-gray-200 dark:border-gray-600">
            <div className="text-center">
              <div className="text-sm font-medium text-gray-900 dark:text-white">
                Dialogue {currentDialogueIndex + 1} of {dialoguesList.length}
              </div>
              <div className="text-xs text-gray-500 dark:text-gray-400">
                {currentDialogue.timeStart} - {currentDialogue.timeEnd}
              </div>
            </div>
          </div>
        </div>
      </motion.div>

      {/* Confirmation Modal */}
      {showConfirmation && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-xl max-w-md w-full">
            <h3 className="text-lg font-semibold mb-4">Unsaved Changes</h3>
            <p className="mb-4">You have unsaved changes. What would you like to do?</p>
            <div className="flex justify-end space-x-4">
              <button
                onClick={handleDiscardChanges}
                className="px-4 py-2 text-gray-600 hover:text-gray-800 dark:text-gray-300 dark:hover:text-white"
              >
                Discard Changes
              </button>
              <button
                onClick={() => setShowConfirmation(false)}
                className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
              >
                Keep Editing
              </button>
              <button
                onClick={handleApproveAndSave}
                disabled={isSaving}
                className="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600 disabled:opacity-50 disabled:cursor-not-allowed"
              >
                {isSaving ? 'Saving...' : revisionRequested ? 'Request Revision' : 'Approve'}
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Feedback Messages */}
      {isSaving && (
        <div className="fixed top-4 right-4 bg-blue-500 text-white px-4 py-2 rounded shadow-lg z-50">
          Saving review...
        </div>
      )}
      
      {showSaveSuccess && (
        <div className="fixed top-4 right-4 bg-green-500 text-white px-4 py-2 rounded shadow-lg z-50">
          Review saved successfully!
        </div>
      )}
      
      {error && (
        <div className="fixed top-4 right-4 bg-red-500 text-white px-4 py-2 rounded shadow-lg z-50">
          {error}
        </div>
      )}
    </div>
  )
} 
```

## File: components\DirectorView.tsx
```tsx
'use client'

import { useSession, signOut } from 'next-auth/react'
import { useRouter } from 'next/navigation'
import { useState } from 'react'

interface Project {
  _id: string
  title: string
  description: string
  sourceLanguage: string
  targetLanguage: string
  status: string
  assignedTo: Array<{
    username: string
    role: string
  }>
}

export default function DirectorView({ projects }: { projects: Project[] }) {
  const { data: session } = useSession()
  const router = useRouter()
  const [isLoggingOut, setIsLoggingOut] = useState(false)

  // Filter projects assigned to current user as director
  const assignedProjects = projects.filter(project => 
    project.assignedTo.some(assignment => 
      assignment.username === session?.user?.username && 
      assignment.role === 'director'
    )
  )

  const handleLogout = async () => {
    try {
      setIsLoggingOut(true)
      // Clear any client-side session data
      if (typeof window !== 'undefined') {
        window.localStorage.clear()
      }
      // Use direct redirect
      await signOut({ 
        redirect: true,
        callbackUrl: '/login'
      })
    } catch (error) {
      console.error('Error during signOut:', error)
      // Fallback redirect if signOut fails
      router.replace('/login')
    } finally {
      setIsLoggingOut(false)
    }
  }

  return (
    <div className="min-h-screen bg-background">
      <div className="max-w-7xl mx-auto px-4 py-6">
        <div className="flex justify-between items-center mb-6 w-full">
          <h1 className="text-2xl font-bold text-foreground">Your Projects</h1>
          <button 
            onClick={handleLogout}
            disabled={isLoggingOut}
            className={`z-50 px-4 py-2 rounded transition-colors ${
              isLoggingOut 
                ? 'bg-gray-400 cursor-not-allowed' 
                : 'bg-red-500 hover:bg-red-600'
            } text-white`}
          >
            {isLoggingOut ? 'Logging out...' : 'Logout'}
          </button>
        </div>

        {assignedProjects.length === 0 ? (
          <div className="text-center p-4">No projects assigned to you as a director.</div>
        ) : (
          <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
            {assignedProjects.map((project) => (
              <div
                key={project._id}
                onClick={() => router.push(`/allDashboards/director/${project._id}`)}
                className="bg-card rounded-lg shadow-lg p-6 cursor-pointer hover:shadow-xl transition-shadow"
              >
                <h2 className="text-xl font-semibold mb-2">{project.title}</h2>
                <p className="text-muted-foreground mb-4">{project.description}</p>
                <div className="text-sm text-muted-foreground">
                  <p>Source Language: {project.sourceLanguage}</p>
                  <p>Status: {project.status}</p>
                </div>
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  )
}


```

## File: components\RecordingTimer.tsx
```tsx
import React, { useState, useEffect } from 'react';
import { Alert } from './ui/alert';

interface RecordingTimerProps {
  isRecording: boolean;
  maxDuration: number;
}

const RecordingTimer: React.FC<RecordingTimerProps> = ({ isRecording, maxDuration }) => {
  const [time, setTime] = useState(0);
  const [showWarning, setShowWarning] = useState(false);

  useEffect(() => {
    let interval: NodeJS.Timeout;
    if (isRecording) {
      interval = setInterval(() => {
        setTime(prev => {
          const newTime = prev + 1;
          if (newTime >= maxDuration * 0.8 && !showWarning) {
            setShowWarning(true);
          }
          if (newTime >= maxDuration) {
            return maxDuration;
          }
          return newTime;
        });
      }, 1000);
    } else {
      setTime(0);
      setShowWarning(false);
    }

    return () => clearInterval(interval);
  }, [isRecording, maxDuration, showWarning]);

  useEffect(() => {
    if (time < maxDuration * 0.8 && showWarning) {
      setShowWarning(false);
    }
  }, [time, maxDuration, showWarning]);

  return (
    <div className="space-y-2">
      <div className="flex justify-between text-sm">
        <span>{String(Math.floor(time / 60)).padStart(2, '0')}:{String(time % 60).padStart(2, '0')}</span>
        <span className="text-gray-500">Max: {maxDuration}s</span>
      </div>
      <div className="h-1.5 bg-gray-200 rounded-full overflow-hidden">
        <div 
          className={`h-full transition-all duration-300 ${
            time / maxDuration > 0.8 ? 'bg-red-500' : 
            time / maxDuration > 0.5 ? 'bg-yellow-500' : 'bg-green-500'
          }`}
          style={{ width: `${(time / maxDuration) * 100}%` }}
        />
      </div>
      {showWarning && (
        <Alert className="py-1 text-sm">
          Recording will stop in {maxDuration - time} seconds
        </Alert>
      )}
    </div>
  );
};

export default RecordingTimer; 
```

## File: components\SystemInit.tsx
```tsx
'use client'

import { useEffect } from 'react'
import { signOut, useSession } from 'next-auth/react'

export default function SystemInit() {
  const { data: session, status } = useSession()

  useEffect(() => {
    const initSystem = async () => {
      console.log('System initialization started:', {
        timestamp: new Date().toISOString(),
        sessionStatus: status
      })

      try {
        // Clear any existing auth tokens from localStorage
        localStorage.removeItem('next-auth.session-token')
        localStorage.removeItem('next-auth.callback-url')
        localStorage.removeItem('next-auth.csrf-token')
        
        // Clear any existing session if user is not authenticated
        if (status === 'unauthenticated') {
          await signOut({ redirect: false })
          console.log('Previous session cleared')
        }

        console.log('System initialization completed:', {
          timestamp: new Date().toISOString(),
          success: true
        })
      } catch (error) {
        console.error('System initialization error:', {
          error,
          timestamp: new Date().toISOString()
        })
      }
    }

    initSystem()
  }, [status])

  return null
} 
```

## File: components\TranscriberDialogueView.tsx
```tsx
import { useState, useRef, useEffect } from 'react'
import { useQueryClient } from '@tanstack/react-query'
import { motion, useMotionValue, useTransform, useAnimation, type PanInfo } from 'framer-motion'
import { useSearchParams, useRouter } from 'next/navigation'
import axios from 'axios'
import { useEpisodeDialogues } from '@/hooks/useEpisodeDialogues'

interface Dialogue {
  _id: string
  index: number
  timeStart: string
  timeEnd: string
  character: string
  videoUrl: string
  projectId?: string
  episodeId?: string
  dialogue: {
    original: string
    translated: string
    adapted: string
  }
  status: string
}

interface Episode {
  _id: string
  name: string
  collectionName: string
  videoPath: string
  videoKey: string
  status: string
  uploadedAt: Date
}

interface DialogueViewProps {
  dialogues: Dialogue[]
  projectId: string
  episodes: Episode[]
  currentEpisodeId?: string
}

type QueryData = {
  data: Dialogue[];
  status: string;
  timestamp: number;
};

export default function TranscriberDialogueView({ 
  dialogues: initialDialogues, 
  projectId,
  episodes,
  currentEpisodeId 
}: DialogueViewProps) {
  const router = useRouter();
  const [searchParams] = useSearchParams();
  const queryClient = useQueryClient();

  // Episode state management
  const [selectedEpisodeId, setSelectedEpisodeId] = useState<string | undefined>(() => {
    // Get episodeId from URL or use currentEpisodeId or first episode if only one exists
    const urlEpisodeId = searchParams.get('episodeId');
    if (urlEpisodeId && episodes.some(ep => ep._id === urlEpisodeId)) {
      return urlEpisodeId;
    }
    if (currentEpisodeId && episodes.some(ep => ep._id === currentEpisodeId)) {
      return currentEpisodeId;
    }
    return episodes.length === 1 ? episodes[0]._id : undefined;
  });

  const selectedEpisode = episodes.find(ep => ep._id === selectedEpisodeId);

  // Fetch dialogues for the selected episode
  const { data: dialoguesForEpisode, isLoading: isLoadingDialogues } = useEpisodeDialogues(
    projectId,
    selectedEpisodeId
  );

  const [dialoguesList, setDialoguesList] = useState<Dialogue[]>(initialDialogues);
  const [currentDialogueIndex, setCurrentDialogueIndex] = useState(0);
  const [isSaving, setIsSaving] = useState(false);
  const [showSaveSuccess, setShowSaveSuccess] = useState(false);
  const [error, setError] = useState<string>('');
  const [character, setCharacter] = useState('');
  const [pendingOriginalText, setPendingOriginalText] = useState('');
  const [showConfirmation, setShowConfirmation] = useState(false);
  const [timeStart, setTimeStart] = useState('');
  const [timeEnd, setTimeEnd] = useState('');
  const [isPlaying, setIsPlaying] = useState(false);
  const videoRef = useRef<HTMLVideoElement>(null);
  const [networkStatus, setNetworkStatus] = useState<'idle' | 'saving' | 'error' | 'success'>('idle');
  const [currentTimestamp, setCurrentTimestamp] = useState('00:00.000');
  const [playbackRate, setPlaybackRate] = useState(1);
  const [isVideoLoading, setIsVideoLoading] = useState(true);

  // Update dialoguesList when episode dialogues change
  useEffect(() => {
    if (dialoguesForEpisode) {
      setDialoguesList(dialoguesForEpisode);
      setCurrentDialogueIndex(0);
    }
  }, [dialoguesForEpisode]);

  // Update URL when episode changes
  useEffect(() => {
    if (selectedEpisodeId) {
      router.replace(`?episodeId=${selectedEpisodeId}`);
    }
  }, [selectedEpisodeId, router]);

  // Early return for no episodes
  if (episodes.length === 0) {
    return (
      <div className="flex items-center justify-center p-4 text-foreground">
        <p>No episodes found for this project.</p>
      </div>
    );
  }

  // Early return for loading state
  if (isLoadingDialogues) {
    return (
      <div className="flex items-center justify-center p-4 text-foreground">
        <p>Loading dialogues...</p>
      </div>
    );
  }

  // Early return for no dialogues
  if (!dialoguesList || dialoguesList.length === 0) {
    return (
      <div className="flex items-center justify-center p-4 text-foreground">
        <p>No dialogues available for {episodes.length === 1 ? 'this episode' : selectedEpisode?.name || 'the selected episode'}.</p>
      </div>
    );
  }

  const currentDialogue = dialoguesList[currentDialogueIndex];

  // Video control functions
  const togglePlayPause = () => {
    if (videoRef.current) {
      if (isPlaying) {
        videoRef.current.pause();
      } else {
        videoRef.current.play();
      }
      setIsPlaying(!isPlaying);
    }
  };

  // Check for unsaved changes
  const hasChanges = () => {
    if (!currentDialogue) return false;
    return (
      character !== currentDialogue.character ||
      pendingOriginalText !== currentDialogue.dialogue.original ||
      timeStart !== currentDialogue.timeStart ||
      timeEnd !== currentDialogue.timeEnd
    );
  };

  // Navigation handlers
  const handleNext = () => {
    if (hasChanges()) {
      setShowConfirmation(true);
    } else if (currentDialogueIndex < dialoguesList.length - 1) {
      setCurrentDialogueIndex(prev => prev + 1);
    }
  };

  const handlePrevious = () => {
    if (currentDialogueIndex > 0) {
      if (hasChanges()) {
        setShowConfirmation(true);
      } else {
        setCurrentDialogueIndex(prev => prev - 1);
      }
    }
  };

  // Reset changes and continue navigation
  const handleDiscardChanges = () => {
    setShowConfirmation(false);
    if (currentDialogue) {
      setCharacter(currentDialogue.character || '');
      setPendingOriginalText(currentDialogue.dialogue.original || '');
      setTimeStart(currentDialogue.timeStart);
      setTimeEnd(currentDialogue.timeEnd);
    }
  };

  // Save changes with approval
  const handleApproveAndSave = async () => {
    if (!currentDialogue) return;
    
    try {
      setNetworkStatus('saving');
      setIsSaving(true);
      
      if (currentDialogue.projectId !== projectId) {
        throw new Error('Project ID mismatch');
      }
      
      const updateData = {
        dialogue: {
          original: pendingOriginalText || currentDialogue.dialogue.original,
          translated: currentDialogue.dialogue.translated || '',
          adapted: currentDialogue.dialogue.adapted || '',
        },
        character: character || currentDialogue.character || '',
        status: 'transcribed',
        timeStart: timeStart || currentDialogue.timeStart,
        timeEnd: timeEnd || currentDialogue.timeEnd,
        index: currentDialogue.index,
        projectId
      };
      
      console.log('Save attempt:', {
        dialogueId: currentDialogue._id,
        currentProjectId: projectId,
        dialogueProjectId: currentDialogue.projectId,
        updateData
      });
      
      const { data: responseData } = await axios.patch(
        `/api/dialogues/${currentDialogue._id}`,
        updateData
      );
      
      setDialoguesList(prevDialogues => 
        prevDialogues.map(d => 
          d._id === currentDialogue._id ? responseData : d
        )
      );

      queryClient.setQueryData(['dialogues', projectId], (oldData: QueryData | undefined) => {
        if (!oldData?.data) return oldData;
        return {
          ...oldData,
          data: oldData.data.map((d: Dialogue) => 
            d._id === currentDialogue._id ? responseData : d
          )
        };
      });

      setNetworkStatus('success');
      setShowConfirmation(false);
      setTimeout(() => setNetworkStatus('idle'), 2000);

      if (currentDialogueIndex < dialoguesList.length - 1) {
        setCurrentDialogueIndex(prev => prev + 1);
      }
    } catch (error) {
      console.error('Save error details:', {
        error,
        dialogue: currentDialogue,
        projectContext: {
          componentProjectId: projectId,
          dialogueProjectId: currentDialogue.projectId,
          dialogueId: currentDialogue._id
        },
        requestData: {
          character,
          pendingOriginalText,
          timeStart,
          timeEnd,
        }
      });
      
      setNetworkStatus('error');
      setError(
        error instanceof Error 
          ? `Save failed: ${error.message}` 
          : 'Failed to save transcription'
      );
    } finally {
      setIsSaving(false);
    }
  };

  // Motion values for swipe animation
  const x = useMotionValue(0)
  const rotate = useTransform(x, [-90, 90], [-10, 10])
  const opacity = useTransform(x, [-200, -150, 0, 150, 200], [0.5, 1, 1, 1, 0.5])
  const scale = useTransform(x, [-200, -150, 0, 150, 200], [0.8, 0.9, 1, 0.9, 0.8])
  const animControls = useAnimation()

  useEffect(() => {
    if (currentDialogue) {
      setCharacter(currentDialogue.character || '')
      setPendingOriginalText(currentDialogue.dialogue.original || '')
      setTimeStart(currentDialogue.timeStart)
      setTimeEnd(currentDialogue.timeEnd)
    }
  }, [currentDialogue])

  useEffect(() => {
    const video = videoRef.current;
    if (video) {
      const handlePlay = () => setIsPlaying(true);
      const handlePause = () => setIsPlaying(false);
      
      video.addEventListener('play', handlePlay);
      video.addEventListener('pause', handlePause);
      
      return () => {
        video.removeEventListener('play', handlePlay);
        video.removeEventListener('pause', handlePause);
      };
    }
  }, []);

  const handleDragEnd = (event: MouseEvent | TouchEvent | PointerEvent, info: PanInfo) => {
    const SWIPE_THRESHOLD = 50;
    const velocity = Math.abs(info.velocity.x);
    const offset = Math.abs(info.offset.x);

    if (offset < SWIPE_THRESHOLD || velocity < 0.5) {
      animControls.start({ x: 0, opacity: 1 })
      return;
    }

    const direction = info.offset.x > 0 ? 'right' : 'left'
    
    if (direction === 'left' && currentDialogueIndex < dialoguesList.length - 1) {
      animControls.start({ 
        x: -200, 
        opacity: 0,
        transition: { duration: 0.2 }
      }).then(() => {
        handleNext();
        animControls.set({ x: 0, opacity: 1 });
      });
    } else if (direction === 'right' && currentDialogueIndex > 0) {
      animControls.start({ 
        x: 200, 
        opacity: 0,
        transition: { duration: 0.2 }
      }).then(() => {
        handlePrevious();
        animControls.set({ x: 0, opacity: 1 });
      });
    }
  };

  // Add new keyboard controls
  useEffect(() => {
    const handleKeyPress = (e: KeyboardEvent) => {
      if (e.target instanceof HTMLTextAreaElement || e.target instanceof HTMLInputElement) {
        return; // Don't trigger shortcuts when typing
      }
      
      switch(e.key.toLowerCase()) {
        case ' ':
          e.preventDefault();
          togglePlayPause();
          break;
        case 'arrowleft':
          e.preventDefault();
          handlePrevious();
          break;
        case 'arrowright':
          e.preventDefault();
          handleNext();
          break;
        case 's':
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            if (hasChanges()) {
              handleApproveAndSave();
            }
          }
          break;
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [togglePlayPause, handlePrevious, handleNext, hasChanges, handleApproveAndSave]);

  // Add timestamp marker functionality
  const formatTime = (seconds: number): string => {
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = Math.floor(seconds % 60);
    const milliseconds = Math.floor((seconds % 1) * 1000);
    return `${String(minutes).padStart(2, '0')}:${String(remainingSeconds).padStart(2, '0')}.${String(milliseconds).padStart(3, '0')}`;
  };

  const handleVideoTimeUpdate = () => {
    if (videoRef.current) {
      const currentTime = videoRef.current.currentTime;
      setCurrentTimestamp(formatTime(currentTime));
    }
  };

  // Add auto-save functionality
  useEffect(() => {
    let autoSaveTimeout: NodeJS.Timeout;

    if (hasChanges()) {
      autoSaveTimeout = setTimeout(() => {
        handleApproveAndSave();
      }, 30000); // Auto-save after 30 seconds of inactivity
    }

    return () => clearTimeout(autoSaveTimeout);
  }, [pendingOriginalText, character, timeStart, timeEnd]);

  // Add status indicator component
  const NetworkStatusIndicator = () => {
    const statusConfig = {
      saving: { bg: 'bg-blue-500', text: 'Saving...' },
      error: { bg: 'bg-red-500', text: 'Error saving' },
      success: { bg: 'bg-green-500', text: 'Saved!' },
    };

    if (networkStatus === 'idle') return null;

    const config = statusConfig[networkStatus as keyof typeof statusConfig];
    
    return (
      <div className={`fixed bottom-20 left-1/2 transform -translate-x-1/2 ${config.bg} text-white px-4 py-2 rounded-full shadow-lg text-sm`}>
        {config.text}
      </div>
    );
  };

  // Add video control functions
  const rewindFiveSeconds = () => {
    if (videoRef.current) {
      videoRef.current.currentTime = Math.max(0, videoRef.current.currentTime - 5);
    }
  };

  const changePlaybackRate = (rate: number) => {
    if (videoRef.current) {
      videoRef.current.playbackRate = rate;
      setPlaybackRate(rate);
    }
  };

  // Add video loading event handlers
  useEffect(() => {
    const video = videoRef.current;
    if (video) {
      const handleLoadStart = () => setIsVideoLoading(true);
      const handleCanPlay = () => setIsVideoLoading(false);
      const handleWaiting = () => setIsVideoLoading(true);
      const handlePlaying = () => setIsVideoLoading(false);
      
      video.addEventListener('loadstart', handleLoadStart);
      video.addEventListener('canplay', handleCanPlay);
      video.addEventListener('waiting', handleWaiting);
      video.addEventListener('playing', handlePlaying);
      
      return () => {
        video.removeEventListener('loadstart', handleLoadStart);
        video.removeEventListener('canplay', handleCanPlay);
        video.removeEventListener('waiting', handleWaiting);
        video.removeEventListener('playing', handlePlaying);
      };
    }
  }, []);

  // Episode selection handler
  const handleEpisodeChange = (episodeId: string) => {
    setSelectedEpisodeId(episodeId);
  };

  return (
    <div className="flex flex-col space-y-4 p-4">
      {/* Episode Selection UI - Only show for multiple episodes */}
      {episodes.length > 1 && (
        <div className="flex flex-col space-y-2">
          <label htmlFor="episode-select" className="text-sm font-medium text-foreground">
            Select Episode
          </label>
          <select
            id="episode-select"
            value={selectedEpisodeId}
            onChange={(e) => handleEpisodeChange(e.target.value)}
            className="rounded-md border border-input bg-background px-3 py-2"
          >
            <option value="">Select an episode...</option>
            {episodes.map((episode) => (
              <option key={episode._id} value={episode._id}>
                {episode.name}
              </option>
            ))}
          </select>
        </div>
      )}

      {/* Current Episode Indicator */}
      {selectedEpisode && (
        <h2 className="text-xl font-semibold text-foreground">
          {episodes.length > 1 ? `Episode: ${selectedEpisode.name}` : selectedEpisode.name}
        </h2>
      )}

      {/* Video Player Card */}
      <div className="bg-white border border-gray-200 rounded-lg shadow dark:bg-gray-800 dark:border-gray-700 overflow-hidden">
        <div className="relative">
          <video
            ref={videoRef}
            src={currentDialogue.videoUrl}
            className="w-full"
          />
          {isVideoLoading && (
            <div className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-50">
              <div className="flex flex-col items-center gap-2">
                <div className="animate-spin rounded-full h-10 w-10 border-b-2 border-white"></div>
                <span className="text-sm text-white">Loading video...</span>
              </div>
            </div>
          )}
        </div>
        
        {/* Video Controls */}
        <div className="p-3 flex items-center justify-center gap-2 flex-wrap">
          <div className="flex items-center gap-2">
            <button
              onClick={rewindFiveSeconds}
              className="px-3 py-1 bg-blue-500 text-white rounded hover:bg-blue-600"
            >
              -5s
            </button>
            <button
              onClick={togglePlayPause}
              className="px-4 py-1 bg-blue-500 text-white rounded hover:bg-blue-600"
            >
              {isPlaying ? 'Pause' : 'Play'}
            </button>
          </div>
          <div className="flex items-center gap-2">
            <span className="text-gray-700 dark:text-gray-300">Speed:</span>
            {[0.5, 0.75, 1].map((rate) => (
              <button
                key={rate}
                onClick={() => changePlaybackRate(rate)}
                className={`px-2 py-1 rounded ${
                  playbackRate === rate
                    ? 'bg-blue-500 text-white'
                    : 'bg-gray-100 text-gray-700 hover:bg-gray-200 dark:bg-gray-700 dark:text-gray-300 dark:hover:bg-gray-600'
                }`}
              >
                {rate}x
              </button>
            ))}
          </div>
        </div>
      </div>

      {/* Dialogue Information Card */}
      <motion.div
        className="bg-white border border-gray-200 rounded-lg shadow dark:bg-gray-800 dark:border-gray-700"
        drag="x"
        dragConstraints={{ left: 0, right: 0 }}
        dragElastic={0.2}
        animate={animControls}
        style={{ x, rotate, opacity, scale }}
        onDragEnd={handleDragEnd}
        whileTap={{ cursor: 'grabbing' }}
        transition={{ 
          type: "spring", 
          stiffness: 300, 
          damping: 30,
          opacity: { duration: 0.2 },
          scale: { duration: 0.2 }
        }}
      >
        <div className="p-3 sm:p-5 space-y-3 sm:space-y-4">
          {/* Character Input */}
          <div>
            <label htmlFor="character" className="block text-sm font-medium mb-1 text-gray-900 dark:text-white">
              Character
            </label>
            <input
              type="text"
              id="character"
              value={character}
              onChange={(e) => setCharacter(e.target.value)}
              className="w-full p-2 text-sm rounded-lg border border-gray-300 bg-gray-50 text-gray-900 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white"
            />
          </div>

          {/* Transcription Text */}
          <div>
            <label htmlFor="originalText" className="block text-sm font-medium mb-1 text-gray-900 dark:text-white">
              Transcription
            </label>
            <textarea
              id="originalText"
              value={pendingOriginalText}
              onChange={(e) => setPendingOriginalText(e.target.value)}
              rows={3}
              className="w-full p-2 text-sm rounded-lg border border-gray-300 bg-gray-50 text-gray-900 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white resize-y min-h-[100px]"
              placeholder="Type the dialogue transcription here..."
            />
          </div>

          {/* Navigation and Info */}
          <div className="flex items-center justify-center pt-3 sm:pt-4 mt-3 sm:mt-4 border-t border-gray-200 dark:border-gray-600">
            <div className="text-center">
              <div className="text-sm font-medium text-gray-900 dark:text-white">
                Dialogue {currentDialogueIndex + 1} of {dialoguesList.length}
              </div>
              <div className="text-xs text-gray-500 dark:text-gray-400">
                {timeStart} - {timeEnd}
              </div>
            </div>
          </div>
        </div>
      </motion.div>

      {/* Confirmation Modal */}
      {showConfirmation && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
          <div className="bg-white dark:bg-gray-800 p-4 sm:p-6 rounded-lg shadow-xl max-w-md w-full">
            <h3 className="text-lg font-semibold mb-4">Unsaved Changes</h3>
            <p className="mb-4">You have unsaved changes. What would you like to do?</p>
            <div className="flex flex-col sm:flex-row justify-end gap-2 sm:gap-4">
              <button
                onClick={handleDiscardChanges}
                className="px-4 py-2 text-gray-600 hover:text-gray-800 dark:text-gray-300 dark:hover:text-white text-sm"
              >
                Discard Changes
              </button>
              <button
                onClick={() => setShowConfirmation(false)}
                className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 text-sm"
              >
                Keep Editing
              </button>
              <button
                onClick={handleApproveAndSave}
                disabled={isSaving}
                className="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600 disabled:opacity-50 disabled:cursor-not-allowed text-sm"
              >
                {isSaving ? 'Saving...' : 'Save Transcription'}
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Feedback Messages */}
      <div className="fixed top-4 right-4 left-4 sm:left-auto z-50 flex flex-col gap-2">
        {isSaving && (
          <div className="bg-blue-500 text-white px-4 py-2 rounded shadow-lg text-sm text-center sm:text-left">
            Saving transcription...
          </div>
        )}
        
        {showSaveSuccess && (
          <div className="bg-green-500 text-white px-4 py-2 rounded shadow-lg text-sm text-center sm:text-left">
            Transcription saved successfully!
          </div>
        )}
        
        {error && (
          <div className="bg-red-500 text-white px-4 py-2 rounded shadow-lg text-sm text-center sm:text-left">
            {error}
          </div>
        )}
      </div>

      {/* Network status indicator */}
      <NetworkStatusIndicator />
    </div>
  )
} 
```

## File: components\TranscriberView.tsx
```tsx
'use client'

import { useSession, signOut } from 'next-auth/react'
import { useRouter } from 'next/navigation'
import { useState } from 'react'

interface Project {
  _id: string
  title: string
  description: string
  sourceLanguage: string
  targetLanguage: string
  status: string
  assignedTo: Array<{
    username: string
    role: string
  }>
}

export default function TranscriberView({ projects }: { projects: Project[] }) {
  const { data: session } = useSession()
  const router = useRouter()
  const [isLoggingOut, setIsLoggingOut] = useState(false)

  // Filter projects assigned to current user as transcriber
  const assignedProjects = projects.filter(project => 
    project.assignedTo.some(assignment => 
      assignment.username === session?.user?.username && 
      assignment.role === 'transcriber'
    )
  )

  const handleLogout = async () => {
    try {
      setIsLoggingOut(true)
      // Clear any client-side session data
      if (typeof window !== 'undefined') {
        window.localStorage.clear()
      }
      // Use direct redirect
      await signOut({ 
        redirect: true,
        callbackUrl: '/login'
      })
    } catch (error) {
      console.error('Error during signOut:', error)
      // Fallback redirect if signOut fails
      router.replace('/login')
    } finally {
      setIsLoggingOut(false)
    }
  }

  return (
    <div className="min-h-screen bg-background">
      <div className="max-w-7xl mx-auto px-4 py-6">
        <div className="flex justify-between items-center mb-6 w-full">
          <h1 className="text-2xl font-bold text-foreground">Your Projects</h1>
          <button 
            onClick={handleLogout}
            disabled={isLoggingOut}
            className={`z-50 px-4 py-2 rounded transition-colors ${
              isLoggingOut 
                ? 'bg-gray-400 cursor-not-allowed' 
                : 'bg-red-500 hover:bg-red-600'
            } text-white`}
          >
            {isLoggingOut ? 'Logging out...' : 'Logout'}
          </button>
        </div>

        {assignedProjects.length === 0 ? (
          <div className="text-center p-4">No projects assigned to you as a transcriber.</div>
        ) : (
          <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
            {assignedProjects.map((project) => (
              <div
                key={project._id}
                onClick={() => router.push(`/allDashboards/transcriber/${project._id}`)}
                className="bg-card rounded-lg shadow-lg p-6 cursor-pointer hover:shadow-xl transition-shadow"
              >
                <h2 className="text-xl font-semibold mb-2">{project.title}</h2>
                <p className="text-muted-foreground mb-4">{project.description}</p>
                <div className="text-sm text-muted-foreground">
                  <p>Source Language: {project.sourceLanguage}</p>
                  <p>Status: {project.status}</p>
                </div>
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  )
}


```

## File: components\TranslatorDialogueView.tsx
```tsx
import { useState, useRef, useEffect } from 'react'
import { useQueryClient } from '@tanstack/react-query'
import { motion, useMotionValue, useTransform, useAnimation, type PanInfo } from 'framer-motion'
import axios from 'axios'

interface Dialogue {
  _id: string
  index: number
  timeStart: string
  timeEnd: string
  character: string
  videoUrl: string
  dialogue: {
    original: string
    translated: string
    adapted: string
  }
  status: string
}

interface DialogueViewProps {
  dialogues: Dialogue[]
  projectId: string
}

type QueryData = {
  data: Dialogue[];
  status: string;
  timestamp: number;
};

export default function TranslatorDialogueView({ dialogues: initialDialogues, projectId }: DialogueViewProps) {
  const [dialoguesList, setDialoguesList] = useState(initialDialogues);
  const [currentDialogueIndex, setCurrentDialogueIndex] = useState(0);
  const [isSaving, setIsSaving] = useState(false);
  const [showSaveSuccess, setShowSaveSuccess] = useState(false);
  const [error, setError] = useState<string>('');
  const [pendingTranslatedText, setPendingTranslatedText] = useState('');
  const [pendingAdaptedText, setPendingAdaptedText] = useState('');
  const [showConfirmation, setShowConfirmation] = useState(false);
  const videoRef = useRef<HTMLVideoElement>(null);
  const queryClient = useQueryClient();
  const [isPlaying, setIsPlaying] = useState(false);
  const [playbackRate, setPlaybackRate] = useState(1);
  const [isVideoLoading, setIsVideoLoading] = useState(true);
  const translationTextareaRef = useRef<HTMLTextAreaElement>(null);
  const adaptedTextareaRef = useRef<HTMLTextAreaElement>(null);

  const currentDialogue = dialoguesList[currentDialogueIndex];

  // Check for unsaved changes
  const hasChanges = () => {
    if (!currentDialogue) return false;
    return pendingTranslatedText !== currentDialogue.dialogue.translated || 
           pendingAdaptedText !== currentDialogue.dialogue.adapted;
  };

  // Navigation handlers
  const handleNext = () => {
    if (hasChanges()) {
      setShowConfirmation(true);
    } else if (currentDialogueIndex < dialoguesList.length - 1) {
      setCurrentDialogueIndex(prev => prev + 1);
    }
  };

  const handlePrevious = () => {
    if (currentDialogueIndex > 0) {
      if (hasChanges()) {
        setShowConfirmation(true);
      } else {
        setCurrentDialogueIndex(prev => prev - 1);
      }
    }
  };

  // Reset changes and continue navigation
  const handleDiscardChanges = () => {
    setShowConfirmation(false);
    if (currentDialogue) {
      setPendingTranslatedText(currentDialogue.dialogue.translated || '');
      setPendingAdaptedText(currentDialogue.dialogue.adapted || '');
    }
  };

  // Save changes with approval
  const handleApproveAndSave = async () => {
    if (!currentDialogue) return;
    
    try {
      setIsSaving(true);
      
      const updateData = {
        dialogue: {
          original: currentDialogue.dialogue.original || '',
          translated: pendingTranslatedText || '',
          adapted: pendingAdaptedText || '',
        },
        character: currentDialogue.character || '',
        status: 'translated',
        timeStart: currentDialogue.timeStart || '',
        timeEnd: currentDialogue.timeEnd || '',
        index: currentDialogue.index,
        projectId
      };
      
      console.log('Translation save attempt:', {
        dialogueId: currentDialogue._id,
        projectId,
        updateData
      });
      
      const { data: responseData } = await axios.patch(
        `/api/dialogues/${currentDialogue._id}`,
        updateData
      );
      
      setDialoguesList(prevDialogues => 
        prevDialogues.map(d => 
          d._id === currentDialogue._id ? responseData : d
        )
      );

      queryClient.setQueryData(['dialogues', projectId], (oldData: QueryData | undefined) => {
        if (!oldData?.data) return oldData;
        return {
          ...oldData,
          data: oldData.data.map((d: Dialogue) => 
            d._id === currentDialogue._id ? responseData : d
          )
        };
      });

      setShowSaveSuccess(true);
      setShowConfirmation(false);
      setTimeout(() => setShowSaveSuccess(false), 2000);

      if (currentDialogueIndex < dialoguesList.length - 1) {
        setCurrentDialogueIndex(prev => prev + 1);
      }
    } catch (error) {
      console.error('Translation save error:', {
        error,
        dialogue: currentDialogue,
        projectId,
        requestData: {
          translated: pendingTranslatedText,
          adapted: pendingAdaptedText
        }
      });
      setError(error instanceof Error ? error.message : 'Failed to save translation');
      setTimeout(() => setError(''), 3000);
    } finally {
      setIsSaving(false);
    }
  };

  // Motion values for swipe animation
  const x = useMotionValue(0)
  const rotate = useTransform(x, [-90, 90], [-10, 10])
  const opacity = useTransform(x, [-200, -150, 0, 150, 200], [0.5, 1, 1, 1, 0.5])
  const scale = useTransform(x, [-200, -150, 0, 150, 200], [0.8, 0.9, 1, 0.9, 0.8])
  const animControls = useAnimation()

  useEffect(() => {
    if (currentDialogue) {
      setPendingTranslatedText(currentDialogue.dialogue.translated || '')
      setPendingAdaptedText(currentDialogue.dialogue.adapted || '')
    }
  }, [currentDialogue])

  const handleDragEnd = (event: MouseEvent | TouchEvent | PointerEvent, info: PanInfo) => {
    const SWIPE_THRESHOLD = 50;
    const velocity = Math.abs(info.velocity.x);
    const offset = Math.abs(info.offset.x);

    if (offset < SWIPE_THRESHOLD || velocity < 0.5) {
      animControls.start({ x: 0, opacity: 1 })
      return;
    }

    const direction = info.offset.x > 0 ? 'right' : 'left'
    
    if (direction === 'left' && currentDialogueIndex < dialoguesList.length - 1) {
      animControls.start({ 
        x: -200, 
        opacity: 0,
        transition: { duration: 0.2 }
      }).then(() => {
        handleNext();
        animControls.set({ x: 0, opacity: 1 });
      });
    } else if (direction === 'right' && currentDialogueIndex > 0) {
      animControls.start({ 
        x: 200, 
        opacity: 0,
        transition: { duration: 0.2 }
      }).then(() => {
        handlePrevious();
        animControls.set({ x: 0, opacity: 1 });
      });
    }
  };


  // Add video control functions
  const togglePlayPause = () => {
    if (videoRef.current) {
      if (isPlaying) {
        videoRef.current.pause();
      } else {
        videoRef.current.play();
      }
      setIsPlaying(!isPlaying);
    }
  };

  const rewindFiveSeconds = () => {
    if (videoRef.current) {
      videoRef.current.currentTime = Math.max(0, videoRef.current.currentTime - 5);
    }
  };

  const changePlaybackRate = (rate: number) => {
    if (videoRef.current) {
      videoRef.current.playbackRate = rate;
      setPlaybackRate(rate);
    }
  };

  // Add useEffect for video event listeners
  useEffect(() => {
    const video = videoRef.current;
    if (video) {
      const handlePlay = () => setIsPlaying(true);
      const handlePause = () => setIsPlaying(false);
      
      video.addEventListener('play', handlePlay);
      video.addEventListener('pause', handlePause);
      
      return () => {
        video.removeEventListener('play', handlePlay);
        video.removeEventListener('pause', handlePause);
      };
    }
  }, []);

  // Add video loading event handlers
  useEffect(() => {
    const video = videoRef.current;
    if (video) {
      const handleLoadStart = () => setIsVideoLoading(true);
      const handleCanPlay = () => setIsVideoLoading(false);
      const handleWaiting = () => setIsVideoLoading(true);
      const handlePlaying = () => setIsVideoLoading(false);
      
      video.addEventListener('loadstart', handleLoadStart);
      video.addEventListener('canplay', handleCanPlay);
      video.addEventListener('waiting', handleWaiting);
      video.addEventListener('playing', handlePlaying);
      
      return () => {
        video.removeEventListener('loadstart', handleLoadStart);
        video.removeEventListener('canplay', handleCanPlay);
        video.removeEventListener('waiting', handleWaiting);
        video.removeEventListener('playing', handlePlaying);
      };
    }
  }, []);

  // Function to adjust textarea height
  const adjustTextareaHeight = (textarea: HTMLTextAreaElement | null) => {
    if (textarea) {
      textarea.style.height = 'auto';
      textarea.style.height = `${textarea.scrollHeight}px`;
    }
  };

  // Adjust heights when text changes
  useEffect(() => {
    adjustTextareaHeight(translationTextareaRef.current);
  }, [pendingTranslatedText]);

  useEffect(() => {
    adjustTextareaHeight(adaptedTextareaRef.current);
  }, [pendingAdaptedText]);

  // Adjust heights when dialogue changes
  useEffect(() => {
    if (currentDialogue) {
      setPendingTranslatedText(currentDialogue.dialogue.translated || '');
      setPendingAdaptedText(currentDialogue.dialogue.adapted || '');
      // Add small delay to ensure state is updated before adjusting height
      setTimeout(() => {
        adjustTextareaHeight(translationTextareaRef.current);
        adjustTextareaHeight(adaptedTextareaRef.current);
      }, 0);
    }
  }, [currentDialogue]);

  if (!currentDialogue) {
    return <div className="text-center p-4">No dialogues available.</div>
  }

  return (
    <div className="w-full max-w-4xl mx-auto px-4 space-y-4 sm:space-y-6">
      {/* Video Player Card */}
      <div className="bg-white border border-gray-200 rounded-lg shadow dark:bg-gray-800 dark:border-gray-700 overflow-hidden">
        <div className="relative">
          <video
            ref={videoRef}
            src={currentDialogue.videoUrl}
            className="w-full"
          />
          {isVideoLoading && (
            <div className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-50">
              <div className="flex flex-col items-center gap-2">
                <div className="animate-spin rounded-full h-10 w-10 border-b-2 border-white"></div>
                <span className="text-sm text-white">Loading video...</span>
              </div>
            </div>
          )}
        </div>
        
        {/* Video Controls */}
        <div className="p-3 flex items-center justify-center gap-2 flex-wrap">
          <div className="flex items-center gap-2">
            <button
              onClick={rewindFiveSeconds}
              className="px-3 py-1 bg-blue-500 text-white rounded hover:bg-blue-600"
            >
              -5s
            </button>
            <button
              onClick={togglePlayPause}
              className="px-4 py-1 bg-blue-500 text-white rounded hover:bg-blue-600"
            >
              {isPlaying ? 'Pause' : 'Play'}
            </button>
          </div>
          <div className="flex items-center gap-2">
            <span className="text-gray-700 dark:text-gray-300">Speed:</span>
            {[0.5, 0.75, 1].map((rate) => (
              <button
                key={rate}
                onClick={() => changePlaybackRate(rate)}
                className={`px-2 py-1 rounded ${
                  playbackRate === rate
                    ? 'bg-blue-500 text-white'
                    : 'bg-gray-100 text-gray-700 hover:bg-gray-200 dark:bg-gray-700 dark:text-gray-300 dark:hover:bg-gray-600'
                }`}
              >
                {rate}x
              </button>
            ))}
          </div>
        </div>
      </div>

      {/* Main Content Card */}
      <motion.div
        className="bg-white border border-gray-200 rounded-lg shadow dark:bg-gray-800 dark:border-gray-700"
        drag="x"
        dragConstraints={{ left: 0, right: 0 }}
        dragElastic={0.2}
        animate={animControls}
        style={{ x, rotate, opacity, scale }}
        onDragEnd={handleDragEnd}
        whileTap={{ cursor: 'grabbing' }}
        transition={{ 
          type: "spring", 
          stiffness: 300, 
          damping: 30,
          opacity: { duration: 0.2 },
          scale: { duration: 0.2 }
        }}
      >
        <div className="p-3 sm:p-5 space-y-3 sm:space-y-4">
          {/* Character Display */}
          {/* <div className="flex items-center gap-2">
            <span className="text-sm font-medium text-gray-900 dark:text-white">
              Character:
            </span>
            <span className="text-gray-900 dark:text-white">
              {currentDialogue.character}
            </span>
          </div> */}

          {/* Original Text */}
          <div>
            <label className="block text-sm font-medium mb-1 text-gray-900 dark:text-white">
              Original Text
            </label>
            <div className="w-full p-2 text-gray-900 dark:text-white">
              {currentDialogue.dialogue.original}
            </div>
          </div>

          {/* Translation Input */}
          <div>
            <label htmlFor="translatedText" className="block text-sm font-medium mb-1 text-gray-900 dark:text-white">
              Translation
            </label>
            <textarea
              ref={translationTextareaRef}
              id="translatedText"
              value={pendingTranslatedText}
              onChange={(e) => setPendingTranslatedText(e.target.value)}
              className="w-full p-2 rounded-lg border border-gray-300 bg-gray-50 text-gray-900 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white resize-none"
            />
          </div>

          {/* Adapted Text Input */}
          <div>
            <label htmlFor="adaptedText" className="block text-sm font-medium mb-1 text-gray-900 dark:text-white">
              Adapted
            </label>
            <textarea
              ref={adaptedTextareaRef}
              id="adaptedText"
              value={pendingAdaptedText}
              onChange={(e) => setPendingAdaptedText(e.target.value)}
              className="w-full p-2 rounded-lg border border-gray-300 bg-gray-50 text-gray-900 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white resize-none"
            />
          </div>

          {/* Navigation and Info */}
          <div className="flex items-center justify-center pt-3 sm:pt-4 mt-3 sm:mt-4 border-t border-gray-200 dark:border-gray-600">
            <div className="text-center">
              <div className="text-sm font-medium text-gray-900 dark:text-white">
                Dialogue {currentDialogueIndex + 1} of {dialoguesList.length}
              </div>
              <div className="text-xs text-gray-500 dark:text-gray-400">
                {currentDialogue.timeStart} - {currentDialogue.timeEnd}
              </div>
            </div>
          </div>
        </div>
      </motion.div>

      {/* Confirmation Modal */}
      {showConfirmation && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
          <div className="bg-white dark:bg-gray-800 p-4 sm:p-6 rounded-lg shadow-xl max-w-md w-full">
            <h3 className="text-lg font-semibold mb-4">Unsaved Changes</h3>
            <p className="mb-4">You have unsaved changes. What would you like to do?</p>
            <div className="flex justify-end gap-2 sm:gap-4">
              <button
                onClick={handleDiscardChanges}
                className="px-4 py-2 text-gray-600 hover:text-gray-800 dark:text-gray-300 dark:hover:text-white text-sm"
              >
                Discard Changes
              </button>
              <button
                onClick={() => setShowConfirmation(false)}
                className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 text-sm"
              >
                Keep Editing
              </button>
              <button
                onClick={handleApproveAndSave}
                disabled={isSaving}
                className="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600 disabled:opacity-50 disabled:cursor-not-allowed text-sm"
              >
                {isSaving ? 'Saving...' : 'Save Translation'}
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Feedback Messages */}
      <div className="fixed top-4 right-4 left-4 sm:left-auto z-50 flex flex-col gap-2">
        {isSaving && (
          <div className="bg-blue-500 text-white px-4 py-2 rounded shadow-lg text-sm text-center sm:text-left">
            Saving translation...
          </div>
        )}
        
        {showSaveSuccess && (
          <div className="bg-green-500 text-white px-4 py-2 rounded shadow-lg text-sm text-center sm:text-left">
            Translation saved successfully!
          </div>
        )}
        
        {error && (
          <div className="bg-red-500 text-white px-4 py-2 rounded shadow-lg text-sm text-center sm:text-left">
            {error}
          </div>
        )}
      </div>
    </div>
  )
} 
```

## File: components\TranslatorView.tsx
```tsx
'use client'

import { useSession, signOut } from 'next-auth/react'
import { useRouter } from 'next/navigation'
import { useState } from 'react'

interface Project {
  _id: string
  title: string
  description: string
  sourceLanguage: string
  targetLanguage: string
  status: string
  assignedTo: Array<{
    username: string
    role: string
  }>
}

export default function TranslatorView({ projects }: { projects: Project[] }) {
  const { data: session } = useSession()
  const router = useRouter()
  const [isLoggingOut, setIsLoggingOut] = useState(false)

  // Filter projects assigned to current user as translator
  const assignedProjects = projects.filter(project => 
    project.assignedTo.some(assignment => 
      assignment.username === session?.user?.username && 
      assignment.role === 'translator'
    )
  )

  const handleLogout = async () => {
    try {
      setIsLoggingOut(true)
      // Clear any client-side session data
      if (typeof window !== 'undefined') {
        window.localStorage.clear()
      }
      // Use direct redirect
      await signOut({ 
        redirect: true,
        callbackUrl: '/login'
      })
    } catch (error) {
      console.error('Error during signOut:', error)
      // Fallback redirect if signOut fails
      router.replace('/login')
    } finally {
      setIsLoggingOut(false)
    }
  }

  return (
    <div className="min-h-screen bg-background">
      <div className="max-w-7xl mx-auto px-4 py-6">
        <div className="flex justify-between items-center mb-6 w-full">
          <h1 className="text-2xl font-bold text-foreground">Your Projects</h1>
          <button 
            onClick={handleLogout}
            disabled={isLoggingOut}
            className={`z-50 px-4 py-2 rounded transition-colors ${
              isLoggingOut 
                ? 'bg-gray-400 cursor-not-allowed' 
                : 'bg-red-500 hover:bg-red-600'
            } text-white`}
          >
            {isLoggingOut ? 'Logging out...' : 'Logout'}
          </button>
        </div>

        {assignedProjects.length === 0 ? (
          <div className="text-center p-4">No projects assigned to you as a translator.</div>
        ) : (
          <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
            {assignedProjects.map((project) => (
              <div
                key={project._id}
                onClick={() => router.push(`/allDashboards/translator/${project._id}`)}
                className="bg-card rounded-lg shadow-lg p-6 cursor-pointer hover:shadow-xl transition-shadow"
              >
                <h2 className="text-xl font-semibold mb-2">{project.title}</h2>
                <p className="text-muted-foreground mb-4">{project.description}</p>
                <div className="text-sm text-muted-foreground">
                  <p>Source Language: {project.sourceLanguage}</p>
                  <p>Status: {project.status}</p>
                </div>
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  )
} 
```

## File: components\ui\alert.tsx
```tsx
import React from 'react';
import { cn } from '../../utils/cn';

interface AlertProps extends React.HTMLAttributes<HTMLDivElement> {
  variant?: 'default' | 'destructive';
  className?: string;
  children: React.ReactNode;
}

export const Alert: React.FC<AlertProps> = ({
  className,
  variant = 'default',
  children,
  ...props
}) => {
  return (
    <div
      role="alert"
      className={cn(
        'rounded-lg border px-4 py-3 text-sm',
        variant === 'default' && 'bg-yellow-50 border-yellow-200 text-yellow-800',
        variant === 'destructive' && 'bg-red-50 border-red-200 text-red-800',
        className
      )}
      {...props}
    >
      {children}
    </div>
  );
}; 
```

## File: components\VoiceOverDialogueView.tsx
```tsx
// VoiceOverDialougeView.tsx

import React, { useState, useRef, useEffect, useCallback } from 'react'
import { useQueryClient } from '@tanstack/react-query'
import { motion, useMotionValue, useAnimation, type PanInfo } from 'framer-motion'
import { type Dialogue } from '../types/dialogue'
import { formatTime, getNumberValue, calculateDuration } from '../utils/formatters'
import { useAudioRecording } from '../hooks/useAudioRecording'
import axios from 'axios'
import AudioVisualizer from './AudioVisualizer'
import RecordingTimer from './RecordingTimer'

// Add new type for recording status
type RecordingStatus = 'available' | 'unavailable' | 'checking';

// Sub-components
const CharacterInfo = React.memo(({ 
  character, 
  voiceOverUrl 
}: { 
  character: string;
  voiceOverUrl?: string;
}) => {
  const [recordingStatus, setRecordingStatus] = useState<RecordingStatus>('checking');

  useEffect(() => {
    const checkRecordingStatus = async () => {
      if (!voiceOverUrl) {
        setRecordingStatus('unavailable');
        return;
      }

      try {
        await axios.head(voiceOverUrl);
        setRecordingStatus('available');
      } catch (error) {
        console.error('Error checking recording status:', error);
        setRecordingStatus('unavailable');
      }
    };

    checkRecordingStatus();
  }, [voiceOverUrl]);

  return (
    <div className="p-2 bg-gray-800">
      <div className="flex items-center justify-center gap-2">
        <span className="text-gray-400">Character:</span>
        <div className="flex items-center gap-2">
          <span className="text-white">{character}</span>
          <div 
            className={`w-3 h-3 rounded-full ${
              recordingStatus === 'checking' 
                ? 'bg-yellow-500 animate-pulse'
                : recordingStatus === 'available'
                ? 'bg-green-500'
                : 'bg-red-500'
            }`}
            title={
              recordingStatus === 'checking'
                ? 'Checking recording status...'
                : recordingStatus === 'available'
                ? 'Recording available'
                : 'Recording not available'
            }
          />
        </div>
      </div>
    </div>
  );
});

CharacterInfo.displayName = 'CharacterInfo';

const VideoPlayer = React.memo(({ 
  videoRef, 
  videoUrl, 
  isVideoLoading 
}: { 
  videoRef: React.RefObject<HTMLVideoElement>,
  videoUrl: string,
  isVideoLoading: boolean
}) => (
  <div className="relative">
    <video
      ref={videoRef}
      src={videoUrl}
      className="w-full aspect-video max-h-[200px] object-contain bg-black"
      aria-label="Dialogue video player"
    />
    {isVideoLoading && (
      <div className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-50">
        <div className="animate-spin rounded-full h-10 w-10 border-b-2 border-white"></div>
      </div>
    )}
  </div>
));

VideoPlayer.displayName = 'VideoPlayer';

const VideoControls = React.memo(({
  isPlaying,
  togglePlayPause,
  handleSyncedPlayback,
  isSyncedPlaying,
  hasRecording,
  audioDuration,
  videoDuration,
}: {
  isPlaying: boolean,
  togglePlayPause: () => void,
  handleSyncedPlayback: () => void,
  isSyncedPlaying: boolean,
  hasRecording: boolean,
  audioDuration: number,
  videoDuration: number,
}) => {
  const durationMatches = Math.abs(audioDuration - videoDuration) < 0.1; // Allow 100ms tolerance

  return (
    <div className="p-2 bg-gray-800 flex flex-col items-center gap-2">
      <div className="flex gap-2 items-center">
        <button
          onClick={togglePlayPause}
          className="px-4 py-1 bg-blue-500 text-white rounded hover:bg-blue-600 text-sm"
          aria-label={isPlaying ? 'Pause video' : 'Play video'}
        >
          {isPlaying ? 'Pause' : 'Play'}
        </button>
        {hasRecording && (
          <div className="flex items-center gap-2">
            <button
              onClick={handleSyncedPlayback}
              className="px-4 py-1 bg-purple-500 text-white rounded hover:bg-purple-600 text-sm"
              aria-label={isSyncedPlaying ? 'Stop synced playback' : 'Play with audio'}
            >
              {isSyncedPlaying ? 'Stop Synced' : 'Play with Audio'}
            </button>
            <div 
              className={`w-3 h-3 rounded-full ${durationMatches ? 'bg-green-500' : 'bg-red-500'}`}
              title={durationMatches 
                ? 'Audio and video durations match' 
                : `Duration mismatch - Video: ${videoDuration.toFixed(3)}s, Audio: ${audioDuration.toFixed(3)}s`}
            />
          </div>
        )}
      </div>
    </div>
  );
});

VideoControls.displayName = 'VideoControls';

const EmotionsDisplay = React.memo(({ emotions }: { emotions: Dialogue['emotions'] }) => (
  <div className="grid grid-cols-2 gap-4">
    <div>
      <span className="text-gray-400">Primary Emotion:</span>
      <p className="text-white">
        {emotions?.primary?.emotion ?? 'Not specified'} 
        {emotions?.primary?.intensity !== undefined && 
          `(Intensity: ${getNumberValue(emotions.primary.intensity)})`
        }
      </p>
    </div>
  </div>
));

EmotionsDisplay.displayName = 'EmotionsDisplay';

const RecordingControls = React.memo(({
  isRecording,
  isPlayingRecording,
  startRecording,
  stopRecording,
  handlePlayRecording,
  hasRecording,
  hasExistingRecording,
  currentIndex,
  totalCount,
  onReRecord,
  onDelete,
  localAudioBlob,
  isProcessing,
  countdown,
  isWaitingForVoice
}: {
  isRecording: boolean,
  isPlayingRecording: boolean,
  startRecording: () => Promise<void>,
  stopRecording: () => void,
  handlePlayRecording: () => void,
  hasRecording: boolean,
  hasExistingRecording: boolean,
  currentIndex: number,
  totalCount: number,
  onReRecord: () => void,
  onDelete: () => void,
  localAudioBlob: Blob | null,
  isProcessing: boolean,
  countdown: number,
  isWaitingForVoice: boolean
}) => {
  const handleStartRecording = async () => {
    if (isProcessing) return;
    
    try {
      await startRecording();
    } catch (error) {
      console.error('Failed to start recording:', error);
    }
  };

  const handleStopRecording = () => {
    try {
      stopRecording();
    } catch (error) {
      console.error('Failed to stop recording:', error);
    }
  };

  return (
    <div className="flex-shrink-0 fixed bottom-0 left-0 right-0 bg-gray-800 border-t border-gray-700">
      <div className="flex flex-col items-center py-4 space-y-4">
        <div className="flex items-center space-x-4">
          {!isRecording && hasExistingRecording && !localAudioBlob && (
            <button
              onClick={onReRecord}
              className="px-6 py-2 rounded-full bg-purple-500 hover:bg-purple-600 text-white transition-colors"
              aria-label="Re-record audio"
              title="Record a new version to replace existing audio"
              disabled={isProcessing}
            >
              Re-Record
            </button>
          )}

          {(!hasExistingRecording || isRecording || localAudioBlob) && (
            <button
              onClick={isRecording ? handleStopRecording : handleStartRecording}
              className={`px-6 py-2 rounded-full ${
                isRecording
                  ? 'bg-red-500 hover:bg-red-600'
                  : 'bg-blue-500 hover:bg-blue-600'
              } text-white transition-colors`}
              aria-label={isRecording ? 'Stop recording' : 'Start recording'}
              disabled={isProcessing}
            >
              {isProcessing && countdown > 0 ? (
                <span className="flex items-center">
                  <span className="text-lg font-bold mr-2">{countdown}</span>
                  Starting...
                </span>
              ) : isWaitingForVoice ? (
                <span className="flex items-center">
                  <span className="animate-pulse">Waiting for voice...</span>
                </span>
              ) : isRecording ? (
                'Stop Recording'
              ) : (
                'Start Recording'
              )}
            </button>
          )}

          {!isRecording && hasRecording && (
            <button
              onClick={handlePlayRecording}
              className={`px-6 py-2 rounded-full ${
                isPlayingRecording
                  ? 'bg-yellow-500 hover:bg-yellow-600'
                  : 'bg-green-500 hover:bg-green-600'
              } text-white transition-colors`}
              aria-label={isPlayingRecording ? 'Stop playing' : 'Play recorded audio'}
              title={isPlayingRecording ? 'Stop current playback' : 'Play recorded audio'}
              disabled={isProcessing}
            >
              {isPlayingRecording ? 'Stop Playing' : 'Play Recorded Audio'}
            </button>
          )}
        </div>

        <div className="text-sm text-gray-300">
          Dialogue {currentIndex + 1} of {totalCount}
        </div>
      </div>
    </div>
  );
});

RecordingControls.displayName = 'RecordingControls';

// Update the ConfirmationModal interface
interface ConfirmationModalProps {
  isOpen: boolean;
  onClose: () => void;
  onDiscard: () => void;
  onApprove: () => void;
  isSaving: boolean;
  type: 'navigation' | 'discard';
  direction?: 'next' | 'previous';
}

const ConfirmationModal = ({
  isOpen,
  onClose,
  onDiscard,
  onApprove,
  isSaving,
  type,
  direction
}: ConfirmationModalProps) => {
  if (!isOpen) return null;
  
  const getTitle = () => {
    if (type === 'navigation') {
      return 'Unsaved Changes - Navigation';
    }
    return 'Unsaved Changes';
  };

  const getMessage = () => {
    if (type === 'navigation') {
      return `You have unsaved changes. Would you like to save them before moving to the ${direction} dialogue?`;
    }
    return 'You have unsaved changes. What would you like to do?';
  };

  const getDiscardButtonText = () => {
    if (type === 'navigation') {
      return 'Discard and Continue';
    }
    return 'Delete Recording';
  };

  const getApproveButtonText = () => {
    if (isSaving) return 'Saving...';
    if (type === 'navigation') {
      return 'Save and Continue';
    }
    return 'Save';
  };
  
  return (
    <div 
      className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50"
      onClick={(e: React.MouseEvent<HTMLDivElement>) => {
        if (e.target === e.currentTarget) {
          onClose();
        }
      }}
      role="dialog"
      aria-modal="true"
      aria-labelledby="modal-title"
    >
      <div className="bg-gray-800 p-6 rounded-lg shadow-xl max-w-md w-full">
        <h3 id="modal-title" className="text-lg font-semibold mb-4 text-white">
          {getTitle()}
        </h3>
        <p className="mb-4 text-gray-300">
          {getMessage()}
        </p>
        <div className="flex justify-end space-x-4">
          <button
            onClick={onDiscard}
            className="px-4 py-2 text-gray-400 hover:text-white transition-colors"
            disabled={isSaving}
          >
            {getDiscardButtonText()}
          </button>
          <button
            onClick={onApprove}
            disabled={isSaving}
            className="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
          >
            {getApproveButtonText()}
          </button>
        </div>
      </div>
    </div>
  );
};

const Notifications = ({
  isSaving,
  showSaveSuccess,
  error
}: {
  isSaving: boolean,
  showSaveSuccess: boolean,
  error: string
}) => (
  <>
    {isSaving && (
      <div className="fixed top-4 right-4 bg-blue-500 text-white px-4 py-2 rounded shadow-lg z-50" role="alert">
        Approving voice-over...
      </div>
    )}
    
    {showSaveSuccess && (
      <div className="fixed top-4 right-4 bg-green-500 text-white px-4 py-2 rounded shadow-lg z-50" role="alert">
        Voice-over saved successfully!
      </div>
    )}
    
    {error && (
      <div className="fixed top-4 right-4 bg-red-500 text-white px-4 py-2 rounded shadow-lg z-50" role="alert">
        {error}
      </div>
    )}
  </>
)

const LoadingSpinner = () => (
  <div className="flex items-center justify-center h-screen bg-gray-900">
    <div className="animate-spin rounded-full h-16 w-16 border-b-2 border-white"></div>
  </div>
)

interface ErrorFallbackProps {
  error: AppError;
  resetError: () => void;
}

const ErrorFallback = ({ error, resetError }: ErrorFallbackProps) => (
  <div className="flex flex-col items-center justify-center h-screen bg-gray-900 text-white p-4">
    <h2 className="text-xl font-bold mb-4">Something went wrong</h2>
    <pre className="bg-gray-800 p-4 rounded mb-4 max-w-lg overflow-auto">
      {error.message}
      {error.code && <div className="text-sm text-gray-400 mt-2">Error code: {error.code}</div>}
      {error.status && <div className="text-sm text-gray-400">Status: {error.status}</div>}
    </pre>
    <button
      onClick={resetError}
      className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
    >
      Try again
    </button>
  </div>
)

interface DialogueViewProps {
  dialogues: Dialogue[];
  projectId: string;
}

interface QueryData {
  data: Dialogue[];
  status: string;
  timestamp: number;
}

interface AppError extends Error {
  code?: string;
  status?: number;
}

// Add logging utility
const logEvent = (message: string, data?: Record<string, unknown>): void => {
  console.log(message, data);
};

export default function VoiceOverDialogueView({ dialogues: initialDialogues, projectId }: DialogueViewProps) {
  const [dialoguesList, setDialoguesList] = useState(initialDialogues);
  const [currentDialogueIndex, setCurrentDialogueIndex] = useState(0);
  const [isSaving, setIsSaving] = useState(false);
  const [showSaveSuccess, setShowSaveSuccess] = useState(false);
  const [error, setError] = useState<string>('');
  const [showConfirmation, setShowConfirmation] = useState(false);
  const [isVideoLoading, setIsVideoLoading] = useState(false);
  const [localAudioBlob, setLocalAudioBlob] = useState<Blob | null>(null);
  const videoRef = useRef<HTMLVideoElement>(null);
  const queryClient = useQueryClient();
  const [isPlaying, setIsPlaying] = useState(false);
  const dragX = useMotionValue(0);
  const dragControls = useAnimation();
  const [confirmationType, setConfirmationType] = useState<'navigation' | 'discard'>('discard');
  const [navigationDirection, setNavigationDirection] = useState<'next' | 'previous' | undefined>();
  const [pendingNavigationIndex, setPendingNavigationIndex] = useState<number | null>(null);
  const [isSyncedPlaying, setIsSyncedPlaying] = useState(false);
  const audioRef = useRef<HTMLAudioElement | null>(null);
  const [audioDuration, setAudioDuration] = useState(0);

  const currentDialogue = dialoguesList[currentDialogueIndex];
  const maxDuration = currentDialogue ? calculateDuration(currentDialogue.timeStart, currentDialogue.timeEnd) : 0;

  const {
    audioBlob,
    isRecording,
    recordingDuration,
    isPlayingRecording,
    startRecording,
    stopRecording,
    handlePlayRecording,
    setPlayingState,
    isProcessing,
    countdown,
    isWaitingForVoice,
    audioStream
  } = useAudioRecording(currentDialogue);

  // Add audio player ref for remote audio
  const audioPlayerRef = useRef<HTMLAudioElement | null>(null);

  // Function to handle playing remote audio
  const handlePlayRemoteAudio = useCallback(() => {
    if (!currentDialogue?.voiceOverUrl) return;

    if (audioPlayerRef.current) {
      audioPlayerRef.current.pause();
      audioPlayerRef.current = null;
      setPlayingState(false);
      return;
    }

    const audio = new Audio(currentDialogue.voiceOverUrl);
    audioPlayerRef.current = audio;

    audio.addEventListener('ended', () => {
      setPlayingState(false);
      audioPlayerRef.current = null;
    });

    audio.addEventListener('error', () => {
      setPlayingState(false);
      audioPlayerRef.current = null;
      setError('Failed to play audio');
    });

    audio.play().then(() => {
      setPlayingState(true);
    }).catch(error => {
      console.error('Failed to play audio:', error);
      setError('Failed to play audio');
      audioPlayerRef.current = null;
    });
  }, [currentDialogue?.voiceOverUrl, setPlayingState]);

  // Combined play function
  const handlePlayAudio = useCallback(() => {
    if (localAudioBlob) {
      handlePlayRecording();
    } else if (currentDialogue?.voiceOverUrl) {
      handlePlayRemoteAudio();
    }
  }, [localAudioBlob, currentDialogue?.voiceOverUrl, handlePlayRecording, handlePlayRemoteAudio]);

  // Cleanup audio on unmount or dialogue change
  useEffect(() => {
    return () => {
      if (audioPlayerRef.current) {
        audioPlayerRef.current.pause();
        audioPlayerRef.current = null;
      }
    };
  }, [currentDialogue?._id]);

  // Update local audio blob when recording changes
  useEffect(() => {
    setLocalAudioBlob(audioBlob);
  }, [audioBlob]);

  // Navigation handlers
  const hasChanges = useCallback(() => {
    return localAudioBlob !== null;
  }, [localAudioBlob]);

  const handleNext = useCallback(() => {
    if (hasChanges()) {
      setConfirmationType('navigation');
      setNavigationDirection('next');
      setPendingNavigationIndex(currentDialogueIndex + 1);
      setShowConfirmation(true);
    } else if (currentDialogueIndex < dialoguesList.length - 1) {
      setCurrentDialogueIndex(prev => prev + 1);
    }
  }, [currentDialogueIndex, dialoguesList.length, hasChanges, setConfirmationType, setNavigationDirection, setPendingNavigationIndex, setShowConfirmation]);

  const handlePrevious = useCallback(() => {
    if (currentDialogueIndex > 0) {
      if (hasChanges()) {
        setConfirmationType('navigation');
        setNavigationDirection('previous');
        setPendingNavigationIndex(currentDialogueIndex - 1);
        setShowConfirmation(true);
      } else {
        setCurrentDialogueIndex(prev => prev - 1);
      }
    }
  }, [currentDialogueIndex, hasChanges]);

  const handleDeleteRecording = async () => {
    if (!currentDialogue) return;

    try {
      setIsSaving(true);
      logEvent('Deleting voice-over recording', { dialogueId: currentDialogue._id });

      const updateData = {
        dialogue: currentDialogue.dialogue,
        character: currentDialogue.character,
        timeStart: currentDialogue.timeStart,
        timeEnd: currentDialogue.timeEnd,
        index: currentDialogue.index,
        deleteVoiceOver: true
      };

      const response = await axios.put(`/api/dialogues/${currentDialogue._id}`, updateData);

      if (!response.data || !response.data._id) {
        throw new Error('Failed to delete recording: Invalid response');
      }

      // Update local state
      const updatedDialogues = dialoguesList.map(dialogue => 
        dialogue._id === currentDialogue._id 
          ? { ...dialogue, voiceOverUrl: undefined, status: 'pending' }
          : dialogue
      );
      setDialoguesList(updatedDialogues);

      // Clear local audio blob
      setLocalAudioBlob(null);

      // Show success message
      setShowSaveSuccess(true);
      setTimeout(() => setShowSaveSuccess(false), 3000);

      // Invalidate queries to refetch data
      await queryClient.invalidateQueries({ queryKey: ['dialogues', projectId] });

      logEvent('Voice-over recording deleted successfully', { dialogueId: currentDialogue._id });
    } catch (error) {
      console.error('Error deleting recording:', error);
      setError('Failed to delete recording');
      setTimeout(() => setError(''), 3000);
    } finally {
      setIsSaving(false);
    }
  };

  const handleDiscardChanges = async () => {
    try {
      if (confirmationType === 'navigation') {
        if (pendingNavigationIndex !== null) {
          setCurrentDialogueIndex(pendingNavigationIndex);
          setPendingNavigationIndex(null);
        }
      } else {
        await handleDeleteRecording();
      }

      // Close confirmation modal
      setShowConfirmation(false);
      setNavigationDirection(undefined);
    } catch (error) {
      console.error('Error discarding changes:', error);
      setError('Failed to delete recording');
      setTimeout(() => setError(''), 3000);
    }
  };

  // Video control functions
  const togglePlayPause = useCallback(() => {
    if (videoRef.current) {
      if (isPlaying) {
        videoRef.current.pause();
      } else {
        videoRef.current.play();
      }
      setIsPlaying(!isPlaying);
    }
  }, [isPlaying]);

  // Add video event listeners
  useEffect(() => {
    const video = videoRef.current;
    if (video) {
      const handlePlay = () => setIsPlaying(true);
      const handlePause = () => setIsPlaying(false);
      const handleLoadStart = () => setIsVideoLoading(true);
      const handleLoadEnd = () => setIsVideoLoading(false);

      video.addEventListener('play', handlePlay);
      video.addEventListener('pause', handlePause);
      video.addEventListener('loadstart', handleLoadStart);
      video.addEventListener('canplay', handleLoadEnd);
      video.addEventListener('error', handleLoadEnd);
      
      return () => {
        video.removeEventListener('play', handlePlay);
        video.removeEventListener('pause', handlePause);
        video.removeEventListener('loadstart', handleLoadStart);
        video.removeEventListener('canplay', handleLoadEnd);
        video.removeEventListener('error', handleLoadEnd);
      };
    }
  }, [currentDialogue?.videoUrl]);

  // Save changes with approval
  const handleApproveAndSave = async () => {
    if (!currentDialogue) return;
    
    try {
      setIsSaving(true);
      logEvent('Starting save process', {
        dialogueId: currentDialogue._id,
        hasNewRecording: !!localAudioBlob,
        hasExistingRecording: !!currentDialogue.voiceOverUrl
      });
      
      let voiceOverUrl = currentDialogue.voiceOverUrl;
      
      // Upload audio if new recording exists
      if (localAudioBlob) {
        logEvent('Preparing to upload audio', {
          dialogueId: currentDialogue._id,
          blobSize: localAudioBlob.size
        });

        const formData = new FormData();
        formData.append('audio', localAudioBlob);
        formData.append('dialogueId', currentDialogue._id);
        formData.append('dialogueIndex', currentDialogue.index.toString());
        formData.append('projectId', projectId);
        
        logEvent('Uploading audio file');
        try {
          const uploadResponse = await axios.post('/api/upload-voice-over', formData, {
            headers: {
              'Content-Type': 'multipart/form-data',
            },
            validateStatus: function (status) {
              return status < 500; // Resolve only if the status code is less than 500
            }
          });
          
          if (!uploadResponse.data.url) {
            logEvent('Upload failed', {
              status: uploadResponse.status,
              error: uploadResponse.data.error || 'No URL returned'
            });
            throw new Error(uploadResponse.data.error || 'Failed to upload voice-over recording');
          }
          
          const { url } = uploadResponse.data;
          voiceOverUrl = url;
          logEvent('Audio upload successful', { url });
        } catch (error: unknown) {
          const uploadError = error as { message: string; response?: { status: number } };
          logEvent('Upload failed', {
            error: uploadError.message,
            status: uploadError.response?.status
          });
          throw new Error('Failed to upload voice-over recording: ' + uploadError.message);
        }
      }
      
      // Only check for voiceOverUrl if we're not uploading a new recording
      if (!localAudioBlob && !voiceOverUrl && !currentDialogue.voiceOverUrl) {
        logEvent('No voice-over URL available', { dialogueId: currentDialogue._id });
        throw new Error('No voice-over recording available to save');
      }
      
      const updateData = {
        dialogue: currentDialogue.dialogue,
        character: currentDialogue.character,
        status: 'voice-over-added',
        timeStart: currentDialogue.timeStart,
        timeEnd: currentDialogue.timeEnd,
        index: currentDialogue.index,
        voiceOverUrl: voiceOverUrl || currentDialogue.voiceOverUrl,
      };
      
      logEvent('Updating dialogue metadata', { 
        dialogueId: currentDialogue._id,
        voiceOverUrl: updateData.voiceOverUrl
      });
      
      const response = await axios.put(`/api/dialogues/${currentDialogue._id}`, updateData);
      
      if (!response.data || !response.data._id) {
        logEvent('Metadata update failed', {
          status: response.status,
          error: response.data?.error || 'No response data'
        });
        throw new Error(response.data?.error || 'Failed to save voice-over: Invalid response');
      }

      // Get fresh copy of dialogues list to avoid race conditions
      const currentDialogues = [...dialoguesList];
      const updatedDialogues = currentDialogues.map(dialogue => 
        dialogue._id === currentDialogue._id ? { ...dialogue, ...response.data } : dialogue
      );
      setDialoguesList(updatedDialogues);

      // Clear local audio blob
      setLocalAudioBlob(null);

      // Show success message
      setShowSaveSuccess(true);
      setTimeout(() => setShowSaveSuccess(false), 3000);

      // Close confirmation modal if open
      setShowConfirmation(false);

      // Invalidate queries to refetch data
      await queryClient.invalidateQueries({ queryKey: ['dialogues', projectId] });

      logEvent('Save process completed successfully', {
        dialogueId: currentDialogue._id
      });

      // Handle navigation after save
      if (pendingNavigationIndex !== null) {
        logEvent('Navigating to next dialogue', {
          from: currentDialogueIndex,
          to: pendingNavigationIndex
        });
        setCurrentDialogueIndex(pendingNavigationIndex);
        setPendingNavigationIndex(null);
      } else if (currentDialogueIndex < dialoguesList.length - 1) {
        logEvent('Auto-advancing to next dialogue', {
          from: currentDialogueIndex,
          to: currentDialogueIndex + 1
        });
        setCurrentDialogueIndex(prev => prev + 1);
      }
    } catch (err) {
      console.error('Error saving voice-over:', err);
      const error = err as AppError;
      logEvent('Save process failed', {
        error: error.message,
        dialogueId: currentDialogue._id,
        hasLocalBlob: !!localAudioBlob,
        hasExistingUrl: !!currentDialogue.voiceOverUrl
      });
      setError(error.message || 'Failed to save voice-over');
      setTimeout(() => setError(''), 3000);
    } finally {
      setIsSaving(false);
      setNavigationDirection(undefined);
    }
  };

  const handleDragEnd = async (event: MouseEvent | TouchEvent | PointerEvent, info: PanInfo): Promise<void> => {
    const threshold = 100;
    const velocity = info.velocity.x;
    const offset = info.offset.x;

    if (Math.abs(velocity) >= 500 || Math.abs(offset) >= threshold) {
      if (velocity > 0 || offset > threshold) {
        // Swipe right - go to previous
        if (currentDialogueIndex > 0) {
          if (hasChanges()) {
            setConfirmationType('navigation');
            setNavigationDirection('previous');
            setPendingNavigationIndex(currentDialogueIndex - 1);
            setShowConfirmation(true);
          } else {
            setCurrentDialogueIndex(prev => prev - 1);
          }
        }
      } else {
        // Swipe left - go to next
        if (currentDialogueIndex < dialoguesList.length - 1) {
          if (localAudioBlob) {
            setConfirmationType('navigation');
            setNavigationDirection('next');
            setPendingNavigationIndex(currentDialogueIndex + 1);
            setShowConfirmation(true);
          } else {
            setCurrentDialogueIndex(prev => prev + 1);
          }
        }
      }
    }
    
    await dragControls.start({ x: 0 });
  };

  // Add recording state logging
  useEffect(() => {
    if (isRecording) {
      logEvent('Recording started', {
        dialogueId: currentDialogue?._id,
        maxDuration,
        dialogueIndex: currentDialogueIndex + 1,
        totalDialogues: dialoguesList.length
      });
    }
  }, [isRecording]);

  // Add audio blob logging
  useEffect(() => {
    if (localAudioBlob) {
      logEvent('New recording created', {
        dialogueId: currentDialogue?._id,
        blobSize: localAudioBlob.size,
        blobType: localAudioBlob.type,
        duration: recordingDuration
      });
    }
  }, [localAudioBlob]);

  // Optimize audio blob state effect
  useEffect(() => {
    const hasLocalBlob = !!localAudioBlob;
    const hasExistingRecording = !!currentDialogue?.voiceOverUrl;
    
    // Only log if there's an actual change in the state
    if (hasLocalBlob || hasExistingRecording) {
      logEvent('Audio blob state changed:', {
        hasLocalBlob,
        localBlobSize: localAudioBlob?.size,
        hasExistingRecording
      });
    }
  }, [localAudioBlob, currentDialogue?.voiceOverUrl]);

  const handleReRecord = useCallback(() => {
    try {
      logEvent('Re-record button clicked', {
        dialogueId: currentDialogue?._id,
        existingUrl: currentDialogue?.voiceOverUrl
      });

      // Show confirmation modal before starting re-record
      setConfirmationType('discard');
      setShowConfirmation(true);
    } catch (error) {
      console.error('Failed to handle re-record:', error);
      setError('Failed to start re-recording');
    }
  }, [currentDialogue, setConfirmationType, setShowConfirmation, setError]);

  useEffect(() => {
    if (currentDialogue?._id && recordingDuration && maxDuration) {
      const key = `recording_duration_${currentDialogue._id}`;
      localStorage.setItem(key, recordingDuration.toString());
    }
  }, [currentDialogue?._id, recordingDuration, maxDuration]);

  useEffect(() => {
    if (currentDialogue?._id && currentDialogueIndex < dialoguesList.length) {
      // Your existing effect logic
      const handleKeyPress = (event: KeyboardEvent) => {
        if (event.key === 'ArrowRight') {
          handleNext();
        } else if (event.key === 'ArrowLeft') {
          handlePrevious();
        }
      };
      window.addEventListener('keydown', handleKeyPress);
      return () => window.removeEventListener('keydown', handleKeyPress);
    }
  }, [currentDialogue?._id, currentDialogueIndex, dialoguesList.length, maxDuration, handleNext, handlePrevious]);

  // Add cleanup effect for dialogue changes
  useEffect(() => {
    // Clean up audio when switching dialogues
    if (audioPlayerRef.current) {
      audioPlayerRef.current.pause();
      audioPlayerRef.current = null;
    }
    
    // Reset states
    setIsPlaying(false);
    setLocalAudioBlob(null);
    
    return () => {
      // Cleanup on unmount
      if (audioPlayerRef.current) {
        audioPlayerRef.current.pause();
        audioPlayerRef.current = null;
      }
    };
  }, [currentDialogue?._id]);

  // Add function to handle synced playback
  const handleSyncedPlayback = useCallback(() => {
    if (isSyncedPlaying) {
      // Stop both video and audio
      if (videoRef.current) {
        videoRef.current.pause();
      }
      if (audioRef.current) {
        audioRef.current.pause();
        audioRef.current = null;
      }
      setIsSyncedPlaying(false);
      setIsPlaying(false);
      return;
    }

    const playSync = async () => {
      try {
        if (!videoRef.current) return;

        // Create audio element
        const audio = new Audio();
        if (localAudioBlob) {
          audio.src = URL.createObjectURL(localAudioBlob);
        } else if (currentDialogue?.voiceOverUrl) {
          audio.src = currentDialogue.voiceOverUrl;
        } else {
          return;
        }

        audioRef.current = audio;

        // Set up cleanup on audio end
        audio.addEventListener('ended', () => {
          setIsSyncedPlaying(false);
          setIsPlaying(false);
          if (videoRef.current) {
            videoRef.current.pause();
            videoRef.current.muted = false; // Restore video audio
          }
          URL.revokeObjectURL(audio.src);
          audioRef.current = null;
        });

        // Mute video audio
        videoRef.current.muted = true;

        // Start playback
        videoRef.current.currentTime = 0;
        await Promise.all([
          videoRef.current.play(),
          audio.play()
        ]);

        setIsSyncedPlaying(true);
        setIsPlaying(true);
      } catch (error) {
        console.error('Failed to start synced playback:', error);
        setIsSyncedPlaying(false);
        setIsPlaying(false);
        if (audioRef.current) {
          audioRef.current.pause();
          audioRef.current = null;
        }
        if (videoRef.current) {
          videoRef.current.pause();
          videoRef.current.muted = false; // Restore video audio on error
        }
      }
    };

    playSync();
  }, [localAudioBlob, currentDialogue?.voiceOverUrl, isSyncedPlaying]);

  // Add cleanup for synced playback
  useEffect(() => {
    return () => {
      if (audioRef.current) {
        audioRef.current.pause();
        audioRef.current = null;
      }
    };
  }, [currentDialogue?._id]);

  // Add function to get audio duration
  const updateAudioDuration = useCallback(async (blob: Blob | string) => {
    try {
      const audio = new Audio();
      if (blob instanceof Blob) {
        audio.src = URL.createObjectURL(blob);
      } else {
        audio.src = blob;
      }

      await new Promise((resolve) => {
        audio.addEventListener('loadedmetadata', () => {
          setAudioDuration(audio.duration);
          resolve(true);
        });
        audio.addEventListener('error', () => {
          console.error('Error loading audio duration');
          setAudioDuration(0);
          resolve(false);
        });
      });

      if (blob instanceof Blob) {
        URL.revokeObjectURL(audio.src);
      }
    } catch (error) {
      console.error('Error getting audio duration:', error);
      setAudioDuration(0);
    }
  }, []);

  // Update audio duration when audio blob or URL changes
  useEffect(() => {
    if (localAudioBlob) {
      updateAudioDuration(localAudioBlob);
    } else if (currentDialogue?.voiceOverUrl) {
      updateAudioDuration(currentDialogue.voiceOverUrl);
    } else {
      setAudioDuration(0);
    }
  }, [localAudioBlob, currentDialogue?.voiceOverUrl, updateAudioDuration]);

  return (
    <div className="w-full h-screen flex flex-col bg-gray-900">
      <CharacterInfo 
        character={currentDialogue.character} 
        voiceOverUrl={currentDialogue.voiceOverUrl}
      />
      
      <VideoPlayer 
        videoRef={videoRef}
        videoUrl={currentDialogue.videoUrl}
        isVideoLoading={isVideoLoading}
      />
      
      <VideoControls 
        isPlaying={isPlaying}
        togglePlayPause={togglePlayPause}
        handleSyncedPlayback={handleSyncedPlayback}
        isSyncedPlaying={isSyncedPlaying}
        hasRecording={!!localAudioBlob || !!currentDialogue?.voiceOverUrl}
        audioDuration={audioDuration}
        videoDuration={maxDuration}
      />

      <motion.div 
        className="flex-grow overflow-y-auto p-4"
        drag="x"
        dragConstraints={{ left: 0, right: 0 }}
        dragElastic={0.2}
        onDragEnd={handleDragEnd}
        animate={dragControls}
        style={{ x: dragX }}
      >
        <EmotionsDisplay emotions={currentDialogue.emotions} />
        
        <div className="mt-4">
          <span className="text-gray-400">Adapted Text:</span>
          <p className="text-white">{currentDialogue.dialogue.adapted}</p>
        </div>

        {isRecording && audioStream && (
          <div className="mt-4 space-y-4">
            <AudioVisualizer
              audioStream={audioStream}
              maxDuration={maxDuration}
            />
            <RecordingTimer
              isRecording={isRecording}
              maxDuration={maxDuration}
            />
          </div>
        )}

        <div className="flex flex-col items-center justify-center text-sm text-gray-400 space-y-2 mt-4">
          <span>Recording duration limit: {formatTime(maxDuration)}</span>
          {isRecording && (
            <span>Recording time: {formatTime(recordingDuration)}</span>
          )}
        </div>
      </motion.div>

      <RecordingControls 
        isRecording={isRecording}
        isPlayingRecording={isPlayingRecording}
        startRecording={startRecording}
        stopRecording={stopRecording}
        handlePlayRecording={handlePlayAudio}
        hasRecording={!!localAudioBlob || !!currentDialogue?.voiceOverUrl}
        hasExistingRecording={!!currentDialogue?.voiceOverUrl}
        currentIndex={currentDialogueIndex}
        totalCount={dialoguesList.length}
        onReRecord={handleReRecord}
        onDelete={handleDeleteRecording}
        localAudioBlob={localAudioBlob}
        isProcessing={isProcessing}
        countdown={countdown}
        isWaitingForVoice={isWaitingForVoice}
      />

      <ConfirmationModal 
        isOpen={showConfirmation}
        onClose={() => {
          setShowConfirmation(false);
          setPendingNavigationIndex(null);
          setNavigationDirection(undefined);
        }}
        onDiscard={handleDiscardChanges}
        onApprove={handleApproveAndSave}
        isSaving={isSaving}
        type={confirmationType}
        direction={navigationDirection}
      />

      <Notifications 
        isSaving={isSaving}
        showSaveSuccess={showSaveSuccess}
        error={error}
      />
    </div>
  );
} 
```

## File: components\VoiceOverView.tsx
```tsx
'use client'

import { useSession, signOut } from 'next-auth/react'
import { useRouter } from 'next/navigation'
import { useState } from 'react'

interface Project {
  _id: string
  title: string
  description: string
  sourceLanguage: string
  targetLanguage: string
  status: string
  assignedTo: Array<{
    username: string
    role: string
  }>
}

export default function VoiceOverView({ projects }: { projects: Project[] }) {
  const { data: session } = useSession()
  const router = useRouter()
  const [isLoggingOut, setIsLoggingOut] = useState(false)

  console.log('VoiceOverView Component:', {
    sessionExists: !!session,
    userRole: session?.user?.role,
    username: session?.user?.username,
    totalProjects: projects.length
  })

  // Filter projects assigned to current user as voice-over
  const assignedProjects = projects.filter(project => 
    project.assignedTo.some(assignment => {
      const matches = assignment.username === session?.user?.username && 
                     assignment.role === 'voiceOver'
      console.log('Project assignment check:', {
        projectTitle: project.title,
        assignmentUsername: assignment.username,
        assignmentRole: assignment.role,
        userUsername: session?.user?.username,
        matches
      })
      return matches
    })
  )

  console.log('Filtered projects:', {
    totalAssigned: assignedProjects.length,
    assignedProjectTitles: assignedProjects.map(p => p.title)
  })

  const handleLogout = async () => {
    try {
      console.log('Initiating logout')
      setIsLoggingOut(true)
      // Clear any client-side session data
      if (typeof window !== 'undefined') {
        window.localStorage.clear()
      }
      // Use direct redirect
      await signOut({ 
        redirect: true,
        callbackUrl: '/login'
      })
    } catch (error) {
      console.error('Error during signOut:', error)
      // Fallback redirect if signOut fails
      router.replace('/login')
    } finally {
      setIsLoggingOut(false)
    }
  }

  return (
    <div className="min-h-screen bg-background">
      <div className="max-w-7xl mx-auto px-4 py-6">
        <div className="flex justify-between items-center mb-6 w-full">
          <h1 className="text-2xl font-bold text-foreground">Your Projects</h1>
          <button 
            onClick={handleLogout}
            disabled={isLoggingOut}
            className={`z-50 px-4 py-2 rounded transition-colors ${
              isLoggingOut 
                ? 'bg-gray-400 cursor-not-allowed' 
                : 'bg-red-500 hover:bg-red-600'
            } text-white`}
          >
            {isLoggingOut ? 'Logging out...' : 'Logout'}
          </button>
        </div>

        {assignedProjects.length === 0 ? (
          <div className="text-center p-4">No projects assigned to you as a voice-over artist.</div>
        ) : (
          <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
            {assignedProjects.map((project) => (
              <div
                key={project._id}
                onClick={() => {
                  console.log('Navigating to project:', {
                    projectId: project._id,
                    projectTitle: project.title
                  })
                  router.push(`/allDashboards/voice-over/${project._id}`)
                }}
                className="bg-card rounded-lg shadow-lg p-6 cursor-pointer hover:shadow-xl transition-shadow"
              >
                <h2 className="text-xl font-semibold mb-2">{project.title}</h2>
                <p className="text-muted-foreground mb-4">{project.description}</p>
                <div className="text-sm text-muted-foreground">
                  <p>Source Language: {project.sourceLanguage}</p>
                  <p>Status: {project.status}</p>
                </div>
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  )
}


```

## File: components.json
```json
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "app/globals.css",
    "baseColor": "slate",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}
```

## File: hooks\useAudioRecording.ts
```ts
//useAudioRecording.ts

import { useState, useRef, useEffect, useCallback, useMemo } from 'react';
import { type Dialogue } from '../types/dialogue';
import { createWorker, createWavBlob, type AudioData } from '../utils/audio';

// Move constants outside component to prevent recreation
const AUDIO_CONFIG = {
  sampleRate: 48000,
  channelCount: 2,
  latencyHint: 'interactive' as const,
  echoCancellation: true,
  noiseSuppression: true,
  autoGainControl: false
} as const;

const logEvent = (message: string, data?: any) => {
  if (process.env.NODE_ENV === 'development') {
    const timestamp = new Date().toISOString();
    // console.log(`[${timestamp}] ${message}`, data ? data : '');
  }
};

export const useAudioRecording = (currentDialogue: Dialogue) => {
  // Add new state for processing and countdown
  const [processingState, setProcessingState] = useState({
    isProcessing: false,
    countdown: 0,
    isWaitingForVoice: false
  });

  // Group related states to reduce re-renders
  const [recordingState, setRecordingState] = useState({
    isRecording: false,
    duration: 0,
    isPlaying: false
  });

  const [audioState, setAudioState] = useState({
    blob: null as Blob | null,
    blobUrl: null as string | null,
    chunks: [] as AudioData[]
  });

  // Use refs for values that don't need to trigger re-renders
  const refs = useRef({
    recordingTimer: null as NodeJS.Timeout | null,
    audioContext: null as AudioContext | null,
    workletNode: null as AudioWorkletNode | null,
    sourceNode: null as MediaStreamAudioSourceNode | null,
    audioPlayer: null as HTMLAudioElement | null,
    maxDuration: 0,
    stream: null as MediaStream | null,
    cleanupInProgress: false,
    stoppingInProgress: false,
    countdownInterval: null as NodeJS.Timeout | null,
    maxDurationTimeout: null as NodeJS.Timeout | null
  });

  // Memoize parseTime function
  const parseTime = useMemo(() => {
    return (time: string): number => {
      const [hours, minutes, seconds, milliseconds] = time.split(':').map(Number);
      return (hours * 3600) + (minutes * 60) + seconds + (milliseconds / 1000);
    };
  }, []);

  // Memoize maxDuration calculation
  useEffect(() => {
    if (currentDialogue?.timeStart && currentDialogue?.timeEnd) {
      const startSeconds = parseTime(currentDialogue.timeStart);
      const endSeconds = parseTime(currentDialogue.timeEnd);
      refs.current.maxDuration = Number((endSeconds - startSeconds).toFixed(3));
    }
  }, [currentDialogue?.timeStart, currentDialogue?.timeEnd, parseTime]);

  const cleanup = useCallback(() => {
    if (refs.current.cleanupInProgress) return;
    refs.current.cleanupInProgress = true;
    
    try {
      logEvent('Cleaning up recording resources');
      
      // Clear timer
      if (refs.current.recordingTimer) {
        clearInterval(refs.current.recordingTimer);
        refs.current.recordingTimer = null;
      }

      // Stop audio playback
      if (refs.current.audioPlayer) {
        refs.current.audioPlayer.pause();
        refs.current.audioPlayer = null;
      }

      // Clean up blob URL
      if (audioState.blobUrl) {
        URL.revokeObjectURL(audioState.blobUrl);
        setAudioState(prev => ({ ...prev, blobUrl: null }));
      }

      // Stop and disconnect worklet
      if (refs.current.workletNode) {
        try {
          refs.current.workletNode.port.postMessage('stop');
          refs.current.workletNode.disconnect();
          refs.current.workletNode = null;
        } catch (error) {
          console.error('Error stopping worklet:', error);
        }
      }

      // Disconnect source
      if (refs.current.sourceNode) {
        try {
          refs.current.sourceNode.disconnect();
          refs.current.sourceNode = null;
        } catch (error) {
          console.error('Error disconnecting source:', error);
        }
      }

      // Stop media stream
      if (refs.current.stream) {
        try {
          refs.current.stream.getTracks().forEach(track => track.stop());
          refs.current.stream = null;
        } catch (error) {
          console.error('Error stopping media tracks:', error);
        }
      }

      // Close audio context
      if (refs.current.audioContext) {
        try {
          refs.current.audioContext.close();
          refs.current.audioContext = null;
        } catch (error) {
          console.error('Error closing audio context:', error);
        }
      }

      setRecordingState(prev => ({ ...prev, isRecording: false }));
      refs.current.stoppingInProgress = false;
    } catch (error) {
      console.error('Error during cleanup:', error);
    } finally {
      refs.current.cleanupInProgress = false;
    }
  }, [audioState.blobUrl]);

  const stopRecording = useCallback(() => {
    if (refs.current.stoppingInProgress) return;
    refs.current.stoppingInProgress = true;
    
    logEvent('Stopping recording', { chunksCount: audioState.chunks.length });
    
    if (refs.current.recordingTimer) {
      clearInterval(refs.current.recordingTimer);
      refs.current.recordingTimer = null;
    }

    if (refs.current.workletNode) {
      refs.current.workletNode.port.postMessage('stop');
    } else {
      cleanup();
    }
  }, [audioState.chunks.length, cleanup]);

  // Add countdown functionality
  const startCountdown = useCallback(() => {
    setProcessingState(prev => ({ ...prev, countdown: 3 }));
    
    refs.current.countdownInterval = setInterval(() => {
      setProcessingState(prev => {
        if (prev.countdown <= 1) {
          if (refs.current.countdownInterval) {
            clearInterval(refs.current.countdownInterval);
          }
          return { ...prev, countdown: 0 };
        }
        return { ...prev, countdown: prev.countdown - 1 };
      });
    }, 1000);
  }, []);

  const startRecording = useCallback(async () => {
    if (processingState.isProcessing) return;
    
    try {
      setProcessingState(prev => ({ ...prev, isProcessing: true }));
      cleanup();
      setAudioState(prev => ({ ...prev, chunks: [], blob: null }));

      // Start countdown
      startCountdown();
      await new Promise(resolve => setTimeout(resolve, 3000));

      setProcessingState(prev => ({ ...prev, isWaitingForVoice: true }));

      if (!window.AudioContext) {
        throw new Error('AudioContext not supported');
      }

      const stream = await navigator.mediaDevices.getUserMedia({ 
        audio: {
          echoCancellation: AUDIO_CONFIG.echoCancellation,
          noiseSuppression: AUDIO_CONFIG.noiseSuppression,
          sampleRate: AUDIO_CONFIG.sampleRate,
          channelCount: AUDIO_CONFIG.channelCount,
          autoGainControl: AUDIO_CONFIG.autoGainControl
        } 
      });
      
      refs.current.stream = stream;
      refs.current.audioContext = new AudioContext({
        sampleRate: AUDIO_CONFIG.sampleRate,
        latencyHint: AUDIO_CONFIG.latencyHint
      });

      // Create analyzer for voice detection
      const analyser = refs.current.audioContext.createAnalyser();
      analyser.fftSize = 256;
      const bufferLength = analyser.frequencyBinCount;
      const dataArray = new Uint8Array(bufferLength);
      
      const sourceNode = refs.current.audioContext.createMediaStreamSource(stream);
      sourceNode.connect(analyser);
      refs.current.sourceNode = sourceNode;

      // Wait for voice input
      await new Promise((resolve) => {
        const checkAudio = () => {
          analyser.getByteFrequencyData(dataArray);
          const average = dataArray.reduce((acc, value) => acc + value, 0) / bufferLength;
          
          if (average > 20) { // Threshold for voice detection
            setProcessingState(prev => ({ ...prev, isWaitingForVoice: false }));
            resolve(true);
          } else {
            requestAnimationFrame(checkAudio);
          }
        };
        checkAudio();
      });

      const workletNode = await createWorker(refs.current.audioContext);
      refs.current.workletNode = workletNode;

      // Set up recording chunks
      const recordingChunks = [] as AudioData[];

      workletNode.addEventListener('audiochunk', ((event: CustomEvent<AudioData>) => {
        const chunk = event.detail;
        recordingChunks.push(chunk);
        setAudioState(prev => ({ ...prev, chunks: [...prev.chunks, chunk] }));
      }) as EventListener);

      workletNode.addEventListener('stopped', () => {
        if (recordingChunks.length === 0) {
          cleanup();
          return;
        }

        try {
          const combinedAudioData = recordingChunks.reduce((acc: Float32Array[], chunk) => {
            if (!chunk.audioData?.length) return acc;
            
            chunk.audioData.forEach((channel, i) => {
              if (!channel?.length) return;
              
              if (!acc[i]) {
                acc[i] = new Float32Array(channel.length);
                acc[i].set(channel);
              } else {
                const newArray = new Float32Array(acc[i].length + channel.length);
                newArray.set(acc[i], 0);
                newArray.set(channel, acc[i].length);
                acc[i] = newArray;
              }
            });
            return acc;
          }, []);

          if (!combinedAudioData.length || !combinedAudioData[0]?.length) {
            throw new Error('No valid audio data recorded');
          }

          if (!refs.current.audioContext) {
            throw new Error('AudioContext is not available');
          }

          const wavBlob = createWavBlob(combinedAudioData, refs.current.audioContext.sampleRate);
          setAudioState(prev => ({ ...prev, blob: wavBlob, chunks: [] }));
        } catch (error) {
          console.error('Error processing audio:', error);
          throw error;
        } finally {
          recordingChunks.length = 0;
          cleanup();
        }
      });

      // Connect nodes for recording
      sourceNode.disconnect(); // Disconnect from analyzer
      sourceNode.connect(workletNode);
      workletNode.connect(refs.current.audioContext.destination);

      setRecordingState(prev => ({ ...prev, isRecording: true, duration: 0 }));
      
      // Set up max duration timeout
      refs.current.maxDurationTimeout = setTimeout(() => {
        stopRecording();
      }, refs.current.maxDuration * 1000);

      // Set up duration timer
      refs.current.recordingTimer = setInterval(() => {
        setRecordingState(prev => {
          const newDuration = Number((prev.duration + 0.01).toFixed(3));
          if (newDuration >= refs.current.maxDuration) {
            stopRecording();
            return { ...prev, duration: refs.current.maxDuration };
          }
          return { ...prev, duration: newDuration };
        });
      }, 10);

    } catch (error) {
      console.error('Recording failed:', error);
      cleanup();
      throw error;
    } finally {
      setProcessingState(prev => ({ 
        ...prev, 
        isProcessing: false,
        isWaitingForVoice: false 
      }));
    }
  }, [cleanup, stopRecording, startCountdown]);

  const handlePlayRecording = useCallback(() => {
    if (!audioState.blob) return;

    // If already playing, stop playback
    if (recordingState.isPlaying) {
      if (refs.current.audioPlayer) {
        refs.current.audioPlayer.pause();
        refs.current.audioPlayer = null;
      }
      setRecordingState(prev => ({ ...prev, isPlaying: false }));
      return;
    }

    let audioUrl: string | null = null;
    try {
      // Create new audio element and URL
      audioUrl = URL.createObjectURL(audioState.blob);
      const audio = new Audio(audioUrl);
      refs.current.audioPlayer = audio;

      // Set up event listeners
      const cleanup = () => {
        setRecordingState(prev => ({ ...prev, isPlaying: false }));
        refs.current.audioPlayer = null;
        if (audioUrl) {
          URL.revokeObjectURL(audioUrl);
          audioUrl = null;
        }
      };

      audio.addEventListener('ended', cleanup);
      audio.addEventListener('error', () => {
        console.error('Audio playback error');
        cleanup();
      });

      // Start playback
      audio.play()
        .then(() => {
          setRecordingState(prev => ({ ...prev, isPlaying: true }));
        })
        .catch(error => {
          console.error('Failed to play audio:', error);
          cleanup();
        });
    } catch (error) {
      console.error('Error setting up audio playback:', error);
      setRecordingState(prev => ({ ...prev, isPlaying: false }));
      if (refs.current.audioPlayer) {
        refs.current.audioPlayer = null;
      }
      if (audioUrl) {
        URL.revokeObjectURL(audioUrl);
      }
    }
  }, [audioState.blob, recordingState.isPlaying]);

  // Reset state when dialogue changes
  useEffect(() => {
    if (!currentDialogue?._id) return;
    cleanup();
    setRecordingState({ isRecording: false, duration: 0, isPlaying: false });
    setAudioState({ blob: null, blobUrl: null, chunks: [] });
  }, [currentDialogue?._id, cleanup]);

  // Add cleanup for countdown interval
  useEffect(() => {
    return () => {
      if (refs.current.countdownInterval) {
        clearInterval(refs.current.countdownInterval);
      }
      if (refs.current.maxDurationTimeout) {
        clearTimeout(refs.current.maxDurationTimeout);
      }
    };
  }, []);

  return {
    isRecording: recordingState.isRecording,
    recordingDuration: recordingState.duration,
    audioBlob: audioState.blob,
    isPlayingRecording: recordingState.isPlaying,
    isProcessing: processingState.isProcessing,
    countdown: processingState.countdown,
    isWaitingForVoice: processingState.isWaitingForVoice,
    startRecording,
    stopRecording,
    handlePlayRecording,
    hasRecording: !!audioState.blob || !!currentDialogue?.voiceOverUrl,
    setPlayingState: (isPlaying: boolean) => setRecordingState(prev => ({ ...prev, isPlaying })),
    audioStream: refs.current.stream
  };
}; 
```

## File: hooks\useDialogues.ts
```ts
import { useQuery } from '@tanstack/react-query'
import { type Dialogue } from '@/types/dialogue'
import { type Project } from '@/types/project'
import axios from 'axios'

// Maintain a record of logged projectIds
const loggedProjectIds = new Set<string>();

async function fetchDialogues(projectId: string): Promise<Dialogue[]> {
  // Only log once per projectId per session
  if (!loggedProjectIds.has(projectId)) {
    console.log('=== Dialogue Fetch Debug ===');
    console.log('Project ID:', projectId);
    console.log('Fetching URL:', `/api/dialogues?projectId=${projectId}`);
    loggedProjectIds.add(projectId);
  }

  try {
    const { data } = await axios.get(`/api/dialogues?projectId=${projectId}`);
    
    // Only log response data once per projectId
    if (loggedProjectIds.size === 1) {
      console.log('Response data:', data);
      console.log('=== End Debug ===');
    }
    
    return data.data || [];
  } catch (error) {
    console.error('Fetch error:', error);
    throw error;
  }
}

export function useDialogues(projectId: string) {
  return useQuery({
    queryKey: ['dialogues', projectId],
    queryFn: () => fetchDialogues(projectId),
    enabled: !!projectId,
    staleTime: 5 * 60 * 1000, // Consider data fresh for 5 minutes
    gcTime: 30 * 60 * 1000, // Keep unused data for 30 minutes
  });
} 
```

## File: hooks\useEpisodeDialogues.ts
```ts
import { useQuery } from '@tanstack/react-query'
import { type Dialogue } from '@/types/dialogue'
import axios from 'axios'

async function fetchEpisodeDialogues(projectId: string, episodeId: string): Promise<Dialogue[]> {
  try {
    const { data } = await axios.get(`/api/dialogues?projectId=${projectId}&episodeId=${episodeId}`);
    return data.data || [];
  } catch (error) {
    console.error('Fetch episode dialogues error:', error);
    throw error;
  }
}

export function useEpisodeDialogues(projectId: string, episodeId: string | undefined) {
  return useQuery({
    queryKey: ['dialogues', projectId, episodeId],
    queryFn: () => fetchEpisodeDialogues(projectId, episodeId!),
    enabled: !!projectId && !!episodeId,
  })
} 
```

## File: hooks\useEpisodes.ts
```ts
import { useQuery } from '@tanstack/react-query'
import { type Episode } from '@/types/project'
import axios from 'axios'

async function fetchEpisodes(projectId: string): Promise<Episode[]> {
  try {
    const { data } = await axios.get(`/api/episodes?projectId=${projectId}`);
    return data.data || [];
  } catch (error) {
    console.error('Fetch episodes error:', error);
    throw error;
  }
}

export function useEpisodes(projectId: string) {
  return useQuery({
    queryKey: ['episodes', projectId],
    queryFn: () => fetchEpisodes(projectId),
    enabled: !!projectId,
  })
} 
```

## File: hooks\useProject.ts
```ts
import { useQuery } from '@tanstack/react-query'
import { type Project } from '@/types/project'
import axios from 'axios'

async function fetchProject(projectId: string): Promise<Project> {
  console.log('=== Project Fetch Debug ===');
  console.log('Fetching project ID:', projectId);
  
  const url = `/api/projects/${projectId}`;
  console.log('Fetching URL:', url);

  try {
    const { data } = await axios.get(url);
    console.log('Project data:', data);
    console.log('=== End Debug ===');
    return data;
  } catch (error) {
    console.error('Fetch error:', error);
    throw error;
  }
}

export function useProject(projectId: string) {
  console.log('useProject hook called with projectId:', projectId);
  
  return useQuery({
    queryKey: ['project', projectId],
    queryFn: () => fetchProject(projectId),
    enabled: !!projectId,
    staleTime: 5 * 60 * 1000, // Consider data fresh for 5 minutes
    gcTime: 30 * 60 * 1000, // Keep unused data for 30 minutes
  });
} 
```

## File: hooks\useProjects.ts
```ts
import { useQuery } from '@tanstack/react-query'
import axios from 'axios'

interface Project {
  _id: string
  title: string
  description: string
  sourceLanguage: string
  targetLanguage: string
  status: string
  assignedTo: Array<{
    username: string
    role: string
  }>
}

// Track if initial fetch has been logged
let hasLoggedInitialFetch = false;

async function fetchProjects(): Promise<Project[]> {
  if (!hasLoggedInitialFetch) {
    console.log('=== Projects Fetch Debug ===');
    hasLoggedInitialFetch = true;
  }
  
  try {
    const { data } = await axios.get('/api/projects')
    
    if (!hasLoggedInitialFetch) {
      console.log('Projects data:', data);
      console.log('=== End Debug ===');
    }
    
    return data
  } catch (error) {
    console.error('Failed to fetch projects:', error)
    throw error
  }
}

export function useProjects() {
  return useQuery({
    queryKey: ['projects'],
    queryFn: fetchProjects,
    staleTime: 5 * 60 * 1000, // Consider data fresh for 5 minutes
    gcTime: 30 * 60 * 1000, // Keep unused data for 30 minutes
  })
} 
```

## File: jest.config.ts
```ts
import type { Config } from 'jest'
import nextJest from 'next/jest'

const createJestConfig = nextJest({
    dir: './',
})

const customJestConfig: Config = {
    preset: 'ts-jest',
    testEnvironment: 'jsdom',
    setupFilesAfterEnv: ['<rootDir>/jest.setup.ts'],
    moduleNameMapper: {
        '^@/(.*)$': '<rootDir>/$1',
    },
    testPathIgnorePatterns: [
        '<rootDir>/node_modules/',
        '<rootDir>/.next/',
        '<rootDir>/coverage/',
        '<rootDir>/dist/',
    ],
    coveragePathIgnorePatterns: [
        '<rootDir>/node_modules/',
        '<rootDir>/.next/',
        '<rootDir>/coverage/',
        '<rootDir>/dist/',
    ],
    transform: {
        '^.+\\.(ts|tsx)$': ['ts-jest', { tsconfig: 'tsconfig.test.json' }],
    },
    testMatch: ['**/__tests__/**/*.test.[jt]s?(x)'],
    moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx', 'json', 'node'],
    verbose: true,
    bail: false,
    passWithNoTests: true,
}

export default createJestConfig(customJestConfig) 
```

## File: jest.setup.ts
```ts
import '@testing-library/jest-dom'
import { TextEncoder, TextDecoder } from 'util'
import { jest } from '@jest/globals'

// Mock next/navigation
jest.mock('next/navigation', () => ({
  useRouter() {
    return {
      push: jest.fn(),
      replace: jest.fn(),
      prefetch: jest.fn(),
    }
  },
  useSearchParams() {
    return {
      get: jest.fn(),
    }
  },
}))

// Mock next-auth
jest.mock('next-auth/react', () => ({
  useSession() {
    return {
      data: {
        user: { role: 'transcriber' },
      },
      status: 'authenticated',
    }
  },
  signIn: jest.fn(),
  signOut: jest.fn(),
}))

// Mock react-query
jest.mock('@tanstack/react-query', () => ({
  useQuery: jest.fn(),
  useQueryClient: jest.fn(() => ({
    setQueryData: jest.fn(),
  })),
}))

// Set up DOM environment
Object.defineProperty(global, 'TextEncoder', {
  value: TextEncoder,
})

Object.defineProperty(global, 'TextDecoder', {
  value: TextDecoder,
})

// Mock window.URL
global.URL.createObjectURL = jest.fn(() => 'mock-url')
global.URL.revokeObjectURL = jest.fn()

// Mock MediaRecorder
class MockMediaRecorder {
  start = jest.fn()
  stop = jest.fn()
  pause = jest.fn()
  resume = jest.fn()
  addEventListener = jest.fn()
  removeEventListener = jest.fn()
  state = 'inactive'

  static isTypeSupported(type: string) {
    return true
  }
}

global.MediaRecorder = MockMediaRecorder as any

// Mock HTMLMediaElement
Object.defineProperty(window.HTMLMediaElement.prototype, 'play', {
  configurable: true,
  value: jest.fn(),
})

Object.defineProperty(window.HTMLMediaElement.prototype, 'pause', {
  configurable: true,
  value: jest.fn(),
})
```

## File: lib\auth.ts
```ts
import { NextAuthOptions } from 'next-auth'
import CredentialsProvider from 'next-auth/providers/credentials'
import { connectToDatabase } from './mongodb'
import bcrypt from 'bcryptjs'
import { UserRole } from '@/types/user'

if (!process.env.NEXTAUTH_SECRET) {
  throw new Error('Please define the NEXTAUTH_SECRET environment variable')
}

export const authOptions: NextAuthOptions = {
  providers: [
    CredentialsProvider({
      name: 'Credentials',
      credentials: {
        username: { label: "Username", type: "text" },
        password: { label: "Password", type: "password" }
      },
      async authorize(credentials, req) {
        if (!credentials?.username || !credentials?.password) {
          throw new Error('Please enter your username and password')
        }

        try {
          const { db } = await connectToDatabase()
          const user = await db.collection('users').findOne({ username: credentials.username })

          console.log('User lookup result:', {
            found: !!user,
            role: user?.role,
            username: user?.username,
            timestamp: new Date().toISOString()
          })

          if (!user) {
            console.log('Authentication failed: User not found', {
              attemptedUsername: credentials.username,
              timestamp: new Date().toISOString()
            })
            throw new Error('Invalid username or password')
          }

          const isPasswordValid = await bcrypt.compare(credentials.password, user.password)
          console.log('Password validation:', { 
            isValid: isPasswordValid,
            username: user.username,
            timestamp: new Date().toISOString()
          })

          if (!isPasswordValid) {
            console.log('Authentication failed: Invalid password', {
              username: user.username,
              timestamp: new Date().toISOString()
            })
            throw new Error('Invalid username or password')
          }

          // Ensure role is in the correct format
          const role = user.role as UserRole
          console.log('Role validation:', {
            role,
            username: user.username,
            timestamp: new Date().toISOString()
          })

          // Update last login
          await db.collection('users').updateOne(
            { _id: user._id },
            { $set: { lastLogin: new Date() } }
          )

          const userData = {
            id: user._id.toString(),
            username: user.username,
            role: role,
            email: user.email
          }

          console.log('Authentication successful:', {
            username: userData.username,
            role: userData.role,
            timestamp: new Date().toISOString()
          })

          return userData
        } catch (error) {
          console.error('Authentication error:', {
            error: error instanceof Error ? error.message : 'Unknown error',
            type: error instanceof Error ? error.constructor.name : typeof error,
            timestamp: new Date().toISOString(),
            username: credentials.username
          })
          throw error
        }
      }
    })
  ],
  callbacks: {
    async jwt({ token, user }) {
      if (user) {
        console.log('JWT generation:', {
          username: user.username,
          role: user.role,
          timestamp: new Date().toISOString()
        })
        token.id = user.id
        token.username = user.username
        token.role = user.role
        token.email = user.email
      }
      return token
    },
    async session({ session, token }) {
      if (token) {
        console.log('Session creation:', {
          username: token.username,
          role: token.role,
          timestamp: new Date().toISOString()
        })
        session.user = {
          ...session.user,
          id: token.id as string,
          username: token.username as string,
          role: token.role as string,
          email: token.email as string
        }
      }
      return session
    }
  },
  pages: {
    signIn: '/login',
    error: '/login'
  },
  session: {
    strategy: 'jwt',
    maxAge: 30 * 24 * 60 * 60 // 30 days
  },
  secret: process.env.NEXTAUTH_SECRET,
  debug: process.env.NODE_ENV === 'development'
} 
```

## File: lib\mongodb.ts
```ts
import { MongoClient } from 'mongodb'

if (!process.env.MONGODB_URI) {
  throw new Error('Invalid/Missing environment variable: "MONGODB_URI"')
}

if (!process.env.MONGODB_DB) {
  throw new Error('Invalid/Missing environment variable: "MONGODB_DB"')
}

// Ensure the URI has the correct protocol
const uri = process.env.MONGODB_URI.startsWith('mongodb://') || process.env.MONGODB_URI.startsWith('mongodb+srv://')
  ? process.env.MONGODB_URI
  : `mongodb+srv://${process.env.MONGODB_URI}`

const dbName = process.env.MONGODB_DB
const options = {
  maxPoolSize: 10,
  serverSelectionTimeoutMS: 5000,
  socketTimeoutMS: 45000,
}

let client: MongoClient
let clientPromise: Promise<MongoClient>

if (process.env.NODE_ENV === 'development') {
  // In development mode, use a global variable so that the value
  // is preserved across module reloads caused by HMR (Hot Module Replacement).
  const globalWithMongo = global as typeof globalThis & {
    _mongoClientPromise?: Promise<MongoClient>
  }

  if (!globalWithMongo._mongoClientPromise) {
    client = new MongoClient(uri, options)
    globalWithMongo._mongoClientPromise = client.connect()
  }
  clientPromise = globalWithMongo._mongoClientPromise
} else {
  // In production mode, it's best to not use a global variable.
  client = new MongoClient(uri, options)
  clientPromise = client.connect()
}

// Export a module-scoped MongoClient promise. By doing this in a
// separate module, the client can be shared across functions.
export default clientPromise

export async function connectToDatabase() {
  const client = await clientPromise
  const db = client.db(dbName)
  return { db, client }
}


```

## File: lib\prisma.ts
```ts
import { PrismaClient } from '@prisma/client'

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined
}

export const prisma = globalForPrisma.prisma ?? new PrismaClient()

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma 
```

## File: lib\seed.ts
```ts
import 'dotenv/config';
import { connectToDatabase } from './mongodb.js'
import bcrypt from 'bcryptjs'

const seed = async () => {
  const { db } = await connectToDatabase()

  // Clear existing users
  await db.collection('users').deleteMany({})

  // Create dummy users
  const users = [
    {
      username: 'transcriber1',
      email: 'transcriber1@email.com',
      password: await bcrypt.hash('trans123', 10),
      role: 'transcriber',
      lastLogin: null,
      lastLogout: null,
      sessionsLog: [],
      assignedProjects: []
    },
    {
      username: 'translator1',
      email: 'translator1@email.com',
      password: await bcrypt.hash('tran123', 10),
      role: 'translator',
      lastLogin: null,
      lastLogout: null,
      sessionsLog: [],
      assignedProjects: []
    },
    {
      username: 'voiceover1',
      email: 'voiceover1@email.com',
      password: await bcrypt.hash('voice123', 10),
      role: 'voiceOver',
      lastLogin: null,
      lastLogout: null,
      sessionsLog: [],
      assignedProjects: []
    },
    {
      username: 'director1',
      email: 'director1@email.com',
      password: await bcrypt.hash('dir123', 10),
      role: 'director',
      lastLogin: null,
      lastLogout: null,
      sessionsLog: [],
      assignedProjects: []
    },
    {
      username: 'admin1',
      email: 'admin1@email.com',
      password: await bcrypt.hash('admin123', 10),
      role: 'admin',
      lastLogin: null,
      lastLogout: null,
      sessionsLog: [],
      assignedProjects: []
    }
  ]

  await db.collection('users').insertMany(users)
  console.log('Database seeded!')
}

seed().catch(console.error) 
```

## File: lib\utils.ts
```ts
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

```

## File: middleware.ts
```ts
import { getToken } from 'next-auth/jwt'
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'
import type { UserRole } from '@/types/user'

// Define role-based route mappings with proper typing
const ROLE_ROUTES: Record<UserRole, string[]> = {
  admin: ['/allDashboards/admin', '/api/admin'],
  director: ['/allDashboards/director'],
  voiceOver: ['/allDashboards/voice-over'],
  transcriber: ['/allDashboards/transcriber'],
  translator: ['/allDashboards/translator']
}

// Helper function to convert role to URL path
const roleToUrlPath = (role: UserRole): string => {
  console.log('Converting role to URL path:', { 
    role,
    timestamp: new Date().toISOString()
  })
  switch (role) {
    case 'voiceOver':
      return 'voice-over'
    default:
      return role
  }
}

export async function middleware(request: NextRequest) {
  const startTime: number = Date.now()
  
  // Add protection against infinite redirects
  const redirectCount = parseInt(request.headers.get('x-redirect-count') || '0')
  if (redirectCount > 10) {
    console.error('Infinite redirect detected:', {
      pathname: request.nextUrl.pathname,
      redirectCount,
      timestamp: new Date().toISOString()
    })
    return new NextResponse('Too many redirects', { status: 508 })
  }

  console.log('Middleware processing started:', {
    pathname: request.nextUrl.pathname,
    method: request.method,
    timestamp: new Date().toISOString(),
    headers: {
      userAgent: request.headers.get('user-agent'),
      referer: request.headers.get('referer'),
      redirectCount
    }
  })

  const token = await getToken({ req: request })
  console.log('Token validation:', {
    hasToken: !!token,
    role: token?.role,
    username: token?.username,
    timestamp: new Date().toISOString(),
    tokenExpiry: token?.exp ? new Date(Number(token.exp) * 1000).toISOString() : null
  })

  const { pathname } = request.nextUrl

  // Public paths that don't require authentication
  if (pathname === '/login') {
    if (token) {
      // Redirect to role-specific dashboard if already authenticated
      const userRole = token.role as UserRole
      const roleRoute = ROLE_ROUTES[userRole]?.[0]
      if (!roleRoute) {
        console.error('Invalid role mapping:', {
          userRole,
          availableRoles: Object.keys(ROLE_ROUTES),
          timestamp: new Date().toISOString()
        })
        return new NextResponse('Invalid role configuration', { status: 500 })
      }
      
      console.log('Authenticated user accessing login page:', {
        userRole,
        roleRoute,
        timestamp: new Date().toISOString(),
        action: 'redirecting_to_dashboard'
      })
      
      const response = NextResponse.redirect(new URL(roleRoute, request.url))
      response.headers.set('x-redirect-count', (redirectCount + 1).toString())
      return response
    }
    console.log('Unauthenticated user accessing login page:', {
      timestamp: new Date().toISOString(),
      action: 'allowing_access'
    })
    return NextResponse.next()
  }

  // Protected routes
  if (!token) {
    console.log('Unauthorized access attempt:', {
      pathname,
      timestamp: new Date().toISOString(),
      action: 'redirecting_to_login'
    })
    const response = NextResponse.redirect(new URL('/login', request.url))
    response.headers.set('x-redirect-count', (redirectCount + 1).toString())
    return response
  }

  // Handle root dashboard route
  if (pathname === '/allDashboards') {
    const userRole = token.role as UserRole
    const roleRoute = ROLE_ROUTES[userRole]?.[0]
    if (!roleRoute) {
      console.error('Invalid role mapping for dashboard:', {
        userRole,
        availableRoles: Object.keys(ROLE_ROUTES),
        timestamp: new Date().toISOString()
      })
      return new NextResponse('Invalid role configuration', { status: 500 })
    }

    console.log('Dashboard route resolution:', {
      userRole,
      roleRoute,
      timestamp: new Date().toISOString(),
      action: 'redirecting_to_role_dashboard'
    })
    
    const response = NextResponse.redirect(new URL(roleRoute, request.url))
    response.headers.set('x-redirect-count', (redirectCount + 1).toString())
    return response
  }

  // Role-based access control for both dashboard and project detail pages
  const userRole = token.role as UserRole
  if (!ROLE_ROUTES[userRole]) {
    console.error('Unknown user role:', {
      userRole,
      availableRoles: Object.keys(ROLE_ROUTES),
      timestamp: new Date().toISOString()
    })
    return new NextResponse('Invalid role configuration', { status: 500 })
  }

  console.log('Role-based access check:', {
    userRole,
    pathname,
    availableRoutes: ROLE_ROUTES[userRole],
    timestamp: new Date().toISOString()
  })

  for (const [role, paths] of Object.entries(ROLE_ROUTES)) {
    const isRoleRoute = paths.some(path => {
      // Check both the dashboard route and any project detail pages under it
      const matches = pathname.startsWith(path) || pathname.match(new RegExp(`${path}/[^/]+`))
      console.log('Route permission check:', {
        role,
        path,
        pathname,
        matches,
        timestamp: new Date().toISOString()
      })
      return matches
    })

    if (isRoleRoute && role !== userRole) {
      // Redirect to user's dashboard if trying to access unauthorized role-based route
      const correctPath = ROLE_ROUTES[userRole]?.[0]
      if (!correctPath) {
        console.error('Invalid role mapping for redirect:', {
          userRole,
          availableRoles: Object.keys(ROLE_ROUTES),
          timestamp: new Date().toISOString()
        })
        return new NextResponse('Invalid role configuration', { status: 500 })
      }

      console.log('Unauthorized role access attempt:', {
        attemptedRole: role,
        userRole,
        correctPath,
        timestamp: new Date().toISOString(),
        action: 'redirecting_to_authorized_route'
      })
      
      const response = NextResponse.redirect(new URL(correctPath, request.url))
      response.headers.set('x-redirect-count', (redirectCount + 1).toString())
      return response
    }
  }

  const processingTime = Date.now() - startTime
  console.log('Middleware processing completed:', {
    userRole,
    pathname,
    processingTimeMs: processingTime,
    timestamp: new Date().toISOString(),
    action: 'access_granted'
  })
  return NextResponse.next()
}

export const config = {
  matcher: [
    '/allDashboards/:path*',
    '/api/admin/:path*',
    '/api/projects/:path*',
    '/api/dialogues/:path*',
    '/login'
  ]
} 
```

## File: next.config.mjs
```mjs
/** @type {import('next').NextConfig} */
const nextConfig = {
  webpack: (config, { isServer }) => {
    // Handle punycode deprecation
    if (!isServer) {
      config.resolve = {
        ...config.resolve,
        fallback: {
          ...config.resolve.fallback,
          punycode: false,
          querystring: false,
        },
        alias: {
          ...config.resolve.alias,
          punycode: false,
        }
      };
    }
    return config;
  },
};

export default nextConfig;

```

## File: package.json
```json
{
  "name": "qa-app",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "next dev",
    "dev:no-warnings": "node --no-warnings ./node_modules/.bin/next dev",
    "build:next": "next build",
    "build": "cross-env NODE_ENV=production npm run build:next && node scripts/build-success.js && npm run start",
    "start": "next start",
    "start:port": "next start -p",
    "lint": "next lint",
    "seed": "tsx scripts/seed.ts",
    "seed:users": "tsx scripts/seed-users.ts",
    "migrate:roles": "tsx scripts/migrate-roles.ts",
    "test": "cross-env NODE_ENV=test jest",
    "test:watch": "cross-env NODE_ENV=test jest --watch",
    "build:start": "cross-env NODE_ENV=production npm run build",
    "migrate-dialogues": "tsx scripts/migrate-dialogues.ts"
  },
  "dependencies": {
    "@aws-sdk/client-s3": "^3.723.0",
    "@aws-sdk/s3-request-presigner": "^3.723.0",
    "@prisma/client": "^6.2.1",
    "@tanstack/react-query": "^5.62.7",
    "@types/bcrypt": "^5.0.2",
    "@types/jsonwebtoken": "^9.0.7",
    "@types/mongoose": "^5.11.96",
    "@vercel/blob": "^0.27.0",
    "axios": "^1.7.9",
    "bcrypt": "^5.1.1",
    "bcryptjs": "^2.4.3",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "dotenv": "^16.4.7",
    "framer-motion": "^11.13.5",
    "ignore": "^7.0.0",
    "jsonwebtoken": "^9.0.2",
    "lucide-react": "^0.468.0",
    "mongodb": "^6.11.0",
    "mongoose": "^8.9.4",
    "next": "^14.2.23",
    "next-auth": "^4.24.11",
    "react": "^18",
    "react-dom": "^18",
    "react-swipeable": "^7.0.2",
    "tailwind-merge": "^2.5.5",
    "tailwindcss-animate": "^1.0.7"
  },
  "devDependencies": {
    "@testing-library/jest-dom": "^6.6.3",
    "@testing-library/react": "^14.3.1",
    "@testing-library/user-event": "^14.5.2",
    "@types/bcryptjs": "^2.4.6",
    "@types/jest": "^29.5.14",
    "@types/node": "^20",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "@typescript-eslint/eslint-plugin": "^8.19.1",
    "@typescript-eslint/parser": "^8.19.1",
    "@vercel/speed-insights": "^1.1.0",
    "chalk": "^5.3.0",
    "cross-env": "^7.0.3",
    "eslint": "^8",
    "eslint-config-next": "14.2.16",
    "eslint-plugin-jest": "^28.9.0",
    "eslint-plugin-testing-library": "^7.1.1",
    "jest": "^29.7.0",
    "jest-environment-jsdom": "^29.7.0",
    "mongodb-memory-server": "^9.5.0",
    "postcss": "^8",
    "prisma": "^6.2.1",
    "tailwindcss": "^3.4.1",
    "ts-jest": "^29.2.5",
    "ts-node": "^10.9.2",
    "tsx": "^4.19.2",
    "typescript": "^5"
  }
}

```

## File: postcss.config.mjs
```mjs
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
  },
};

export default config;

```

## File: prisma\schema.prisma
```prisma
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

enum UserRole {
  transcriber
  translator
  voiceOver
  director
  admin
}

enum ProjectStatus {
  pending
  in_progress
  completed
  on_hold
}

enum EpisodeStatus {
  uploaded
  processing
  error
}

model User {
  id              String      @id @default(auto()) @map("_id") @db.ObjectId
  username        String      @unique
  email           String      @unique
  password        String?
  role            UserRole
  lastLogin       DateTime?
  lastLogout      DateTime?
  sessionsLog     Json[]
  assignedProjects String[]
  isActive        Boolean     @default(true)
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
}

model Project {
  id                String        @id @default(auto()) @map("_id") @db.ObjectId
  title            String
  description      String
  sourceLanguage   String
  targetLanguage   String
  status           ProjectStatus
  assignedTo       Json[]        // Array of AssignedUser objects
  parentFolder     String
  databaseName     String
  uploadStatus     Json          // Object containing upload status
  episodes         Episode[]
  dialogues        Dialogue[]
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt
}

model Episode {
  id              String        @id @default(auto()) @map("_id") @db.ObjectId
  name            String
  collectionName  String
  videoPath       String
  videoKey        String
  status          EpisodeStatus
  uploadedAt      DateTime
  project         Project       @relation(fields: [projectId], references: [id])
  projectId       String        @db.ObjectId
}

model Dialogue {
  id              String    @id @default(auto()) @map("_id") @db.ObjectId
  index           Int
  timeStart       String
  timeEnd         String
  character       String
  videoUrl        String
  dialogue        Json      // Contains original, translated, adapted
  emotions        Json?     // Contains primary and secondary emotions
  direction       String?
  lipMovements    String?
  sceneContext    String?
  technicalNotes  String?
  culturalNotes   String?
  status          String
  voiceOverUrl    String?
  voiceOverNotes  String?
  directorNotes   String?
  recordingStatus String?
  words           Json?     // Array of WordDetail objects
  scenario        Json?     // Scenario object
  updatedAt       DateTime  @updatedAt
  updatedBy       String?
  project         Project   @relation(fields: [projectId], references: [id])
  projectId       String    @db.ObjectId
}

```

## File: scripts\build-success.js
```js
import chalk from 'chalk';

// Function to create a visual separator
const separator = () => {
  console.log(chalk.gray('â•'.repeat(80)));
};

// Function to display success message
const displayBuildSuccess = () => {
  separator();
  console.log(chalk.green.bold('ğŸ‰ Build Completed Successfully! ğŸ‰'));
  console.log(chalk.green('âœ“ All tests passed'));
  console.log(chalk.green('âœ“ Next.js build completed'));
  console.log(chalk.green('âœ“ Application is ready for deployment'));
  separator();
};

// Function to display build summary
const displayBuildSummary = () => {
  console.log(chalk.cyan('\nBuild Summary:'));
  console.log(chalk.white('â€¢ Environment: Production'));
  console.log(chalk.white('â€¢ Test Coverage: Passed'));
  console.log(chalk.white('â€¢ Build Size: Optimized'));
  console.log(chalk.white('â€¢ Static Pages: Generated'));
  console.log(chalk.white('â€¢ API Routes: Configured\n'));
};

// Main execution
const main = async () => {
  try {
    displayBuildSuccess();
    displayBuildSummary();
  } catch (error) {
    console.error(chalk.red('Error during build process:', error));
    process.exit(1);
  }
};

main(); 
```

## File: scripts\dialougeSample.json
```json
{
    "_id": {
        "$oid": "6757fdbf79542727d6b72e28"
    },
    "index": {
        "$numberInt": "34"
    },
    "timeStart": "00:01:31:480",
    "timeEnd": "00:01:36:160",
    "character": "Character Name",
    "videoUrl": "https://pub-ca2dd6ef0390446c8dda16e228d97cf6.r2.dev/Kuma%20Ep%2001/videos/Kuma%20Ep%2001_Clip_34.mp4",
    "dialogue": {
        "original": "Annemize saygÄ±lÄ± davranÄ±r, babamÄ±za da bir evlat olarak gÃ¶revimizi yaparÄ±z.",
        "translated": "I respect our mother, and do our duty to our father as his sons.",
        "adapted": "à¤®à¥ˆà¤‚ à¤…à¤ªà¤¨à¥€ à¤®à¤¾à¤‚ à¤•à¤¾ à¤¸à¤®à¥à¤®à¤¾à¤¨ à¤•à¤°à¤¤à¤¾ à¤¹à¥‚à¤‚ à¤”à¤° à¤…à¤ªà¤¨à¥‡ à¤ªà¤¿à¤¤à¤¾ à¤•à¥‡ à¤ªà¥à¤°à¤¤à¤¿ à¤‰à¤¨à¤•à¥‡ à¤ªà¥à¤¤à¥à¤° à¤¹à¥‹à¤¨à¥‡ à¤•à¥‡ à¤¨à¤¾à¤¤à¥‡ à¤…à¤ªà¤¨à¤¾ à¤•à¤°à¥à¤¤à¤µà¥à¤¯ à¤¨à¤¿à¤­à¤¾à¤¤à¤¾ à¤¹à¥‚à¤‚à¥¤"
    },
    "emotions": {
        "primary": {
            "emotion": "Neutral",
            "intensity": {
                "$numberInt": "1"
            }
        },
        "secondary": {
            "emotion": "Neutral",
            "intensity": {
                "$numberInt": "1"
            }
        }
    },
    "direction": "Normal tone",
    "lipMovements": "0",
    "sceneContext": "Character speaking",
    "technicalNotes": "Neutral tone",
    "culturalNotes": "General conversation",
    "status": "recorded",
    "recordingStatus": "pending",
    "projectId": {
        "$oid": "123456789123456789123456"
    },
    "words": [
        {
            "characterName": "Character Name",
            "wordSequenceNumber": {
                "$numberInt": "1"
            },
            "word": "Annemize",
            "wordTimestamp": "00:01:31:480",
            "dialogNumber": {},
            "dialogStartTimestamp": "00:01:31:480",
            "dialogEndTimestamp": "00:01:36:160",
            "dialogVocalFile": "",
            "characterProfile": {
                "age": "",
                "occupation": "",
                "accents": [],
                "otherNotes": ""
            },
            "numberOfLipMovementsForThisWord": {
                "$numberInt": "4"
            }
        },
        {
            "characterName": "Character Name",
            "wordSequenceNumber": {
                "$numberInt": "2"
            },
            "word": "saygÄ±lÄ±",
            "wordTimestamp": "00:01:31:948",
            "dialogNumber": {},
            "dialogStartTimestamp": "00:01:31:480",
            "dialogEndTimestamp": "00:01:36:160",
            "dialogVocalFile": "",
            "characterProfile": {
                "age": "",
                "occupation": "",
                "accents": [],
                "otherNotes": ""
            },
            "numberOfLipMovementsForThisWord": {
                "$numberInt": "1"
            }
        },
        {
            "characterName": "Character Name",
            "wordSequenceNumber": {
                "$numberInt": "3"
            },
            "word": "davranÄ±r",
            "wordTimestamp": "00:01:32:416",
            "dialogNumber": {},
            "dialogStartTimestamp": "00:01:31:480",
            "dialogEndTimestamp": "00:01:36:160",
            "dialogVocalFile": "",
            "characterProfile": {
                "age": "",
                "occupation": "",
                "accents": [],
                "otherNotes": ""
            },
            "numberOfLipMovementsForThisWord": {
                "$numberInt": "2"
            }
        },
        {
            "characterName": "Character Name",
            "wordSequenceNumber": {
                "$numberInt": "4"
            },
            "word": "babamÄ±za",
            "wordTimestamp": "00:01:32:884",
            "dialogNumber": {},
            "dialogStartTimestamp": "00:01:31:480",
            "dialogEndTimestamp": "00:01:36:160",
            "dialogVocalFile": "",
            "characterProfile": {
                "age": "",
                "occupation": "",
                "accents": [],
                "otherNotes": ""
            },
            "numberOfLipMovementsForThisWord": {
                "$numberInt": "3"
            }
        },
        {
            "characterName": "Character Name",
            "wordSequenceNumber": {
                "$numberInt": "5"
            },
            "word": "da",
            "wordTimestamp": "00:01:33:352",
            "dialogNumber": {},
            "dialogStartTimestamp": "00:01:31:480",
            "dialogEndTimestamp": "00:01:36:160",
            "dialogVocalFile": "",
            "characterProfile": {
                "age": "",
                "occupation": "",
                "accents": [],
                "otherNotes": ""
            },
            "numberOfLipMovementsForThisWord": {
                "$numberInt": "1"
            }
        },
        {
            "characterName": "Character Name",
            "wordSequenceNumber": {
                "$numberInt": "6"
            },
            "word": "bir",
            "wordTimestamp": "00:01:33:820",
            "dialogNumber": {},
            "dialogStartTimestamp": "00:01:31:480",
            "dialogEndTimestamp": "00:01:36:160",
            "dialogVocalFile": "",
            "characterProfile": {
                "age": "",
                "occupation": "",
                "accents": [],
                "otherNotes": ""
            },
            "numberOfLipMovementsForThisWord": {
                "$numberInt": "1"
            }
        },
        {
            "characterName": "Character Name",
            "wordSequenceNumber": {
                "$numberInt": "7"
            },
            "word": "evlat",
            "wordTimestamp": "00:01:34:288",
            "dialogNumber": {},
            "dialogStartTimestamp": "00:01:31:480",
            "dialogEndTimestamp": "00:01:36:160",
            "dialogVocalFile": "",
            "characterProfile": {
                "age": "",
                "occupation": "",
                "accents": [],
                "otherNotes": ""
            },
            "numberOfLipMovementsForThisWord": {
                "$numberInt": "2"
            }
        },
        {
            "characterName": "Character Name",
            "wordSequenceNumber": {
                "$numberInt": "8"
            },
            "word": "olarak",
            "wordTimestamp": "00:01:34:756",
            "dialogNumber": {},
            "dialogStartTimestamp": "00:01:31:480",
            "dialogEndTimestamp": "00:01:36:160",
            "dialogVocalFile": "",
            "characterProfile": {
                "age": "",
                "occupation": "",
                "accents": [],
                "otherNotes": ""
            },
            "numberOfLipMovementsForThisWord": {
                "$numberInt": "3"
            }
        },
        {
            "characterName": "Character Name",
            "wordSequenceNumber": {
                "$numberInt": "9"
            },
            "word": "gÃ¶revimizi",
            "wordTimestamp": "00:01:35:224",
            "dialogNumber": {},
            "dialogStartTimestamp": "00:01:31:480",
            "dialogEndTimestamp": "00:01:36:160",
            "dialogVocalFile": "",
            "characterProfile": {
                "age": "",
                "occupation": "",
                "accents": [],
                "otherNotes": ""
            },
            "numberOfLipMovementsForThisWord": {
                "$numberInt": "4"
            }
        },
        {
            "characterName": "Character Name",
            "wordSequenceNumber": {
                "$numberInt": "10"
            },
            "word": "yaparÄ±z",
            "wordTimestamp": "00:01:35:692",
            "dialogNumber": {},
            "dialogStartTimestamp": "00:01:31:480",
            "dialogEndTimestamp": "00:01:36:160",
            "dialogVocalFile": "",
            "characterProfile": {
                "age": "",
                "occupation": "",
                "accents": [],
                "otherNotes": ""
            },
            "numberOfLipMovementsForThisWord": {
                "$numberInt": "2"
            }
        }
    ],
    "scenario": {
        "name": "",
        "description": "",
        "location": "",
        "timeOfDay": "",
        "otherScenarioNotes": ""
    },
    "voiceOverNotes": "",
    "directorNotes": "",
    "updatedAt": "2025-01-13T11:23:40.646Z",
    "updatedBy": "",
    "deleteVoiceOver": false
}
```

## File: scripts\migrate-dialogues.ts
```ts
import mongoose from 'mongoose';
import { config } from 'dotenv';
import { fileURLToPath } from 'url';
import { dirname } from 'path';
import path from 'path';
import { WordDetail, CharacterProfile } from '../types/dialogue';
import { Collection } from 'mongodb';

// Setup __dirname equivalent for ES modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Load environment variables from the root .env file
const envPath = path.resolve(__dirname, '../.env');
console.log('Loading .env from:', envPath);
config({ path: envPath });

// Debug: Check if env vars are loaded
console.log('MONGODB_URI exists:', !!process.env.MONGODB_URI);

const MONGODB_URI = process.env.MONGODB_URI || "mongodb+srv://vivekkumarsingh:dGeuK817ItxjmUb4@cluster0.vir7o.mongodb.net/?retryWrites=true&w=majority&appName=Cluster0";

async function generateAndUpdateWords(dialoguesCollection: Collection) {
  console.log('\nStarting word generation preview...');
  
  // Get a sample document with non-empty dialogue
  const sampleDoc = await dialoguesCollection.findOne({
    'dialogue.original': { $exists: true, $ne: '' }
  });

  if (!sampleDoc) {
    // If no document with non-empty dialogue found, try to find any document
    const anyDoc = await dialoguesCollection.findOne({});
    console.log('No documents found with non-empty dialogue. Sample document:', 
      JSON.stringify(anyDoc?.dialogue || {}, null, 2));
    return;
  }

  // Update index normalization
  const normalizedIndex = await normalizeIndex(sampleDoc);
  if (normalizedIndex === null) {
    console.log('Warning: Could not normalize index for sample document');
  }

  // Generate sample words for preview
  const originalText = sampleDoc.dialogue?.original || '';
  if (!originalText.trim()) {
    console.log('Sample document has empty dialogue text');
    return;
  }

  const wordList = originalText
    .trim()
    .split(/\s+/)
    .filter((word: string) => word.length > 0);

  const sampleWordObjects: WordDetail[] = wordList.map((word: string, index: number) => ({
    characterName: sampleDoc.character,
    wordSequenceNumber: index + 1,
    word: word,
    wordTimestamp: sampleDoc.timeStart,
    dialogNumber: sampleDoc.index,
    dialogStartTimestamp: sampleDoc.timeStart,
    dialogEndTimestamp: sampleDoc.timeEnd,
    dialogVocalFile: sampleDoc.voiceOverUrl || '',
    characterProfile: {
      age: '',
      occupation: '',
      accents: [],
      otherNotes: ''
    } as CharacterProfile,
    numberOfLipMovementsForThisWord: 0
  }));

  console.log('\nSample document:');
  console.log('Original text:', originalText);
  console.log('\nGenerated words array (first 3 items):', JSON.stringify(sampleWordObjects.slice(0, 3), null, 2));

  // Ask for confirmation
  console.log('\nWould you like to proceed with updating all documents? (y/n)');
  const response = await new Promise(resolve => {
    process.stdin.once('data', data => {
      resolve(data.toString().trim().toLowerCase());
    });
  });

  if (response !== 'y') {
    console.log('Operation cancelled by user');
    return;
  }

  // Proceed with full update
  const allDocs = await dialoguesCollection.find({
    'dialogue.original': { $exists: true, $ne: '' }
  }).toArray();
  
  console.log(`\nProceeding to update ${allDocs.length} documents...`);
  let updatedCount = 0;

  for (const doc of allDocs) {
    if (doc.words && doc.words.length > 0) {
      console.log(`Skipping document ${doc._id} - already has words`);
      continue;
    }

    const wordObjects = generateWordsForDoc(doc);
    await dialoguesCollection.updateOne(
      { _id: doc._id },
      { $set: { words: wordObjects } }
    );
    updatedCount++;
    
    if (updatedCount % 10 === 0) {
      console.log(`Progress: ${updatedCount}/${allDocs.length} documents updated`);
    }
  }

  console.log(`\nWord generation completed. Updated ${updatedCount} documents`);
}

function generateWordsForDoc(doc: any): WordDetail[] {
  const originalText = doc.dialogue?.original || '';
  if (!originalText.trim()) {
    console.log(`Document ${doc._id} has empty dialogue text`);
    return [];
  }

  // Enhanced text cleaning
  const cleanText = originalText
    .trim()  // Remove leading/trailing whitespace and newlines
    .replace(/\.{3,}/g, ' ')  // Replace ellipsis with space
    .replace(/[.,!?à¥¤à¥¥â€¦\n\r]+/g, ' ')  // Replace punctuation and newlines with space
    .replace(/\s+/g, ' ')  // Replace multiple spaces with single space
    .trim();  // Final trim

  // Split into words and filter
  const wordList = cleanText
    .split(' ')
    .filter((word: string) => {
      const cleaned = word.trim();
      return cleaned.length > 0 && 
             !/^[.,!?à¥¤à¥¥â€¦]+$/.test(cleaned) &&  // Not just punctuation
             !/^\d+$/.test(cleaned);           // Not just numbers
    });

  if (wordList.length === 0) {
    console.log(`Document ${doc._id} has no valid words after cleaning`);
    return [];
  }

  // Calculate time distribution
  const startTime = doc.timeStart || '';
  const endTime = doc.timeEnd || '';
  const timePerWord = calculateTimePerWord(startTime, endTime, wordList.length);

  // Preview for debugging
  if (process.env.DEBUG) {
    console.log(`\nDocument ${doc._id} text processing:
    Original: "${originalText}"
    Cleaned: "${cleanText}"
    Words: ${JSON.stringify(wordList)}
    Time per word: ${timePerWord}ms`);
  }

  return wordList.map((word: string, index: number) => {
    const cleanWord = word.trim();
    const lipMovements = calculateLipMovements(cleanWord);
    const wordTimestamp = calculateWordTimestamp(startTime, timePerWord, index);

    return {
      characterName: doc.character || '',
      wordSequenceNumber: index + 1,
      word: cleanWord,
      wordTimestamp,
      dialogNumber: normalizeIndex(doc),
      dialogStartTimestamp: startTime,
      dialogEndTimestamp: endTime,
      dialogVocalFile: doc.voiceOverUrl || '',
      characterProfile: {
        age: doc.characterProfile?.age || '',
        occupation: doc.characterProfile?.occupation || '',
        accents: doc.characterProfile?.accents || [],
        otherNotes: doc.characterProfile?.otherNotes || ''
      } as CharacterProfile,
      numberOfLipMovementsForThisWord: lipMovements
    };
  });
}

// Helper function to calculate time per word
function calculateTimePerWord(startTime: string, endTime: string, wordCount: number): number {
  try {
    const [startHours, startMinutes, startSeconds, startMillis] = startTime.split(':').map(Number);
    const [endHours, endMinutes, endSeconds, endMillis] = endTime.split(':').map(Number);
    
    const startTotalMillis = (startHours * 3600000) + (startMinutes * 60000) + (startSeconds * 1000) + startMillis;
    const endTotalMillis = (endHours * 3600000) + (endMinutes * 60000) + (endSeconds * 1000) + endMillis;
    
    return Math.floor((endTotalMillis - startTotalMillis) / wordCount);
  } catch (error) {
    console.warn('Error calculating time per word, using default spacing');
    return 500; // Default 500ms per word
  }
}

// Helper function to calculate word timestamp
function calculateWordTimestamp(startTime: string, timePerWord: number, wordIndex: number): string {
  try {
    const [hours, minutes, seconds, millis] = startTime.split(':').map(Number);
    const startTotalMillis = (hours * 3600000) + (minutes * 60000) + (seconds * 1000) + millis;
    const wordTimeMillis = startTotalMillis + (timePerWord * wordIndex);
    
    const newHours = Math.floor(wordTimeMillis / 3600000);
    const newMinutes = Math.floor((wordTimeMillis % 3600000) / 60000);
    const newSeconds = Math.floor((wordTimeMillis % 60000) / 1000);
    const newMillis = wordTimeMillis % 1000;
    
    return `${newHours.toString().padStart(2, '0')}:${newMinutes.toString().padStart(2, '0')}:${newSeconds.toString().padStart(2, '0')}:${newMillis.toString().padStart(3, '0')}`;
  } catch (error) {
    console.warn('Error calculating word timestamp, using start time');
    return startTime;
  }
}

// Enhanced lip movement calculation
function calculateLipMovements(word: string): number {
  // Handle Devanagari text
  if (/[\u0900-\u097F]/.test(word)) {
    return calculateDevanagariLipMovements(word);
  }
  
  // Handle English/Latin text
  return calculateEnglishLipMovements(word);
}

function calculateDevanagariLipMovements(word: string): number {
  // Count matras (vowel marks) and explicit vowels
  const matraCount = (word.match(/[\u093E-\u094D\u0955-\u0963]/g) || []).length;
  const vowelCount = (word.match(/[\u0904-\u0914]/g) || []).length;
  const halfLetterCount = (word.match(/à¥[à¤•à¤–à¤—à¤˜à¤™à¤šà¤›à¤œà¤à¤à¤Ÿà¤ à¤¡à¤¢à¤£à¤¤à¤¥à¤¦à¤§à¤¨à¤ªà¤«à¤¬à¤­à¤®à¤¯à¤°à¤²à¤µà¤¶à¤·à¤¸à¤¹]/g) || []).length;
  
  // Basic syllable count: matras + explicit vowels + half letters
  const syllables = matraCount + vowelCount + halfLetterCount;
  return Math.max(1, syllables);
}

function calculateEnglishLipMovements(word: string): number {
  const syllableRegex = /[^aeiouy]*[aeiouy]+(?:[^aeiouy]*$|[^aeiouy](?=[^aeiouy]))?/gi;
  const matches = word.match(syllableRegex);
  return matches ? matches.length : 1;
}

// Add debug preview function
async function previewWordGeneration(doc: Record<string, any>): Promise<WordDetail[]> {
  console.log('\nSample document:');
  console.log('Original text:', JSON.stringify(doc.dialogue?.original));
  
  const words = generateWordsForDoc(doc);
  console.log('\nGenerated words:', JSON.stringify(words, null, 2));
  
  // Additional debug info
  if (words.length > 0) {
    console.log('\nWord timing distribution:');
    words.forEach(w => {
      console.log(`"${w.word}": ${w.wordTimestamp} (${w.numberOfLipMovementsForThisWord} lip movements)`);
    });
  }
  
  return words;
}

async function normalizeIndex(doc: any): Promise<number> {
  if (!doc.index) return 0;
  
  try {
    if (typeof doc.index === 'object') {
      if (doc.index.$numberInt) {
        return parseInt(doc.index.$numberInt, 10);
      }
      return 0;
    }
    
    if (typeof doc.index === 'string') {
      // Handle string indices like "04"
      return parseInt(doc.index, 10);
    }
    
    if (typeof doc.index === 'number') {
      return doc.index;
    }
    
    return 0;
  } catch (error) {
    console.error(`Error normalizing index for document ${doc._id}:`, error);
    return 0;
  }
}

async function verifyDocument(doc: any) {
  const issues: string[] = [];
  
  // Check index specifically
  const normalizedIndex = await normalizeIndex(doc);
  if (normalizedIndex === 0 && doc.index !== 0) {
    issues.push(`Invalid index: ${JSON.stringify(doc.index)}`);
  }
  
  // Check required fields
  if (!doc.index || typeof doc.index !== 'number') issues.push('Invalid index');
  if (!doc.timeStart || typeof doc.timeStart !== 'string') issues.push('Invalid timeStart');
  if (!doc.timeEnd || typeof doc.timeEnd !== 'string') issues.push('Invalid timeEnd');
  if (!doc.character || typeof doc.character !== 'string') issues.push('Invalid character');
  if (typeof doc.videoUrl !== 'string') issues.push('Invalid videoUrl');
  if (!doc.status || typeof doc.status !== 'string') issues.push('Invalid status');
  
  // Check dialogue structure
  if (!doc.dialogue || 
      typeof doc.dialogue.original !== 'string' ||
      typeof doc.dialogue.translated !== 'string' ||
      typeof doc.dialogue.adapted !== 'string') {
    issues.push('Invalid dialogue structure');
  }
  
  // Check emotions structure
  if (!doc.emotions?.primary ||
      typeof doc.emotions.primary.emotion !== 'string' ||
      typeof doc.emotions.primary.intensity !== 'number' ||
      doc.emotions.primary.intensity < 0 ||
      doc.emotions.primary.intensity > 100) {
    issues.push('Invalid emotions structure');
  }
  
  // Check words array if it exists
  if (doc.words) {
    if (!Array.isArray(doc.words)) {
      issues.push('Invalid words array');
    } else {
      const invalidWords = doc.words.some((word: any) => 
        !word.word || 
        typeof word.word !== 'string' ||
        !word.wordSequenceNumber ||
        typeof word.wordSequenceNumber !== 'number'
      );
      if (invalidWords) issues.push('Invalid word objects in words array');
    }
  }
  
  // Check scenario object
  if (!doc.scenario || 
      typeof doc.scenario !== 'object' ||
      typeof doc.scenario.name !== 'string' ||
      typeof doc.scenario.description !== 'string' ||
      typeof doc.scenario.location !== 'string' ||
      typeof doc.scenario.timeOfDay !== 'string') {
    issues.push('Invalid scenario object');
  }
  
  return issues.length ? issues : 'No issues found';
}

async function migrationScript() {
  let connection: typeof mongoose | null = null;
  try {
    // Connect to MongoDB
    if (!MONGODB_URI) {
      throw new Error('MONGODB_URI is not defined in environment variables');
    }
    
    console.log('Attempting to connect to MongoDB...');
    connection = await mongoose.connect(MONGODB_URI);
    console.log('Connected to MongoDB successfully');

    const db = mongoose.connection.db;
    if (!db) {
      throw new Error('Failed to get database instance');
    }
    console.log('Got database instance');
    console.log('Database name:', db.databaseName);

    const dialoguesCollection = db.collection('demo_S1_E1');
    console.log('Accessing dialogues collection...');
    
    // Check if collection exists and has documents
    const count = await dialoguesCollection.countDocuments();
    console.log('Total documents in collection:', count);

    // Add this: Check structure of first document
    const sampleDoc = await dialoguesCollection.findOne({});
    console.log('Sample document structure:', JSON.stringify(sampleDoc, null, 2));

    // After getting sample document, add this check
    console.log('\nChecking index patterns...');
    const indexPatterns = await dialoguesCollection.distinct('index');
    console.log('Unique indices:', indexPatterns.sort((a, b) => a - b));

    // Also check index distribution
    const indexCounts = await dialoguesCollection.aggregate([
      { $group: { _id: "$index", count: { $sum: 1 } } },
      { $sort: { _id: 1 } }
    ]).toArray();
    
    console.log('\nIndex distribution:');
    console.log(JSON.stringify(indexCounts, null, 2));

    // After index distribution check and before main update
    console.log('\nStarting word generation...');
    await generateAndUpdateWords(dialoguesCollection);

    // Then continue with the main update
    console.log('Starting update operation...');
    const result = await dialoguesCollection.updateMany(
      {},  // Match all documents
      [    // Use aggregation pipeline for complex transformations
        {
          $set: {
            // Normalize index first
            index: {
              $convert: {
                input: {
                  $cond: {
                    if: { $eq: [{ $type: "$index" }, "object"] },
                    then: { $toInt: "$index.numberInt" },
                    else: {
                      $cond: {
                        if: { $eq: [{ $type: "$index" }, "string"] },
                        then: { $toInt: "$index" },
                        else: { $ifNull: ["$index", 0] }
                      }
                    }
                  }
                },
                to: "int",
                onError: 0,
                onNull: 0
              }
            },
            // Convert lipMovements to string using $toInt and $toString
            lipMovements: {
              $let: {
                vars: {
                  numValue: {
                    $cond: {
                      if: { $eq: [{ $type: "$lipMovements" }, "object"] },
                      then: { $toInt: "$lipMovements.numberInt" },
                      else: { $toInt: { $ifNull: ["$lipMovements", "0"] } }
                    }
                  }
                },
                in: { $toString: "$$numValue" }
              }
            },

            // Ensure required fields exist with default values if missing
            timeStart: { $ifNull: ["$timeStart", ""] },
            timeEnd: { $ifNull: ["$timeEnd", ""] },
            character: { $ifNull: ["$character", ""] },
            videoUrl: { $ifNull: ["$videoUrl", ""] },
            status: { $ifNull: ["$status", "pending"] },

            // Ensure dialogue structure
            dialogue: {
              $ifNull: ["$dialogue", {
                original: "",
                translated: "",
                adapted: ""
              }]
            },

            // Fix emotions structure and types
            emotions: {
              $ifNull: ["$emotions", {
                primary: {
                  emotion: "",
                  intensity: 0
                }
              }]
            },

            // Add missing arrays/objects if not present
            words: { $ifNull: ["$words", []] },  // Just set empty array if missing
            scenario: { 
              $ifNull: ["$scenario", {
                name: "",
                description: "",
                location: "",
                timeOfDay: "",
                otherScenarioNotes: ""
              }]
            },

            // Optional fields with proper types
            direction: { $ifNull: ["$direction", ""] },
            sceneContext: { $ifNull: ["$sceneContext", ""] },
            technicalNotes: { $ifNull: ["$technicalNotes", ""] },
            culturalNotes: { $ifNull: ["$culturalNotes", ""] },
            voiceOverNotes: { $ifNull: ["$voiceOverNotes", ""] },
            directorNotes: { $ifNull: ["$directorNotes", ""] },
            recordingStatus: { $ifNull: ["$recordingStatus", ""] },
            projectId: { $ifNull: ["$projectId", ""] },
            updatedAt: { $ifNull: ["$updatedAt", new Date().toISOString()] },
            updatedBy: { $ifNull: ["$updatedBy", ""] },

            // Handle voiceOverUrl and deleteVoiceOver
            voiceOverUrl: { $ifNull: ["$voiceOverUrl", "$audioUrl"] },
            deleteVoiceOver: { $ifNull: ["$deleteVoiceOver", false] }
          }
        },
        {
          $unset: ["audioUrl"]  // Remove redundant audioUrl field
        }
      ]
    );

    console.log(`Migration completed. Modified ${result.modifiedCount} documents`);

    console.log('Verifying updated documents...');
    
    // Sample verification of a few documents
    const verifiedDocs = await dialoguesCollection.find({}).limit(10).toArray();
    const verificationResults = await Promise.all(verifiedDocs.map(async doc => ({
      _id: doc._id,
      index: doc.index,
      issues: await verifyDocument(doc)
    })));
    
    console.log('\nVerification Results:');
    console.log(JSON.stringify(verificationResults, null, 2));
    
    // Count documents with specific fields to verify
    const stats = {
      total: await dialoguesCollection.countDocuments(),
      withWords: await dialoguesCollection.countDocuments({ words: { $exists: true } }),
      withScenario: await dialoguesCollection.countDocuments({ scenario: { $exists: true } }),
      withEmotions: await dialoguesCollection.countDocuments({ emotions: { $exists: true } }),
      withLipMovements: await dialoguesCollection.countDocuments({ lipMovements: { $exists: true } })
    };
    
    console.log('\nCollection Statistics:');
    console.log(JSON.stringify(stats, null, 2));

  } catch (error) {
    console.error('Migration failed:', error instanceof Error ? error.message : error);
    if (error instanceof Error && error.stack) {
      console.error('Stack trace:', error.stack);
    }
    process.exit(1);
  } finally {
    if (connection) {
      try {
        await connection.disconnect();
        console.log('Disconnected from MongoDB');
      } catch (error) {
        console.error('Error during disconnect:', error);
      }
    }
  }
}

// Add process error handlers
process.on('unhandledRejection', (reason, promise) => {
  console.error('Unhandled Rejection at:', promise, 'reason:', reason);
  process.exit(1);
});

process.on('uncaughtException', (error) => {
  console.error('Uncaught Exception:', error);
  process.exit(1);
});

// Run the migration
migrationScript(); 
```

## File: scripts\migrate-roles.ts
```ts
import { MongoClient } from 'mongodb'
import * as dotenv from 'dotenv'
import { resolve } from 'path'

// Load environment variables from .env.local if it exists, otherwise from .env
dotenv.config({ path: resolve(process.cwd(), '.env.local') })
dotenv.config({ path: resolve(process.cwd(), '.env') })

const MONGODB_URI = process.env.MONGODB_URI
const MONGODB_DB = process.env.MONGODB_DB

if (!MONGODB_URI) {
  throw new Error('Please define the MONGODB_URI environment variable')
}

if (!MONGODB_DB) {
  throw new Error('Please define the MONGODB_DB environment variable')
}

async function migrateRoles() {
  console.log('Starting role migration...')
  console.log('Using database:', MONGODB_DB)
  
  const client = new MongoClient(MONGODB_URI as string)

  try {
    await client.connect()
    console.log('Connected to MongoDB Atlas')
    
    const db = client.db(MONGODB_DB)

    // Update project assignments
    const result = await db.collection('projects').updateMany(
      { 'assignedTo.role': 'voiceOver' },
      { $set: { 'assignedTo.$[elem].role': 'voiceOver' } },
      { arrayFilters: [{ 'elem.role': 'voiceOver' }] }
    )

    console.log(`Updated ${result.modifiedCount} project assignments`)

  } catch (error) {
    console.error('Error migrating roles:', error)
    throw error
  } finally {
    await client.close()
    console.log('Database connection closed')
  }
}

// Run the migration function
migrateRoles()
  .then(() => {
    console.log('Migration completed successfully')
    process.exit(0)
  })
  .catch((error) => {
    console.error('Migration failed:', error)
    process.exit(1)
  }) 
```

## File: scripts\seed-users.ts
```ts
import { MongoClient } from 'mongodb'
import bcrypt from 'bcryptjs'
import * as dotenv from 'dotenv'
import { resolve } from 'path'

// Load environment variables from .env.local if it exists, otherwise from .env
dotenv.config({ path: resolve(process.cwd(), '.env.local') })
dotenv.config({ path: resolve(process.cwd(), '.env') })

const MONGODB_URI = process.env.MONGODB_URI
const MONGODB_DB = process.env.MONGODB_DB

if (!MONGODB_URI) {
  throw new Error('Please define the MONGODB_URI environment variable')
}

if (!MONGODB_DB) {
  throw new Error('Please define the MONGODB_DB environment variable')
}

async function seedUsers() {
  console.log('Starting user seeding...')
  console.log('Using database:', MONGODB_DB)
  
  const client = new MongoClient(MONGODB_URI as string)

  try {
    await client.connect()
    console.log('Connected to MongoDB Atlas')
    
    const db = client.db(MONGODB_DB)

    // Drop existing users collection if it exists
    try {
      await db.collection('users').drop()
      console.log('Dropped existing users collection')
    } catch (error) {
      console.log('No existing users collection to drop')
    }

    // Create users collection
    const users = [
      {
        username: 'transcriber1',
        email: 'transcriber1@email.com',
        password: await bcrypt.hash('trans123', 10),
        role: 'transcriber',
        lastLogin: null,
        lastLogout: null,
        sessionsLog: [],
        assignedProjects: [],
        createdAt: new Date(),
        updatedAt: new Date()
      },
      {
        username: 'translator1',
        email: 'translator1@email.com',
        password: await bcrypt.hash('tran123', 10),
        role: 'translator',
        lastLogin: null,
        lastLogout: null,
        sessionsLog: [],
        assignedProjects: [],
        createdAt: new Date(),
        updatedAt: new Date()
      },
      {
        username: 'voiceover1',
        email: 'voiceover1@email.com',
        password: await bcrypt.hash('voice123', 10),
        role: 'voiceOver',
        lastLogin: null,
        lastLogout: null,
        sessionsLog: [],
        assignedProjects: [],
        createdAt: new Date(),
        updatedAt: new Date()
      },
      {
        username: 'director1',
        email: 'director1@email.com',
        password: await bcrypt.hash('dir123', 10),
        role: 'director',
        lastLogin: null,
        lastLogout: null,
        sessionsLog: [],
        assignedProjects: [],
        createdAt: new Date(),
        updatedAt: new Date()
      },
      {
        username: 'admin1',
        email: 'admin1@email.com',
        password: await bcrypt.hash('admin123', 10),
        role: 'admin',
        lastLogin: null,
        lastLogout: null,
        sessionsLog: [],
        assignedProjects: [],
        createdAt: new Date(),
        updatedAt: new Date()
      }
    ]

    console.log('Creating users...')
    const result = await db.collection('users').insertMany(users)
    console.log(`Successfully inserted ${result.insertedCount} users`)

    // Create indexes
    console.log('Creating indexes...')
    await db.collection('users').createIndex({ email: 1 }, { unique: true })
    await db.collection('users').createIndex({ username: 1 }, { unique: true })
    console.log('Created indexes on email and username')

  } catch (error) {
    console.error('Error seeding users:', error)
    throw error
  } finally {
    await client.close()
    console.log('Database connection closed')
  }
}

// Run the seed function
seedUsers()
  .then(() => {
    console.log('Seeding completed successfully')
    process.exit(0)
  })
  .catch((error) => {
    console.error('Seeding failed:', error)
    process.exit(1)
  }) 
```

## File: scripts\seed.ts
```ts
import { MongoClient, ObjectId } from 'mongodb'
import { config } from 'dotenv'
import { fileURLToPath } from 'url'
import { dirname } from 'path'

const __filename = fileURLToPath(import.meta.url)
const __dirname = dirname(__filename)

config()

async function seed() {
  console.log('Starting database seeding...')
  const uri = process.env.MONGODB_URI || 'mongodb://localhost:27017/qa-app'
  const client = new MongoClient(uri)

  try {
    await client.connect()
    console.log('Connected to MongoDB')
    
    const db = client.db()

    // Update dialogues without valid projectId
    console.log('Updating dialogues without valid projectId...')
    const result = await db.collection('dialogues').updateMany(
      { 
        $or: [
          { projectId: null },
          { projectId: "null" },
          { projectId: { $exists: false } }
        ]
      },
      {
        $set: {
          projectId: new ObjectId("123456789123456789123456")
        }
      }
    )

    console.log(`Updated ${result.modifiedCount} dialogues with default projectId`)

  } catch (error) {
    console.error('Error during seeding:', error)
  } finally {
    await client.close()
    console.log('Database connection closed')
  }
}

seed().catch(console.error) 
```

## File: scripts\start-app.js
```js
import { exec } from 'child_process';
import chalk from 'chalk';
import { promisify } from 'util';
import net from 'net';

const execAsync = promisify(exec);

// Function to check if port is in use
const isPortInUse = async (port) => {
  return new Promise((resolve) => {
    const server = net.createServer()
      .once('error', () => resolve(true))
      .once('listening', () => {
        server.close();
        resolve(false);
      })
      .listen(port);
  });
};

// Function to find next available port
const findAvailablePort = async (startPort) => {
  let port = startPort;
  while (await isPortInUse(port)) {
    port++;
    if (port > startPort + 100) return null; // Limit search to 100 ports
  }
  return port;
};

// Function to get process info using port
const getProcessInfo = async (port) => {
  try {
    if (process.platform === 'win32') {
      const { stdout } = await execAsync(`netstat -ano | findstr :${port}`);
      const lines = stdout.split('\n').filter(line => line.includes(`:${port}`));
      if (lines.length > 0) {
        const processId = lines[0].split(' ').filter(Boolean).pop();
        if (processId) {
          const { stdout: processInfo } = await execAsync(`tasklist /FI "PID eq ${processId}"`);
          return { pid: processId, info: processInfo };
        }
      }
    }
    return null;
  } catch (error) {
    return null;
  }
};

// Function to kill process on port
const killProcess = async (port) => {
  try {
    if (process.platform === 'win32') {
      const processInfo = await getProcessInfo(port);
      if (processInfo) {
        console.log(chalk.yellow(`\nProcess using port ${port}:`));
        console.log(chalk.gray(processInfo.info));
        await execAsync(`taskkill /F /PID ${processInfo.pid}`);
        return true;
      }
    } else {
      await execAsync(`lsof -i :${port} -t | xargs kill -9`);
      return true;
    }
  } catch (error) {
    return false;
  }
  return false;
};

// Function to start the application
const startApp = async (port) => {
  const command = `npm run start:port ${port}`;
  console.log(chalk.cyan(`\nStarting application on port ${port}...`));
  
  const child = exec(command);
  
  child.stdout.on('data', (data) => {
    console.log(data);
  });

  child.stderr.on('data', (data) => {
    console.error(chalk.red(data));
  });

  child.on('close', (code) => {
    if (code !== 0) {
      console.log(chalk.red(`Process exited with code ${code}`));
    }
    process.exit(code);
  });
};

// Main execution
const main = async () => {
  const defaultPort = 3000;
  
  try {
    // Check if default port is in use
    if (await isPortInUse(defaultPort)) {
      console.log(chalk.yellow(`\nPort ${defaultPort} is in use.`));
      
      // Try to find next available port
      const nextPort = await findAvailablePort(defaultPort + 1);
      
      if (nextPort) {
        console.log(chalk.green(`Found available port: ${nextPort}`));
        await startApp(nextPort);
      } else {
        console.error(chalk.red('No available ports found. Please free up some ports and try again.'));
        process.exit(1);
      }
    } else {
      await startApp(defaultPort);
    }
  } catch (error) {
    console.error(chalk.red('Error starting application:', error));
    process.exit(1);
  }
};

// Start the application
main(); 
```

## File: scripts\test-db-creation.ts
```ts
import { MongoClient } from 'mongodb';
import { config } from 'dotenv';
import { fileURLToPath } from 'url';
import { dirname } from 'path';
import path from 'path';

// Setup __dirname equivalent for ES modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Load environment variables
const envPath = path.resolve(__dirname, '../.env');
config({ path: envPath });

const MONGODB_URI = process.env.MONGODB_URI || "mongodb+srv://vivekkumarsingh:dGeuK817ItxjmUb4@cluster0.vir7o.mongodb.net/?retryWrites=true&w=majority&appName=Cluster0";

async function testDatabaseCreation() {
  console.log('Starting database creation test...');
  console.log('Using MongoDB URI:', MONGODB_URI);
  
  const client = new MongoClient(MONGODB_URI);

  try {
    await client.connect();
    console.log('Connected to MongoDB');

    // Create a demo database
    const databaseName = 'demo_test_db';
    const db = client.db(databaseName);
    console.log(`Created database reference: ${databaseName}`);

    // Create test collections
    const collections = [
      'demo_collection_1',
      'demo_collection_2',
      'demo_collection_3'
    ];

    for (const collectionName of collections) {
      try {
        await db.createCollection(collectionName);
        console.log(`Created collection: ${collectionName}`);
      } catch (error: any) {
        if (error.code === 48) {
          console.log(`Collection ${collectionName} already exists`);
        } else {
          console.error(`Error creating collection ${collectionName}:`, error);
          throw error;
        }
      }
    }

    // List all collections to verify
    const collectionsList = await db.listCollections().toArray();
    console.log('\nVerifying collections:');
    collectionsList.forEach(collection => {
      console.log(`- ${collection.name}`);
    });

    // Insert a test document
    const testCollection = db.collection('demo_collection_1');
    await testCollection.insertOne({
      test: true,
      createdAt: new Date(),
      message: 'Test document'
    });
    console.log('\nInserted test document');

    // Verify document
    const doc = await testCollection.findOne({ test: true });
    console.log('Retrieved test document:', doc);

  } catch (error) {
    console.error('Test failed:', error);
  } finally {
    await client.close();
    console.log('\nDatabase connection closed');
  }
}

// Run the test
testDatabaseCreation()
  .then(() => {
    console.log('Test completed successfully');
    process.exit(0);
  })
  .catch((error) => {
    console.error('Test failed:', error);
    process.exit(1);
  }); 
```

## File: src\types\dialogue.ts
```ts
export interface Dialogue {
  _id: string
  index: number
  timeStart: string
  timeEnd: string
  character: string
  videoUrl: string
  dialogue: {
    original: string
    translated: string
    adapted: string
  }
  emotions: {
    primary: {
      emotion: string
      intensity: number
    }
    secondary: {
      emotion: string
      intensity: number
    }
  }
  direction: string
  lipMovements: number
  sceneContext: string
  technicalNotes: string
  culturalNotes: string
  status: string
  recordingStatus: string
  projectId: string
  updatedAt: string
  updatedBy: string
  voiceOverUrl: string | null
}

export interface DialogueViewProps {
  dialogues: Dialogue[]
  projectId: string
} 
```

## File: tailwind.config.ts
```ts
import type { Config } from "tailwindcss";

const config: Config = {
    darkMode: ["class"],
    content: [
    "./pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./components/**/*.{js,ts,jsx,tsx,mdx}",
    "./app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
  	extend: {
  		colors: {
  			background: 'hsl(var(--background))',
  			foreground: 'hsl(var(--foreground))',
  			card: {
  				DEFAULT: 'hsl(var(--card))',
  				foreground: 'hsl(var(--card-foreground))'
  			},
  			popover: {
  				DEFAULT: 'hsl(var(--popover))',
  				foreground: 'hsl(var(--popover-foreground))'
  			},
  			primary: {
  				DEFAULT: 'hsl(var(--primary))',
  				foreground: 'hsl(var(--primary-foreground))'
  			},
  			secondary: {
  				DEFAULT: 'hsl(var(--secondary))',
  				foreground: 'hsl(var(--secondary-foreground))'
  			},
  			muted: {
  				DEFAULT: 'hsl(var(--muted))',
  				foreground: 'hsl(var(--muted-foreground))'
  			},
  			accent: {
  				DEFAULT: 'hsl(var(--accent))',
  				foreground: 'hsl(var(--accent-foreground))'
  			},
  			destructive: {
  				DEFAULT: 'hsl(var(--destructive))',
  				foreground: 'hsl(var(--destructive-foreground))'
  			},
  			border: 'hsl(var(--border))',
  			input: 'hsl(var(--input))',
  			ring: 'hsl(var(--ring))',
  			chart: {
  				'1': 'hsl(var(--chart-1))',
  				'2': 'hsl(var(--chart-2))',
  				'3': 'hsl(var(--chart-3))',
  				'4': 'hsl(var(--chart-4))',
  				'5': 'hsl(var(--chart-5))'
  			}
  		},
  		borderRadius: {
  			lg: 'var(--radius)',
  			md: 'calc(var(--radius) - 2px)',
  			sm: 'calc(var(--radius) - 4px)'
  		}
  	}
  },
  plugins: [require("tailwindcss-animate")],
};
export default config;

```

## File: Tools\copyandpaste.js
```js
import { readFileSync, writeFileSync, readdirSync, statSync } from 'fs';
import { join, resolve, relative } from 'path';
import { fileURLToPath } from 'url';
import { dirname } from 'path';
import ignore from 'ignore';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Read .gitignore and create ignore filter
const gitignorePath = join(process.cwd(), '.gitignore');
const ig = ignore();
// Always ignore .git directory and README.md
ig.add(['.git/**', ".__tests__/**", 'README.md', 'package-lock.json', 'notes/**', '.cursorignore', '.cursorrules']);
try {
    const gitignoreContent = readFileSync(gitignorePath, 'utf8');
    ig.add(gitignoreContent);
} catch (err) {
    console.warn('No .gitignore file found, proceeding without ignore rules');
}

// Remove IGNORED_DIRS constant since we'll use .gitignore rules instead
const MAX_FILE_SIZE = 10240 * 1024; // 10MB limit per file

function getAllFiles(dirPath, arrayOfFiles = [], indent = '') {
    const files = readdirSync(dirPath);
    let content = '';

    for (const file of files) {
        const fullPath = join(dirPath, file);
        const relativePath = relative(process.cwd(), fullPath);
        
        // Skip files/directories that match .gitignore rules
        if (ig.ignores(relativePath)) {
            continue;
        }

        const stats = statSync(fullPath);
        
        if (stats.isDirectory()) {
            // Skip if any parent directory is .git
            if (fullPath.includes('/.git/') || fullPath.includes('\\.git\\')) {
                continue;
            }
            content += `${indent}ğŸ“ ${file}/\n`;
            // Recursively get contents of subdirectories
            const { fileList, fileContent } = getAllFiles(fullPath, arrayOfFiles, indent + '  ');
            content += fileContent;
            arrayOfFiles = fileList;
        } else {
            // Skip if file is in .git directory
            if (fullPath.includes('/.git/') || fullPath.includes('\\.git\\')) {
                continue;
            }
            // Add file name to structure
            content += `${indent}ğŸ“„ ${file}`;
            
            // Skip large files
            if (stats.size > MAX_FILE_SIZE) {
                content += ` (file too large - ${(stats.size / 10240 / 1024).toFixed(2)}MB)\n`;
                continue;
            }

            // Skip binary files or files with specific extensions
            const ext = file.toLowerCase().split('.').pop();
            if (['jpg', 'jpeg', 'png', 'gif', 'ico', 'woff', 'woff2', 'ttf', 'eot', 'mp3', 'mp4', 'zip', 'pdf'].includes(ext)) {
                content += ' (binary file - skipped)\n';
                continue;
            }

            content += '\n';
            
            // Add file contents
            try {
                const fileContent = readFileSync(fullPath, 'utf8');
                arrayOfFiles.push({
                    path: relativePath,
                    content: fileContent
                });
            } catch (err) {
                console.error(`Error reading file ${fullPath}: ${err}`);
                content += `${indent}  (error reading file)\n`;
            }
        }
    }

    return { fileList: arrayOfFiles, fileContent: content };
}

function generateFileStructureAndContents() {
    const parentDir = resolve(__dirname, '..');
    const { fileList, fileContent } = getAllFiles(parentDir);
    
    let outputContent = '# Project Structure\n\n';
    outputContent += fileContent;
    outputContent += '\n\n# File Contents\n\n';

    fileList.forEach(file => {
        // Get file extension for proper code block formatting
        const ext = file.path.split('.').pop() || '';
        outputContent += `\n## File: ${file.path}\n\`\`\`${ext}\n${file.content}\n\`\`\`\n`;
    });

    // Write to output file
    const outputPath = join(__dirname, 'project_structure_and_contents.txt');
    writeFileSync(outputPath, outputContent);
    console.log(`File structure and contents have been saved to: ${outputPath}`);
}

// Execute the function
generateFileStructureAndContents();

```

## File: tsconfig.json
```json
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    },
    "types": [
      "@aws-sdk/client-s3"
    ],
    "baseUrl": "."
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}

```

## File: types\dialogue.ts
```ts
export interface CharacterProfile {
  age?: string;
  occupation?: string;
  accents?: string[];
  otherNotes?: string;
}

export interface WordDetail {
  characterName: string;
  wordSequenceNumber: number;
  word: string;
  wordTimestamp: string;
  dialogNumber: number;
  dialogStartTimestamp: string;
  dialogEndTimestamp: string;
  dialogVocalFile?: string;
  characterProfile?: CharacterProfile;
  numberOfLipMovementsForThisWord?: number;
}

export interface DialogueText {
  original: string;
  translated: string;
  adapted: string;
}

export interface Emotions {
  primary: {
    emotion?: string;
    intensity?: number;
  };
  secondary?: {
    emotion?: string;
    intensity?: number;
  };
}

export interface Scenario {
  name?: string;
  description?: string;
  location?: string;
  timeOfDay?: string;
  otherScenarioNotes?: string;
}

export interface Dialogue {
  _id: string;
  index: number;
  timeStart: string;
  timeEnd: string;
  character: string;
  videoUrl: string;
  dialogue: DialogueText;
  emotions?: Emotions;
  direction?: string;
  lipMovements?: string;
  sceneContext?: string;
  technicalNotes?: string;
  culturalNotes?: string;
  status: string;
  voiceOverUrl?: string;
  voiceOverNotes?: string;
  directorNotes?: string;
  recordingStatus?: string;
  projectId?: string;
  updatedAt?: string;
  updatedBy?: string;
  words?: WordDetail[];
  scenario?: Scenario;
  deleteVoiceOver?: boolean;
} 
```

## File: types\next-auth.d.ts
```ts
import 'next-auth'
import { JWT } from 'next-auth/jwt'

declare module 'next-auth' {
  interface Session {
    user: {
      id: string
      username: string
      role: string
      email: string | null
      name?: string | null
      image?: string | null
    }
  }

  interface User {
    id: string
    username: string
    role: string
    email?: string | null
  }
}

declare module 'next-auth/jwt' {
  interface JWT {
    id: string
    username: string
    role: string
    email?: string | null
  }
} 
```

## File: types\project.ts
```ts
import { User } from './user';

export type ProjectStatus = 'pending' | 'in-progress' | 'completed' | 'on-hold';

interface AssignedUser {
  username: string;
  role: string;
}

export interface Episode {
  _id: string;
  name: string;
  collectionName: string;
  videoPath: string;
  videoKey: string;
  status: 'uploaded' | 'processing' | 'error';
  uploadedAt: Date;
}

export interface Project {
  dialogue_collection: any;
  _id: string;
  title: string;
  description: string;
  sourceLanguage: string;
  targetLanguage: string;
  status: ProjectStatus;
  assignedTo: AssignedUser[];
  updatedAt: string | Date;
  createdAt?: string | Date;
  parentFolder: string;
  databaseName: string;
  episodes: Episode[];
  uploadStatus: {
    totalFiles: number;
    completedFiles: number;
    currentFile: number;
    status: string;
  };
}

// Import and re-export the UserRole type from types/user
export type { UserRole } from './user'; 
```

## File: types\user.ts
```ts
export type UserRole = 'transcriber' | 'translator' | 'voiceOver' | 'director' | 'admin';

interface SessionLog {
  loginTime: string | Date;
  userAgent: string;
}

export interface User {
  _id: string;
  username: string;
  email: string;
  password?: string;
  role: UserRole;
  lastLogin?: string | Date;
  lastLogout?: string | Date | null;
  sessionsLog: SessionLog[];
  assignedProjects: string[];
  isActive: boolean;
  createdAt: string | Date;
  updatedAt: string | Date;
} 
```

## File: utils\audio.ts
```ts
export type AudioData = {
  audioData: Float32Array[];
  peakLevel: number;
};

export const createWorker = async (audioContext: AudioContext) => {
  const workletCode = `
    class RecorderProcessor extends AudioWorkletProcessor {
      constructor() {
        super();
        this.isRecording = true;
        this.bufferSize = 4096;
        this.sampleRate = 48000;
        this.isProcessing = false;
        this.isStopping = false;
        
        // Initialize buffer for each channel
        this.buffers = [new Float32Array(this.bufferSize), new Float32Array(this.bufferSize)];
        this.bufferIndex = 0;
        
        this.port.onmessage = (event) => {
          if (event.data === 'stop' && !this.isStopping) {
            this.isStopping = true;
            this.isRecording = false;
            // Send any remaining buffered data
            if (this.bufferIndex > 0) {
              this.flush();
            }
            // Send end signal
            this.port.postMessage({ type: 'stopped' });
          }
        };
      }

      flush() {
        if (this.bufferIndex > 0 && !this.isProcessing) {
          this.isProcessing = true;
          
          const audioData = this.buffers.map(buffer => {
            const trimmedBuffer = new Float32Array(this.bufferIndex);
            trimmedBuffer.set(buffer.subarray(0, this.bufferIndex));
            return trimmedBuffer;
          });
          
          const peakLevel = Math.max(
            ...audioData.map(channel => 
              Math.max(...channel.map(Math.abs))
            )
          );

          this.port.postMessage({ 
            type: 'chunk',
            audioData, 
            peakLevel 
          });
          
          // Reset buffers
          this.buffers = [new Float32Array(this.bufferSize), new Float32Array(this.bufferSize)];
          this.bufferIndex = 0;
          this.isProcessing = false;
        }
      }

      process(inputs) {
        const input = inputs[0];
        if (!input || input.length === 0 || !this.isRecording || this.isProcessing) return true;

        // Process each channel
        input.forEach((channel, channelIndex) => {
          if (channel && channel.length > 0) {
            // Calculate remaining space in buffer
            const remainingSpace = this.bufferSize - this.bufferIndex;
            
            if (remainingSpace >= channel.length) {
              // If we have enough space, add samples directly
              for (let i = 0; i < channel.length; i++) {
                // Apply gain and normalize
                this.buffers[channelIndex][this.bufferIndex + i] = 
                  Math.max(-1, Math.min(1, channel[i] * 1.5)); // gainFactor = 1.5
              }
              
              // Only increment buffer index after processing last channel
              if (channelIndex === input.length - 1) {
                this.bufferIndex += channel.length;
                
                // If buffer is full or nearly full, flush it
                if (this.bufferIndex >= this.bufferSize - 128) {
                  this.flush();
                }
              }
            } else {
              // If not enough space, fill current buffer and create new one
              for (let i = 0; i < remainingSpace; i++) {
                this.buffers[channelIndex][this.bufferIndex + i] = 
                  Math.max(-1, Math.min(1, channel[i] * 1.5));
              }
              
              if (channelIndex === input.length - 1) {
                // Flush the full buffer
                this.flush();
                
                // Process remaining samples
                const remainingSamples = channel.length - remainingSpace;
                for (let i = 0; i < remainingSamples; i++) {
                  this.buffers[channelIndex][i] = 
                    Math.max(-1, Math.min(1, channel[remainingSpace + i] * 1.5));
                }
                this.bufferIndex = remainingSamples;
              }
            }
          }
        });

        return true;
      }
    }

    registerProcessor('recorder-processor', RecorderProcessor);
  `;

  const blob = new Blob([workletCode], { type: 'application/javascript' });
  const workletUrl = URL.createObjectURL(blob);

  try {
    await audioContext.audioWorklet.addModule(workletUrl);
    const workletNode = new AudioWorkletNode(audioContext, 'recorder-processor', {
      numberOfInputs: 1,
      numberOfOutputs: 1,
      channelCount: 2,
      processorOptions: {
        sampleRate: 48000,
        bufferSize: 4096
      }
    });

    // Add message type handling
    workletNode.port.onmessage = (event) => {
      if (event.data.type === 'chunk') {
        workletNode.dispatchEvent(new CustomEvent('audiochunk', {
          detail: {
            audioData: event.data.audioData,
            peakLevel: event.data.peakLevel
          }
        }));
      } else if (event.data.type === 'stopped') {
        workletNode.dispatchEvent(new CustomEvent('stopped'));
      }
    };

    // Clean up the URL
    URL.revokeObjectURL(workletUrl);

    return workletNode;
  } catch (error) {
    console.error('Failed to create audio worklet:', error);
    URL.revokeObjectURL(workletUrl);
    throw error;
  }
};

export const createWavBlob = (audioData: Float32Array[], sampleRate: number = 48000): Blob => {
  const numChannels = audioData.length;
  const length = audioData[0].length;
  const buffer = new ArrayBuffer(44 + length * numChannels * 2);
  const view = new DataView(buffer);

  const writeString = (view: DataView, offset: number, string: string) => {
    for (let i = 0; i < string.length; i++) {
      view.setUint8(offset + i, string.charCodeAt(i));
    }
  };

  // Write WAV header
  writeString(view, 0, 'RIFF');
  view.setUint32(4, 36 + length * numChannels * 2, true);
  writeString(view, 8, 'WAVE');
  writeString(view, 12, 'fmt ');
  view.setUint32(16, 16, true);
  view.setUint16(20, 1, true);
  view.setUint16(22, numChannels, true);
  view.setUint32(24, sampleRate, true);
  view.setUint32(28, sampleRate * numChannels * 2, true);
  view.setUint16(32, numChannels * 2, true);
  view.setUint16(34, 16, true);
  writeString(view, 36, 'data');
  view.setUint32(40, length * numChannels * 2, true);

  // Write audio data
  const offset = 44;
  for (let i = 0; i < length; i++) {
    for (let channel = 0; channel < numChannels; channel++) {
      const sample = Math.max(-1, Math.min(1, audioData[channel][i]));
      view.setInt16(offset + (i * numChannels + channel) * 2, sample * 0x7FFF, true);
    }
  }

  return new Blob([buffer], { type: 'audio/wav' });
}; 
```

## File: utils\cn.ts
```ts
import { clsx, type ClassValue } from 'clsx';
import { twMerge } from 'tailwind-merge';

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
} 
```

## File: utils\formatters.ts
```ts
export const getNumberValue = (mongoNumber: any): number => {
  if (typeof mongoNumber === 'object' && mongoNumber !== null) {
    if ('$numberInt' in mongoNumber) return Number(mongoNumber.$numberInt);
    if ('$numberDouble' in mongoNumber) return Number(mongoNumber.$numberDouble);
  }
  return Number(mongoNumber);
};

export const formatTime = (seconds: number): string => {
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  const secs = Math.floor(seconds % 60);
  const milliseconds = Math.floor((seconds % 1) * 1000);

  return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}:${milliseconds.toString().padStart(3, '0')}`;
};

export const calculateDuration = (timeStart: string, timeEnd: string): number => {
  const parseTime = (time: string): number => {
    const [hours, minutes, seconds, milliseconds] = time.split(':').map(Number);
    return (hours * 3600) + (minutes * 60) + seconds + (milliseconds / 1000);
  };
  
  const startSeconds = parseTime(timeStart);
  const endSeconds = parseTime(timeEnd);
  return Number((endSeconds - startSeconds).toFixed(3));
}; 
```

## File: vercel.json
```json
{} 
```
