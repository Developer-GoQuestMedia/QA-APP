# Project Structure

📄 .eslintrc.json
📁 .git/
📄 .gitignore
📁 .next/
📁 .notes/
  📄 directory_structure.md
  📄 project_overview.md
  📄 task_list.md
📁 app/
  📁 admin/
    📁 project/
      📁 [projectId]/
        📁 progress/
          📄 page.tsx
  📁 allDashboards/
    📁 admin/
      📄 page.tsx
    📁 director/
      📄 page.tsx
      📁 [projectId]/
        📄 page.tsx
    📄 page.tsx
    📁 transcriber/
      📄 page.tsx
      📁 [projectId]/
        📄 page.tsx
    📁 translator/
      📄 page.tsx
      📁 [projectId]/
        📄 page.tsx
    📁 voice-over/
      📄 page.tsx
      📁 [projectId]/
        📄 page.tsx
  📁 api/
    📁 admin/
      📁 projects/
        📄 route.ts
        📁 [projectId]/
          📁 assign/
            📄 route.ts
          📁 progress/
            📄 route.ts
          📄 route.ts
      📁 users/
        📄 route.ts
        📁 [userId]/
          📄 route.ts
    📁 auth/
      📄 auth.config.ts
      📁 login/
        📄 route.ts
      📁 [...nextauth]/
        📄 route.ts
    📁 dialogues/
      📄 route.ts
      📁 [id]/
        📄 route.ts
    📁 projects/
      📄 route.ts
      📁 [id]/
        📁 assign/
          📄 route.ts
    📁 upload-audio/
      📄 route.ts
    📁 upload-voice-over/
      📄 route.ts
    📁 users/
      📁 me/
        📄 route.ts
      📄 route.ts
    📁 voice-over/
      📁 upload/
        📄 route.ts
  📁 components/
    📄 Button.tsx
    📄 Card.tsx
    📄 ThemeToggle.tsx
  📄 favicon.ico (binary file - skipped)
  📁 fonts/
    📄 GeistMonoVF.woff (binary file - skipped)
    📄 GeistVF.woff (binary file - skipped)
  📄 globals.css
  📄 layout.tsx
  📁 login/
    📄 page.tsx
  📄 page.tsx
  📄 providers.tsx
  📁 styles/
    📄 styleLogger.ts
    📄 theme.ts
📁 components/
  📄 AdminView.tsx
  📁 audio/
  📄 AudioVisualizer.tsx
  📄 Button.tsx
  📄 Card.tsx
  📁 common/
  📄 DashboardLayout.tsx
  📄 DirectorDialogueView.tsx
  📄 DirectorView.tsx
  📁 layout/
  📄 RecordingTimer.tsx
  📄 TranscriberDialogueView.tsx
  📄 TranscriberView.tsx
  📄 TranslatorDialogueView.tsx
  📄 TranslatorView.tsx
  📁 ui/
    📄 alert.tsx
  📁 views/
  📄 VoiceOverDialogueView.tsx
  📄 VoiceOverView.tsx
📄 components.json
📁 hooks/
  📄 useAudioRecording.ts
  📄 useDialogues.ts
  📄 useProject.ts
  📄 useProjects.ts
📄 jest.config.ts
📄 jest.setup.ts
📁 lib/
  📄 auth.ts
  📄 mongodb.ts
  📄 seed.ts
  📄 utils.ts
📄 middleware.ts
📄 next.config.mjs
📄 package.json
📄 postcss.config.mjs
📁 scripts/
  📄 build-success.js
  📄 seed-users.ts
  📄 seed.ts
  📄 start-app.js
📁 src/
  📁 types/
    📄 dialogue.ts
📄 tailwind.config.ts
📁 Tools/
  📄 copyandpaste.js
📄 tsconfig.json
📁 types/
  📄 dialogue.ts
  📄 next-auth.d.ts
  📄 project.ts
  📄 user.ts
📁 utils/
  📄 audio.ts
  📄 cn.ts
  📄 formatters.ts
📁 __tests__/
  📁 components/
    📄 TranscriberDialogueView.test.tsx
    📄 TranscriberView.test.tsx
    📄 VoiceOverDialogueView.test.tsx
    📄 VoiceOverView.test.tsx
  📄 login.test.tsx
  📄 mongodb.test.ts


# File Contents


## File: .eslintrc.json
```json
{
  "extends": [
    "next/core-web-vitals",
    "plugin:@typescript-eslint/recommended",
    "plugin:jest/recommended",
    "plugin:testing-library/react"
  ],
  "plugins": [
    "@typescript-eslint",
    "jest",
    "testing-library"
  ],
  "env": {
    "jest": true,
    "browser": true,
    "node": true
  },
  "rules": {
    "@typescript-eslint/no-explicit-any": "warn",
    "@typescript-eslint/no-unused-vars": ["warn", {
      "varsIgnorePattern": "^(rotate|opacity|scale|animControls|autoResizeTextArea|checkMediaSupport|mediaRecorderRef|playbackRate|handleNext|handlePrevious|rewindFiveSeconds|changePlaybackRate)$",
      "argsIgnorePattern": "^_"
    }],
    "jest/no-disabled-tests": "warn",
    "jest/no-focused-tests": "error",
    "jest/no-identical-title": "error",
    "jest/prefer-to-have-length": "warn",
    "jest/valid-expect": "error"
  },
  "overrides": [
    {
      "files": ["**/__tests__/**/*.[jt]s?(x)", "**/?(*.)+(spec|test).[jt]s?(x)"],
      "extends": ["plugin:testing-library/react"]
    }
  ]
}

```

## File: .gitignore
```gitignore
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js
.yarn/install-state.gz

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local
.env
.env.development
.env.test
.env.production

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

# IDE
.idea/
.vscode/
*.sublime-project
*.sublime-workspace

# Build and Cache
.swc/
.turbo
.cache/
dist/

# Logs
logs/
*.log

# System Files
Thumbs.db
.DS_Store
desktop.ini

```

## File: .notes\directory_structure.md
```md
﻿# Current Directory Structure

## Core Components

`
- **.notes/**
    - project_overview.md
    - task_list.md
- **app/**
    - **admin/**
        - **project/**
            - **[projectId]/**
    - **allDashboards/**
        - **admin/**
            - page.tsx
        - **director/**
            - **[projectId]/**
            - page.tsx
        - **transcriber/**
            - **[projectId]/**
            - page.tsx
        - **translator/**
            - **[projectId]/**
            - page.tsx
        - **voice-over/**
            - **[projectId]/**
            - page.tsx
        - page.tsx
    - **api/**
        - **admin/**
            - **projects/**
                - **[projectId]/**
                - route.ts
            - **users/**
                - **[userId]/**
                - route.ts
        - **auth/**
            - **login/**
                - route.ts
            - **[...nextauth]/**
            - auth.config.ts
        - **dialogues/**
            - **[id]/**
            - route.ts
        - **projects/**
            - **[id]/**
            - route.ts
        - **upload-audio/**
            - route.ts
        - **upload-voice-over/**
            - route.ts
        - **users/**
            - **me/**
                - route.ts
            - route.ts
        - **voice-over/**
            - **upload/**
                - route.ts
    - **components/**
        - Button.tsx
        - Card.tsx
        - ThemeToggle.tsx
    - **dashboard/**
        - page.tsx
    - **fonts/**
        - GeistMonoVF.woff
        - GeistVF.woff
    - **login/**
        - page.tsx
    - **styles/**
        - styleLogger.ts
        - theme.ts
    - favicon.ico
    - globals.css
    - layout.tsx
    - page.tsx
    - providers.tsx
- **components/**
    - **audio/**
    - **common/**
    - **layout/**
    - **ui/**
        - alert.tsx
    - **views/**
    - AdminView.tsx
    - AudioVisualizer.tsx
    - Button.tsx
    - Card.tsx
    - DashboardLayout.tsx
    - DirectorDialogueView.tsx
    - DirectorView.tsx
    - RecordingTimer.tsx
    - TranscriberDialogueView.tsx
    - TranscriberView.tsx
    - TranslatorDialogueView.tsx
    - TranslatorView.tsx
    - VoiceOverDialogueView.tsx
    - VoiceOverView.tsx
- **hooks/**
    - useAudioRecording.ts
    - useDialogues.ts
    - useProject.ts
    - useProjects.ts
- **lib/**
    - auth.ts
    - mongodb.ts
    - seed.ts
    - utils.ts
- **scripts/**
    - build-success.js
    - seed-users.ts
    - seed.ts
    - start-app.js
- **src/**
    - **types/**
        - dialogue.ts
- **Tools/**
    - copyandpaste.js
    - project_structure_and_contents.txt
- **types/**
    - dialogue.ts
    - next-auth.d.ts
    - project.ts
    - user.ts
- **utils/**
    - audio.ts
    - cn.ts
    - formatters.ts
- **__tests__/**
    - **components/**
        - TranscriberDialogueView.test.tsx
        - TranscriberView.test.tsx
        - VoiceOverDialogueView.test.tsx
        - VoiceOverView.test.tsx
    - login.test.tsx
    - mongodb.test.ts
- .cursorignore
- .cursorrules
- .env
- .env.local
- .eslintrc.json
- .gitignore
- components.json
- jest.config.ts
- jest.setup.ts
- next-env.d.ts
- next.config.mjs
- package-lock.json
- package.json
- postcss.config.mjs
- README.md
- tailwind.config.ts
- tsconfig.json
- update_directory.ps1
`
```

## File: .notes\project_overview.md
```md
# QA-APP Project Overview

## Project Description
A comprehensive Quality Assurance application for managing multimedia content translation and voice-over production workflow. The application supports multiple user roles and provides specialized interfaces for transcription, translation, voice-over recording, and project management.

## Technical Stack
- **Frontend Framework**: Next.js 14.2.16
- **Language**: TypeScript
- **Styling**: Tailwind CSS with custom theming
- **State Management**: React Query (TanStack Query)
- **Authentication**: NextAuth.js
- **Database**: MongoDB
- **Storage**: AWS S3 (for media files)
- **Testing**: Jest with React Testing Library

## Core Features

### 1. Authentication & Authorization
- Role-based access control (RBAC)
- Supported roles: admin, director, transcriber, translator, voice-over
- Secure session management with JWT
- Protected API routes and client-side navigation

### 2. Project Management
- Project creation and assignment
- Progress tracking
- Multi-language support
- Resource allocation
- Status monitoring

### 3. Workflow Components
- **Transcription Module**
  - Video playback with controls
  - Time-stamped dialogue entry
  - Character assignment
  - Auto-save functionality

- **Translation Module**
  - Original text reference
  - Translation input
  - Adaptation support
  - Cultural notes

- **Voice-Over Module**
  - Audio recording with visualization
  - Playback controls
  - Timing synchronization
  - Quality monitoring

### 4. Technical Features
- Real-time audio processing
- Video playback synchronization
- Automated progress calculation
- File upload/download management
- Responsive design
- Dark/Light theme support

## Project Structure

### Key Directories
- `/app`: Next.js application routes and API endpoints
- `/components`: Reusable React components
- `/hooks`: Custom React hooks
- `/lib`: Core utilities and configurations
- `/types`: TypeScript type definitions
- `/utils`: Helper functions and utilities
- `/tests`: Test suites and configurations

### Main Components
1. **User Interface**
   - AdminView
   - TranscriberView
   - TranslatorView
   - VoiceOverView
   - DirectorView

2. **Dialogue Management**
   - TranscriberDialogueView
   - TranslatorDialogueView
   - VoiceOverDialogueView

3. **Media Handling**
   - AudioVisualizer
   - RecordingTimer
   - VideoPlayer

## Development Guidelines

### Code Standards
- TypeScript strict mode enabled
- ESLint configuration for code quality
- Jest for unit and integration testing
- Component-based architecture
- Responsive design principles

### Security Measures
- API route protection
- Input validation
- Secure file handling
- Session management
- Environment variable usage

### Performance Optimization
- Lazy loading
- Optimized media handling
- Caching strategies
- Query optimization

## Deployment
- Production build optimization
- Environment configuration
- Database seeding support
- Monitoring setup

## Future Enhancements
1. Real-time collaboration features
2. Enhanced progress analytics
3. Batch processing capabilities
4. Advanced search functionality
5. Extended language support

## Documentation
- API documentation
- Component documentation
- Type definitions
- Testing guidelines
- Deployment procedures

```

## File: .notes\task_list.md
```md

```

## File: app\admin\project\[projectId]\progress\page.tsx
```tsx
'use client'

import { useSession } from 'next-auth/react'
import { useRouter } from 'next/navigation'
import { useEffect } from 'react'
import { useQuery } from '@tanstack/react-query'
import axios from 'axios'

interface ProjectProgress {
  transcribed: number
  translated: number
  voiceOver: number
  approved: number
  total: number
  lastUpdated: string
}

export default function ProjectProgressPage({
  params,
}: {
  params: { projectId: string }
}) {
  const { data: session, status } = useSession()
  const router = useRouter()

  const { data: progress, isLoading } = useQuery<ProjectProgress>({
    queryKey: ['project-progress', params.projectId],
    queryFn: async () => {
      const response = await axios.get(`/api/admin/projects/${params.projectId}/progress`)
      return response.data.data
    },
    enabled: !!session && session.user.role === 'admin'
  })

  useEffect(() => {
    if (status === 'unauthenticated' || (session && session.user.role !== 'admin')) {
      router.push('/login')
    }
  }, [status, session, router])

  if (status === 'loading' || isLoading) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="text-center">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary mx-auto"></div>
          <p className="mt-2">Loading...</p>
        </div>
      </div>
    )
  }

  if (!progress) {
    return null
  }

  return (
    <div className="min-h-screen bg-gray-50 dark:bg-gray-900 py-8">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <div className="mb-8">
          <button
            onClick={() => router.back()}
            className="text-blue-500 hover:text-blue-600 transition-colors"
          >
            ← Back
          </button>
        </div>

        <div className="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
          <h1 className="text-2xl font-bold text-gray-900 dark:text-white mb-6">Project Progress</h1>

          <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-4">
            <div className="bg-blue-50 dark:bg-blue-900/50 rounded-lg p-4">
              <h3 className="text-blue-800 dark:text-blue-200 font-medium">Transcribed</h3>
              <div className="mt-2">
                <div className="flex items-center">
                  <div className="flex-1 bg-blue-200 dark:bg-blue-700 rounded-full h-2">
                    <div
                      className="bg-blue-500 h-2 rounded-full"
                      style={{ width: `${progress.transcribed}%` }}
                    />
                  </div>
                  <span className="ml-2 text-blue-800 dark:text-blue-200">
                    {progress.transcribed}%
                  </span>
                </div>
              </div>
            </div>

            <div className="bg-purple-50 dark:bg-purple-900/50 rounded-lg p-4">
              <h3 className="text-purple-800 dark:text-purple-200 font-medium">Translated</h3>
              <div className="mt-2">
                <div className="flex items-center">
                  <div className="flex-1 bg-purple-200 dark:bg-purple-700 rounded-full h-2">
                    <div
                      className="bg-purple-500 h-2 rounded-full"
                      style={{ width: `${progress.translated}%` }}
                    />
                  </div>
                  <span className="ml-2 text-purple-800 dark:text-purple-200">
                    {progress.translated}%
                  </span>
                </div>
              </div>
            </div>

            <div className="bg-green-50 dark:bg-green-900/50 rounded-lg p-4">
              <h3 className="text-green-800 dark:text-green-200 font-medium">Voice Over</h3>
              <div className="mt-2">
                <div className="flex items-center">
                  <div className="flex-1 bg-green-200 dark:bg-green-700 rounded-full h-2">
                    <div
                      className="bg-green-500 h-2 rounded-full"
                      style={{ width: `${progress.voiceOver}%` }}
                    />
                  </div>
                  <span className="ml-2 text-green-800 dark:text-green-200">
                    {progress.voiceOver}%
                  </span>
                </div>
              </div>
            </div>

            <div className="bg-yellow-50 dark:bg-yellow-900/50 rounded-lg p-4">
              <h3 className="text-yellow-800 dark:text-yellow-200 font-medium">Approved</h3>
              <div className="mt-2">
                <div className="flex items-center">
                  <div className="flex-1 bg-yellow-200 dark:bg-yellow-700 rounded-full h-2">
                    <div
                      className="bg-yellow-500 h-2 rounded-full"
                      style={{ width: `${progress.approved}%` }}
                    />
                  </div>
                  <span className="ml-2 text-yellow-800 dark:text-yellow-200">
                    {progress.approved}%
                  </span>
                </div>
              </div>
            </div>
          </div>

          <div className="mt-6 text-sm text-gray-500 dark:text-gray-400">
            <p>Total Dialogues: {progress.total}</p>
            <p>Last Updated: {new Date(progress.lastUpdated).toLocaleString()}</p>
          </div>
        </div>
      </div>
    </div>
  )
} 
```

## File: app\allDashboards\admin\page.tsx
```tsx
'use client'

import { useSession } from 'next-auth/react'
import { useState, useEffect } from 'react'
import AdminView from '@/components/AdminView'
import DashboardLayout from '@/components/DashboardLayout'
import { Project } from '@/types/project'
import axios from 'axios'

export default function Page() {
  const { data: session, status } = useSession()
  const [projects, setProjects] = useState<Project[]>([])

  const fetchProjects = async () => {
    try {
      console.log('Fetching projects...');
      const { data } = await axios.get('/api/projects')
      const projectsWithDates = data.map((project: Omit<Project, 'updatedAt' | 'createdAt'> & {
        updatedAt: string;
        createdAt?: string;
      }) => ({
        ...project,
        updatedAt: new Date(project.updatedAt),
        createdAt: project.createdAt ? new Date(project.createdAt) : undefined
      }))
      console.log('Projects fetched successfully:', projectsWithDates.length);
      setProjects(projectsWithDates)
    } catch (error) {
      console.error('Error fetching projects:', error)
    }
  }

  useEffect(() => {
    fetchProjects()
  }, [])

  if (status === 'loading') {
    return <div>Loading...</div>
  }

  return (
    <DashboardLayout title="Admin Dashboard">
      <AdminView projects={projects} refetchProjects={fetchProjects} />
    </DashboardLayout>
  )
} 
```

## File: app\allDashboards\director\page.tsx
```tsx
'use client'

import { useSession } from 'next-auth/react'
import DirectorView from '@/components/DirectorView'
import { useProjects } from '@/hooks/useProjects'

export default function DirectorDashboard() {
  const { data: session, status } = useSession()
  const { data: projects, isLoading: isLoadingProjects } = useProjects()

  if (status === 'loading' || isLoadingProjects) {
    return <div>Loading...</div>
  }

  return (
    <div className="min-h-screen bg-background">
      <DirectorView projects={projects || []} />
    </div>
  )
} 
```

## File: app\allDashboards\director\[projectId]\page.tsx
```tsx
'use client'

import { useSession } from 'next-auth/react'
import { useRouter } from 'next/navigation'
import { useDialogues } from '@/hooks/useDialogues'
import DirectorDialogueView from '../../../../components/DirectorDialogueView'

export default function DirectorProjectPage({
  params,
}: {
  params: { projectId: string }
}) {
  const { status } = useSession()
  const router = useRouter()
  const { data: dialogues, isLoading } = useDialogues(params.projectId)

  if (status === 'loading' || isLoading) {
    return (
      <div className="min-h-screen flex items-center justify-center p-4">
        <div className="text-center">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary mx-auto"></div>
          <p className="mt-2 text-foreground">Loading...</p>
        </div>
      </div>
    )
  }

  return (
    <div className="min-h-screen bg-background">
      <div className="w-full max-w-7xl mx-auto py-4 sm:py-6">
        <div className="flex justify-between items-center mb-4 sm:mb-6 px-4">
          <button
            onClick={() => router.push('/allDashboards/director')}
            className="text-primary hover:text-primary/80 transition-colors text-sm sm:text-base"
          >
            ← Back to Projects
          </button>
        </div>
        <DirectorDialogueView dialogues={dialogues || []} projectId={params.projectId} />
      </div>
    </div>
  )
} 
```

## File: app\allDashboards\page.tsx
```tsx
'use client'

import { useSession } from 'next-auth/react'

export default function DashboardRouter() {
  const { status } = useSession()

  if (status === 'loading') {
    return <div>Loading...</div>
  }

  return null
} 
```

## File: app\allDashboards\transcriber\page.tsx
```tsx
'use client'

import { useSession } from 'next-auth/react'
import TranscriberView from '@/components/TranscriberView'
import { useProjects } from '@/hooks/useProjects'

export default function TranscriberDashboard() {
  const { data: session, status } = useSession()
  const { data: projects, isLoading: isLoadingProjects } = useProjects()

  if (status === 'loading' || isLoadingProjects) {
    return <div>Loading...</div>
  }

  return (
    <div className="min-h-screen bg-background">
      <TranscriberView projects={projects || []} />
    </div>
  )
} 
```

## File: app\allDashboards\transcriber\[projectId]\page.tsx
```tsx
'use client'

import { useSession } from 'next-auth/react'
import { useRouter } from 'next/navigation'
import { useDialogues } from '@/hooks/useDialogues'
import TranscriberDialogueView from '../../../../components/TranscriberDialogueView'

export default function TranscriberProjectPage({
  params,
}: {
  params: { projectId: string }
}) {
  const { status } = useSession()
  const router = useRouter()
  const { data: dialogues, isLoading } = useDialogues(params.projectId)

  if (status === 'loading' || isLoading) {
    return (
      <div className="min-h-screen flex items-center justify-center p-4">
        <div className="text-center">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary mx-auto"></div>
          <p className="mt-2 text-foreground">Loading...</p>
        </div>
      </div>
    )
  }

  return (
    <div className="min-h-screen bg-background">
      <div className="w-full max-w-7xl mx-auto py-4 sm:py-6">
        <div className="flex justify-between items-center mb-4 sm:mb-6 px-4">
          <button
            onClick={() => router.push('/allDashboards/transcriber')}
            className="text-primary hover:text-primary/80 transition-colors text-sm sm:text-base"
          >
            ← Back to Projects
          </button>
        </div>
        <TranscriberDialogueView dialogues={dialogues || []} projectId={params.projectId} />
      </div>
    </div>
  )
} 
```

## File: app\allDashboards\translator\page.tsx
```tsx
'use client'

import { useSession } from 'next-auth/react'
import TranslatorView from '@/components/TranslatorView'
import { useProjects } from '@/hooks/useProjects'

export default function TranslatorDashboard() {
  const { data: session, status } = useSession()
  const { data: projects, isLoading: isLoadingProjects } = useProjects()

  if (status === 'loading' || isLoadingProjects) {
    return <div>Loading...</div>
  }

  return (
    <div className="min-h-screen bg-background">
      <TranslatorView projects={projects || []} />
    </div>
  )
} 
```

## File: app\allDashboards\translator\[projectId]\page.tsx
```tsx
'use client'

import { useSession } from 'next-auth/react'
import { useRouter } from 'next/navigation'
import { useDialogues } from '@/hooks/useDialogues'
import TranslatorDialogueView from '../../../../components/TranslatorDialogueView'

export default function TranslatorProjectPage({
  params,
}: {
  params: { projectId: string }
}) {
  const { status } = useSession()
  const router = useRouter()
  const { data: dialogues, isLoading } = useDialogues(params.projectId)

  if (status === 'loading' || isLoading) {
    return (
      <div className="min-h-screen flex items-center justify-center p-4">
        <div className="text-center">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary mx-auto"></div>
          <p className="mt-2 text-foreground">Loading...</p>
        </div>
      </div>
    )
  }

  return (
    <div className="min-h-screen bg-background">
      <div className="w-full max-w-7xl mx-auto py-4 sm:py-6">
        <div className="flex justify-between items-center mb-4 sm:mb-6 px-4">
          <button
            onClick={() => router.push('/allDashboards/translator')}
            className="text-primary hover:text-primary/80 transition-colors text-sm sm:text-base"
          >
            ← Back to Projects
          </button>
        </div>
        <TranslatorDialogueView dialogues={dialogues || []} projectId={params.projectId} />
      </div>
    </div>
  )
} 
```

## File: app\allDashboards\voice-over\page.tsx
```tsx
'use client'

import { useSession } from 'next-auth/react'
import VoiceOverView from '@/components/VoiceOverView'
import { useProjects } from '@/hooks/useProjects'

export default function VoiceOverDashboard() {
  const { data: session, status } = useSession()
  const { data: projects, isLoading: isLoadingProjects } = useProjects()

  if (status === 'loading' || isLoadingProjects) {
    return <div>Loading...</div>
  }

  return (
    <div className="min-h-screen bg-background">
      <VoiceOverView projects={projects || []} />
    </div>
  )
} 
```

## File: app\allDashboards\voice-over\[projectId]\page.tsx
```tsx
'use client'

import { useSession } from 'next-auth/react'
import { useRouter } from 'next/navigation'
import { useDialogues } from '@/hooks/useDialogues'
import VoiceOverDialogueView from '../../../../components/VoiceOverDialogueView'

export default function VoiceOverProjectPage({
  params,
}: {
  params: { projectId: string }
}) {
  const { status } = useSession()
  const router = useRouter()
  const { data: dialogues, isLoading } = useDialogues(params.projectId)

  if (status === 'loading' || isLoading) {
    return (
      <div className="min-h-screen flex items-center justify-center p-4">
        <div className="text-center">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary mx-auto"></div>
          <p className="mt-2 text-foreground">Loading...</p>
        </div>
      </div>
    )
  }

  return (
    <div className="min-h-screen bg-background">
      <div className="w-full max-w-7xl mx-auto py-4 sm:py-6">
        <div className="flex justify-between items-center mb-4 sm:mb-6 px-4">
          <button
            onClick={() => router.push('/allDashboards/voice-over')}
            className="text-primary hover:text-primary/80 transition-colors text-sm sm:text-base"
          >
            ← Back to Projects
          </button>
        </div>
        <VoiceOverDialogueView dialogues={dialogues || []} projectId={params.projectId} />
      </div>
    </div>
  )
} 
```

## File: app\api\admin\projects\route.ts
```ts
import { NextResponse } from 'next/server';
import { connectToDatabase } from '@/lib/mongodb';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

// GET all projects
export async function GET() {
  try {
    const session = await getServerSession(authOptions);
    
    // Check if user is authenticated and is an admin
    if (!session || session.user.role !== 'admin') {
      return NextResponse.json(
        { error: 'Unauthorized access' },
        { status: 401 }
      );
    }

    const { db } = await connectToDatabase();
    const projects = await db.collection('projects')
      .find({})
      .sort({ updatedAt: -1 })
      .toArray();

    return NextResponse.json({ success: true, data: projects });
  } catch (error) {
    console.error('Error fetching projects:', error);
    return NextResponse.json(
      { error: 'Failed to fetch projects' },
      { status: 500 }
    );
  }
}

// POST create new project
export async function POST(request: Request) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session || session.user.role !== 'admin') {
      return NextResponse.json(
        { error: 'Unauthorized access' },
        { status: 401 }
      );
    }

    const body = await request.json();
    const { title, description, sourceLanguage, targetLanguage, dialogue_collection } = body;

    // Validate required fields
    if (!title || !description || !sourceLanguage || !targetLanguage || !dialogue_collection) {
      return NextResponse.json(
        { error: 'Missing required fields' },
        { status: 400 }
      );
    }

    const { db } = await connectToDatabase();
    
    // Create a new collection for dialogues
    try {
      await db.createCollection(dialogue_collection);
      console.log(`Created new collection: ${dialogue_collection}`);
    } catch (error: any) {
      // If collection already exists, continue
      if (error.code !== 48) { // 48 is MongoDB's error code for "collection already exists"
        throw error;
      }
    }
    
    const newProject = {
      title,
      description,
      sourceLanguage,
      targetLanguage,
      dialogue_collection,
      status: 'pending',
      assignedTo: [],
      videoPath: `${title}/videos/`,  // Default video path structure
      updatedAt: new Date(),
      createdAt: new Date()
    };

    const result = await db.collection('projects').insertOne(newProject);

    return NextResponse.json({
      success: true,
      data: { ...newProject, _id: result.insertedId }
    });
  } catch (error) {
    console.error('Error creating project:', error);
    return NextResponse.json(
      { error: 'Failed to create project' },
      { status: 500 }
    );
  }
} 
```

## File: app\api\admin\projects\[projectId]\assign\route.ts
```ts
import { NextResponse } from 'next/server';
import { connectToDatabase } from '@/lib/mongodb';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { ObjectId, Document } from 'mongodb';

// POST assign users to project
export async function POST(
  request: Request,
  { params }: { params: { projectId: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session || session.user.role !== 'admin') {
      return NextResponse.json(
        { error: 'Unauthorized access' },
        { status: 401 }
      );
    }

    const body = await request.json();
    const { usernames } = body;

    if (!usernames || !Array.isArray(usernames)) {
      return NextResponse.json(
        { error: 'Invalid usernames' },
        { status: 400 }
      );
    }

    const { db } = await connectToDatabase();

    // Get users to assign by username
    const users = await db.collection('users')
      .find(
        { 
          username: { $in: usernames },
          isActive: true 
        },
        { projection: { username: 1, email: 1, role: 1 } }
      )
      .toArray();

    console.log('Users to assign:', users);
    console.log('Mapped users for assignment:', users.map(user => ({
      username: user.username,
      role: user.role
    })));

    if (users.length !== usernames.length) {
      return NextResponse.json(
        { error: 'One or more users not found or inactive' },
        { status: 400 }
      );
    }

    // Update project with assigned users
    const result = await db.collection('projects').updateOne(
      { _id: new ObjectId(params.projectId) },
      { 
        $set: { 
          assignedTo: users.map(user => ({
            username: user.username,
            role: user.role
          })),
          updatedAt: new Date()
        }
      }
    );

    if (result.matchedCount === 0) {
      return NextResponse.json(
        { error: 'Project not found' },
        { status: 404 }
      );
    }

    return NextResponse.json({
      success: true,
      message: 'Users assigned successfully',
      data: { assignedUsers: users }
    });
  } catch (error) {
    console.error('Error assigning users:', error);
    return NextResponse.json(
      { error: 'Failed to assign users' },
      { status: 500 }
    );
  }
}

// DELETE remove users from project
export async function DELETE(
  request: Request,
  { params }: { params: { projectId: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session || session.user.role !== 'admin') {
      return NextResponse.json(
        { error: 'Unauthorized access' },
        { status: 401 }
      );
    }

    const body = await request.json();
    const { usernames } = body;

    if (!usernames || !Array.isArray(usernames)) {
      return NextResponse.json(
        { error: 'Invalid usernames' },
        { status: 400 }
      );
    }

    const { db } = await connectToDatabase();

    // First get the project
    const project = await db.collection('projects').findOne(
      { _id: new ObjectId(params.projectId) }
    );

    if (!project) {
      return NextResponse.json(
        { error: 'Project not found' },
        { status: 404 }
      );
    }

    // Filter out the users to remove
    const updatedAssignedTo = project.assignedTo.filter(
      (user: { username: string }) => !usernames.includes(user.username)
    );

    console.log('Original assigned users:', project.assignedTo);
    console.log('Usernames to remove:', usernames);
    console.log('Updated assigned users:', updatedAssignedTo);

    // Update the project with the filtered users
    const result = await db.collection('projects').updateOne(
      { _id: new ObjectId(params.projectId) },
      { 
        $set: { 
          assignedTo: updatedAssignedTo,
          updatedAt: new Date()
        }
      }
    );

    if (result.matchedCount === 0) {
      return NextResponse.json(
        { error: 'Project not found' },
        { status: 404 }
      );
    }

    return NextResponse.json({
      success: true,
      message: 'Users removed successfully'
    });
  } catch (error) {
    console.error('Error removing users:', error);
    return NextResponse.json(
      { error: 'Failed to remove users' },
      { status: 500 }
    );
  }
} 
```

## File: app\api\admin\projects\[projectId]\progress\route.ts
```ts
import { NextResponse } from 'next/server';
import { connectToDatabase } from '@/lib/mongodb';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { ObjectId } from 'mongodb';

export async function GET(
  request: Request,
  { params }: { params: { projectId: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session || session.user.role !== 'admin') {
      return NextResponse.json(
        { error: 'Unauthorized access' },
        { status: 401 }
      );
    }

    const { db } = await connectToDatabase();
    
    // Get project to verify collection name
    const project = await db.collection('projects').findOne({
      _id: new ObjectId(params.projectId)
    });

    if (!project) {
      return NextResponse.json(
        { error: 'Project not found' },
        { status: 404 }
      );
    }

    // Get dialogues from the project's collection
    const dialogues = await db.collection(project.dialogue_collection)
      .find({ projectId: new ObjectId(params.projectId) })
      .toArray();

    const total = dialogues.length;
    
    // Calculate progress statistics
    const stats = dialogues.reduce((acc, dialogue) => {
      if (dialogue.dialogue?.original) acc.transcribed++;
      if (dialogue.dialogue?.translated) acc.translated++;
      if (dialogue.voiceOverUrl) acc.voiceOver++;
      if (dialogue.status === 'approved') acc.approved++;
      return acc;
    }, {
      transcribed: 0,
      translated: 0,
      voiceOver: 0,
      approved: 0
    });

    // Convert to percentages
    const progress = {
      transcribed: total > 0 ? Math.round((stats.transcribed / total) * 100) : 0,
      translated: total > 0 ? Math.round((stats.translated / total) * 100) : 0,
      voiceOver: total > 0 ? Math.round((stats.voiceOver / total) * 100) : 0,
      approved: total > 0 ? Math.round((stats.approved / total) * 100) : 0,
      total,
      lastUpdated: project.updatedAt
    };

    return NextResponse.json({
      success: true,
      data: progress
    });
  } catch (error) {
    console.error('Error fetching project progress:', error);
    return NextResponse.json(
      { error: 'Failed to fetch project progress' },
      { status: 500 }
    );
  }
} 
```

## File: app\api\admin\projects\[projectId]\route.ts
```ts
import { NextResponse } from 'next/server';
import { connectToDatabase } from '@/lib/mongodb';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { ObjectId } from 'mongodb';

// GET single project
export async function GET(
  request: Request,
  { params }: { params: { projectId: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session || session.user.role !== 'admin') {
      return NextResponse.json(
        { error: 'Unauthorized access' },
        { status: 401 }
      );
    }

    const { db } = await connectToDatabase();
    const project = await db.collection('projects').findOne({
      _id: new ObjectId(params.projectId)
    });

    if (!project) {
      return NextResponse.json(
        { error: 'Project not found' },
        { status: 404 }
      );
    }

    return NextResponse.json({ success: true, data: project });
  } catch (error) {
    console.error('Error fetching project:', error);
    return NextResponse.json(
      { error: 'Failed to fetch project' },
      { status: 500 }
    );
  }
}

// PATCH update project
export async function PATCH(
  request: Request,
  { params }: { params: { projectId: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session || session.user.role !== 'admin') {
      return NextResponse.json(
        { error: 'Unauthorized access' },
        { status: 401 }
      );
    }

    const body = await request.json();
    const updateData = {
      ...body,
      updatedAt: new Date()
    };

    const { db } = await connectToDatabase();
    const result = await db.collection('projects').updateOne(
      { _id: new ObjectId(params.projectId) },
      { $set: updateData }
    );

    if (result.matchedCount === 0) {
      return NextResponse.json(
        { error: 'Project not found' },
        { status: 404 }
      );
    }

    return NextResponse.json({
      success: true,
      message: 'Project updated successfully'
    });
  } catch (error) {
    console.error('Error updating project:', error);
    return NextResponse.json(
      { error: 'Failed to update project' },
      { status: 500 }
    );
  }
}

// DELETE project
export async function DELETE(
  request: Request,
  { params }: { params: { projectId: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session || session.user.role !== 'admin') {
      return NextResponse.json(
        { error: 'Unauthorized access' },
        { status: 401 }
      );
    }

    const { db } = await connectToDatabase();
    const result = await db.collection('projects').deleteOne({
      _id: new ObjectId(params.projectId)
    });

    if (result.deletedCount === 0) {
      return NextResponse.json(
        { error: 'Project not found' },
        { status: 404 }
      );
    }

    return NextResponse.json({
      success: true,
      message: 'Project deleted successfully'
    });
  } catch (error) {
    console.error('Error deleting project:', error);
    return NextResponse.json(
      { error: 'Failed to delete project' },
      { status: 500 }
    );
  }
} 
```

## File: app\api\admin\users\route.ts
```ts
import { NextResponse } from 'next/server';
import { connectToDatabase } from '@/lib/mongodb';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { hash } from 'bcryptjs';

// GET all users
export async function GET() {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session || session.user.role !== 'admin') {
      return NextResponse.json(
        { error: 'Unauthorized access' },
        { status: 401 }
      );
    }

    const { db } = await connectToDatabase();
    const users = await db.collection('users')
      .find({})
      .project({ password: 0 }) // Exclude password field
      .sort({ createdAt: -1 })
      .toArray();

    return NextResponse.json({ success: true, data: users });
  } catch (error) {
    console.error('Error fetching users:', error);
    return NextResponse.json(
      { error: 'Failed to fetch users' },
      { status: 500 }
    );
  }
}

// POST create new user
export async function POST(request: Request) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session || session.user.role !== 'admin') {
      return NextResponse.json(
        { error: 'Unauthorized access' },
        { status: 401 }
      );
    }

    const body = await request.json();
    const { username, email, password, role } = body;

    // Validate required fields
    if (!username || !email || !password || !role) {
      return NextResponse.json(
        { error: 'Missing required fields' },
        { status: 400 }
      );
    }

    const { db } = await connectToDatabase();
    
    // Check if user already exists
    const existingUser = await db.collection('users').findOne({
      $or: [{ email }, { username }]
    });

    if (existingUser) {
      return NextResponse.json(
        { error: 'User with this email or username already exists' },
        { status: 400 }
      );
    }

    // Hash password
    const hashedPassword = await hash(password, 12);

    const newUser = {
      username,
      email,
      password: hashedPassword,
      role,
      isActive: true,
      createdAt: new Date(),
      updatedAt: new Date(),
      createdBy: session.user.id
    };

    const result = await db.collection('users').insertOne(newUser);

    // Remove password from response
    const { password: _, ...userWithoutPassword } = newUser;

    return NextResponse.json({
      success: true,
      data: { ...userWithoutPassword, _id: result.insertedId }
    });
  } catch (error) {
    console.error('Error creating user:', error);
    return NextResponse.json(
      { error: 'Failed to create user' },
      { status: 500 }
    );
  }
} 
```

## File: app\api\admin\users\[userId]\route.ts
```ts
import { NextResponse } from 'next/server';
import { connectToDatabase } from '@/lib/mongodb';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { ObjectId } from 'mongodb';

// GET single user
export async function GET(
  request: Request,
  { params }: { params: { userId: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session || session.user.role !== 'admin') {
      return NextResponse.json(
        { error: 'Unauthorized access' },
        { status: 401 }
      );
    }

    const { db } = await connectToDatabase();
    const user = await db.collection('users').findOne(
      { _id: new ObjectId(params.userId) },
      { projection: { password: 0 } }
    );

    if (!user) {
      return NextResponse.json(
        { error: 'User not found' },
        { status: 404 }
      );
    }

    // Get assigned projects
    const assignedProjects = await db.collection('projects')
      .find({ 'assignedTo._id': params.userId })
      .toArray();

    return NextResponse.json({
      success: true,
      data: { ...user, assignedProjects }
    });
  } catch (error) {
    console.error('Error fetching user:', error);
    return NextResponse.json(
      { error: 'Failed to fetch user' },
      { status: 500 }
    );
  }
}

// PATCH update user
export async function PATCH(
  request: Request,
  { params }: { params: { userId: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session || session.user.role !== 'admin') {
      return NextResponse.json(
        { error: 'Unauthorized access' },
        { status: 401 }
      );
    }

    const body = await request.json();
    const updateData = {
      ...body,
      updatedAt: new Date()
    };

    // Remove password if it's empty
    if (updateData.password === '') {
      delete updateData.password;
    } else if (updateData.password) {
      updateData.password = await hash(updateData.password, 12);
    }

    const { db } = await connectToDatabase();
    const result = await db.collection('users').updateOne(
      { _id: new ObjectId(params.userId) },
      { $set: updateData }
    );

    if (result.matchedCount === 0) {
      return NextResponse.json(
        { error: 'User not found' },
        { status: 404 }
      );
    }

    return NextResponse.json({
      success: true,
      message: 'User updated successfully'
    });
  } catch (error) {
    console.error('Error updating user:', error);
    return NextResponse.json(
      { error: 'Failed to update user' },
      { status: 500 }
    );
  }
}

// DELETE user
export async function DELETE(
  request: Request,
  { params }: { params: { userId: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session || session.user.role !== 'admin') {
      return NextResponse.json(
        { error: 'Unauthorized access' },
        { status: 401 }
      );
    }

    const { db } = await connectToDatabase();
    
    // Remove user from all assigned projects
    await db.collection('projects').updateMany(
      { 'assignedTo._id': params.userId },
      { $pull: { assignedTo: { _id: params.userId } } }
    );

    // Delete the user
    const result = await db.collection('users').deleteOne({
      _id: new ObjectId(params.userId)
    });

    if (result.deletedCount === 0) {
      return NextResponse.json(
        { error: 'User not found' },
        { status: 404 }
      );
    }

    return NextResponse.json({
      success: true,
      message: 'User deleted successfully'
    });
  } catch (error) {
    console.error('Error deleting user:', error);
    return NextResponse.json(
      { error: 'Failed to delete user' },
      { status: 500 }
    );
  }
} 
```

## File: app\api\auth\auth.config.ts
```ts
import CredentialsProvider from 'next-auth/providers/credentials'
import { connectToDatabase } from '@/lib/mongodb'
import bcrypt from 'bcryptjs'
import type { NextAuthOptions } from 'next-auth'

if (!process.env.NEXTAUTH_SECRET) {
  throw new Error('Please define the NEXTAUTH_SECRET environment variable')
}

export const authOptions: NextAuthOptions = {
  providers: [
    CredentialsProvider({
      name: 'Credentials',
      credentials: {
        email: { label: "Email", type: "email" },
        password: { label: "Password", type: "password" }
      },
      async authorize(credentials, req) {
        if (!credentials?.email || !credentials?.password) {
          throw new Error('Please enter your email and password')
        }

        try {
          const { db } = await connectToDatabase()
          const user = await db.collection('users').findOne({ 
            email: credentials.email 
          })

          if (!user) {
            throw new Error('Invalid email or password')
          }

          const isPasswordValid = await bcrypt.compare(
            credentials.password,
            user.password
          )

          if (!isPasswordValid) {
            throw new Error('Invalid email or password')
          }

          // Update last login and sessions log
          const sessionLog = {
            loginTime: new Date(),
            userAgent: req.headers?.['user-agent'] || 'unknown'
          }

          await db.collection('users').updateOne(
            { _id: user._id },
            {
              $set: { 
                lastLogin: new Date(),
                'sessionsLog.0': sessionLog
              }
            }
          )

          return {
            id: user._id.toString(),
            email: user.email,
            role: user.role,
            username: user.username,
            name: user.username
          }
        } catch (error) {
          console.error('Authentication error:', error)
          throw error
        }
      }
    })
  ],
  callbacks: {
    async jwt({ token, user }) {
      if (user) {
        token.id = user.id
        token.email = user.email
        token.role = user.role
        token.username = user.username
      }
      return token
    },
    async session({ session, token }) {
      if (token && session.user) {
        session.user.id = token.id as string
        session.user.email = token.email as string
        session.user.role = token.role as string
        session.user.username = token.username as string
        session.user.name = token.name as string
      }
      return session
    }
  },
  pages: {
    signIn: '/login',
  },
  session: {
    strategy: 'jwt',
    maxAge: 30 * 24 * 60 * 60, // 30 days
  },
  secret: process.env.NEXTAUTH_SECRET,
  debug: process.env.NODE_ENV === 'development',
} 
```

## File: app\api\auth\login\route.ts
```ts
import { NextResponse } from 'next/server'
import { connectToDatabase } from '@/lib/mongodb'
import bcrypt from 'bcryptjs'
import { sign } from 'jsonwebtoken'

const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key'

export async function POST(req: Request) {
  try {
    const { email, password } = await req.json()

    const { db } = await connectToDatabase()
    const user = await db.collection('users').findOne({ email })

    if (!user) {
      return NextResponse.json(
        { error: 'Invalid credentials' },
        { status: 401 }
      )
    }

    const isPasswordValid = await bcrypt.compare(password, user.password)
    if (!isPasswordValid) {
      return NextResponse.json(
        { error: 'Invalid credentials' },
        { status: 401 }
      )
    }

    // Update last login and sessions log
    const sessionLog = {
      loginTime: new Date(),
      userAgent: req.headers.get('user-agent') || 'unknown'
    }

    await db.collection('users').updateOne(
      { _id: user._id },
      { 
        $set: { 
          lastLogin: new Date(),
          sessionsLog: [sessionLog, ...(user.sessionsLog || [])]
        }
      }
    )

    // Create token
    const token = sign(
      {
        id: user._id.toString(),
        email: user.email,
        role: user.role,
        username: user.username
      },
      JWT_SECRET,
      { expiresIn: '1d' }
    )

    return NextResponse.json({
      token,
      user: {
        id: user._id.toString(),
        email: user.email,
        role: user.role,
        username: user.username
      }
    })
  } catch (error) {
    console.error('Login error:', error)
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
} 
```

## File: app\api\auth\[...nextauth]\route.ts
```ts
import NextAuth from 'next-auth'
import { authOptions } from '../auth.config'

const handler = NextAuth(authOptions)

export { handler as GET, handler as POST }


```

## File: app\api\dialogues\route.ts
```ts
import { NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { connectToDatabase } from '@/lib/mongodb'
import { ObjectId } from 'mongodb'
import { authOptions } from '../../../lib/auth'

export async function GET(request: Request) {
  console.log('=== API Dialogues Route Debug ===');
  
  try {
    // Check authentication
    const session = await getServerSession(authOptions);
    if (!session) {
      console.log('No session found');
      return new NextResponse(
        JSON.stringify({ error: 'Authentication required' }),
        { status: 401 }
      );
    }

    // Get query parameters
    const { searchParams } = new URL(request.url);
    const projectId = searchParams.get('projectId');
    const collection = searchParams.get('collection');

    console.log('Query params:', { projectId, collection });

    if (!projectId) {
      console.log('No projectId provided');
      return new NextResponse(
        JSON.stringify({ error: 'Project ID is required' }),
        { status: 400 }
      );
    }

    // Validate projectId format
    if (!ObjectId.isValid(projectId)) {
      console.log('Invalid projectId format');
      return new NextResponse(
        JSON.stringify({ error: 'Invalid project ID format' }),
        { status: 400 }
      );
    }

    // Connect to database
    const { db } = await connectToDatabase();
    console.log('Connected to database');

    // Get project to verify collection name
    const project = await db.collection('projects').findOne({
      _id: new ObjectId(projectId)
    });

    if (!project) {
      console.log('Project not found');
      return new NextResponse(
        JSON.stringify({ error: 'Project not found' }),
        { status: 404 }
      );
    }

    // Determine collection name from project
    const collectionName = project.dialogue_collection || collection || 'dialogues';
    console.log('Using collection:', collectionName);

    // Fetch dialogues
    const dialogues = await db.collection(collectionName)
      .find({ projectId: new ObjectId(projectId) })
      .sort({ timeStart: 1 })
      .toArray();

    // Transform ObjectIds to strings for JSON serialization
    const serializedDialogues = dialogues.map(dialogue => ({
      ...dialogue,
      _id: dialogue._id.toString(),
      projectId: dialogue.projectId.toString()
    }));

    console.log(`Found ${dialogues.length} dialogues`);
    console.log('=== End Debug ===');

    return new NextResponse(
      JSON.stringify({ 
        data: serializedDialogues,
        collection: collectionName,
        project: {
          title: project.title,
          sourceLanguage: project.sourceLanguage,
          targetLanguage: project.targetLanguage
        }
      }),
      { status: 200 }
    );

  } catch (error) {
    console.error('Error in dialogues route:', error);
    return new NextResponse(
      JSON.stringify({ error: 'Internal server error' }),
      { status: 500 }
    );
  }
}

export async function POST(request: Request) {
  console.log('\n=== POST /api/dialogues - Started ===')
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user) {
      console.error('Unauthorized access attempt to create dialogue')
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const data = await request.json()
    const { projectId, dialogue, collection } = data

    console.log('Creating dialogue:', {
      projectId,
      collection,
      dialoguePreview: dialogue ? {
        timeStart: dialogue.timeStart,
        timeEnd: dialogue.timeEnd,
        character: dialogue.character
      } : 'none'
    })

    if (!projectId || !dialogue) {
      console.error('Missing required fields')
      return NextResponse.json({ error: 'Missing required fields' }, { status: 400 })
    }

    console.log('Connecting to database...')
    const { db } = await connectToDatabase()

    // Get project to verify collection name
    const project = await db.collection('projects').findOne({
      _id: new ObjectId(projectId)
    })

    if (!project) {
      console.error('Project not found:', projectId)
      return NextResponse.json({ error: 'Project not found' }, { status: 404 })
    }

    // Use the collection from request, project, or default
    const dialogueCollection = collection || project.dialogue_collection || 'dialogues'

    console.log('Using collection:', dialogueCollection)

    // Get the next index
    const lastDialogue = await db.collection(dialogueCollection)
      .findOne({ projectId: new ObjectId(projectId) }, { sort: { index: -1 } })
    
    const nextIndex = (lastDialogue?.index || 0) + 1

    const newDialogue = {
      ...dialogue,
      projectId: new ObjectId(projectId),
      index: nextIndex,
      status: 'pending',
      createdAt: new Date(),
      updatedAt: new Date(),
      createdBy: session.user.username
    }

    console.log('Creating new dialogue:', {
      collection: dialogueCollection,
      index: nextIndex,
      projectId
    })

    const result = await db.collection(dialogueCollection).insertOne(newDialogue)

    const response = {
      ...newDialogue,
      _id: result.insertedId.toString(),
      projectId: projectId
    }

    console.log('=== POST /api/dialogues - Completed ===\n')
    return NextResponse.json(response)
  } catch (error) {
    console.error('Error creating dialogue:', error)
    return NextResponse.json(
      { error: 'Failed to create dialogue' },
      { status: 500 }
    )
  }
}


```

## File: app\api\dialogues\[id]\route.ts
```ts
import { NextResponse } from 'next/server'
import { connectToDatabase } from '@/lib/mongodb'
import { ObjectId } from 'mongodb'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/app/api/auth/auth.config'

export async function GET(
  request: Request,
  { params }: { params: { id: string } }
) {
  console.log('GET /api/dialogues/[id] - Started', { id: params.id })
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user) {
      console.error('Unauthorized access attempt to dialogue')
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    if (!ObjectId.isValid(params.id)) {
      console.error('Invalid dialogue ID format:', params.id)
      return NextResponse.json({ error: 'Invalid dialogue ID format' }, { status: 400 })
    }

    console.log('Connecting to database...')
    const { db } = await connectToDatabase()

    // First try to find the dialogue in any collection by checking project's dialogue_collection
    let dialogue = null;

    // Try to find the dialogue in any collection by checking all projects
    const projects = await db.collection('projects').find().toArray();
    
    for (const project of projects) {
      if (project.dialogue_collection) {
        const tempDialogue = await db.collection(project.dialogue_collection).findOne({
          _id: new ObjectId(params.id)
        });
        if (tempDialogue) {
          dialogue = tempDialogue;
          break;
        }
      }
    }

    // If still not found, try the default collection
    if (!dialogue) {
      dialogue = await db.collection('dialogues').findOne({
        _id: new ObjectId(params.id)
      });
    }

    if (!dialogue) {
      console.error('Dialogue not found:', params.id)
      return NextResponse.json({ error: 'Dialogue not found' }, { status: 404 })
    }

    // Check project access
    const project = await db.collection('projects').findOne({
      _id: new ObjectId(dialogue.projectId),
      'assignedTo': {
        $elemMatch: {
          username: session.user.username
        }
      }
    })

    if (!project) {
      console.error('User not authorized for this dialogue')
      return NextResponse.json({ error: 'Not authorized' }, { status: 403 })
    }

    // Transform ObjectIds to strings
    const serializedDialogue = {
      ...dialogue,
      _id: dialogue._id.toString(),
      projectId: dialogue.projectId.toString()
    }

    return NextResponse.json(serializedDialogue)
  } catch (error) {
    console.error('Error fetching dialogue:', error)
    return NextResponse.json(
      { error: 'Failed to fetch dialogue' },
      { status: 500 }
    )
  }
}

export async function PUT(
  request: Request,
  { params }: { params: { id: string } }
) {
  console.log('PUT /api/dialogues/[id] - Started', { id: params.id })
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user) {
      console.error('Unauthorized access attempt to update dialogue')
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    if (!ObjectId.isValid(params.id)) {
      console.error('Invalid dialogue ID format:', params.id)
      return NextResponse.json({ error: 'Invalid dialogue ID format' }, { status: 400 })
    }

    const updates = await request.json()
    console.log('Requested updates:', updates)

    // Handle voice-over deletion
    if (updates.deleteVoiceOver) {
      console.log('Deleting voice-over for dialogue:', params.id);
      updates.voiceOverUrl = null;
      updates.status = 'pending';
    }
    // Validate voiceOverUrl if status is voice-over-added
    else if (updates.status === 'voice-over-added' && !updates.voiceOverUrl) {
      console.error('Missing voiceOverUrl for voice-over-added status');
      return NextResponse.json(
        { error: 'Voice-over URL is required when status is voice-over-added' },
        { status: 400 }
      );
    }

    console.log('Connecting to database...')
    const { db } = await connectToDatabase()

    // First try to find the dialogue in any collection by checking project's dialogue_collection
    let dialogue = null;
    let dialogueCollection = 'dialogues';

    // Try to find the dialogue in any collection by checking all projects
    const projects = await db.collection('projects').find().toArray();
    
    for (const project of projects) {
      if (project.dialogue_collection) {
        const tempDialogue = await db.collection(project.dialogue_collection).findOne({
          _id: new ObjectId(params.id)
        });
        if (tempDialogue) {
          dialogue = tempDialogue;
          dialogueCollection = project.dialogue_collection;
          break;
        }
      }
    }

    // If still not found, try the default collection
    if (!dialogue) {
      dialogue = await db.collection('dialogues').findOne({
        _id: new ObjectId(params.id)
      });
    }

    if (!dialogue) {
      console.error('Dialogue not found:', params.id)
      return NextResponse.json({ error: 'Dialogue not found' }, { status: 404 })
    }

    // Check project access
    const project = await db.collection('projects').findOne({
      _id: new ObjectId(dialogue.projectId),
      'assignedTo': {
        $elemMatch: {
          username: session.user.username,
          role: { $in: ['transcriber', 'voice-over'] }
        }
      }
    })

    if (!project) {
      console.error('User not authorized to update this dialogue:', {
        username: session.user.username,
        dialogueId: params.id,
        projectId: dialogue.projectId
      })
      return NextResponse.json({ error: 'Not authorized' }, { status: 403 })
    }

    // Prepare update data
    const updateData = {
      ...updates,
      updatedAt: new Date(),
      updatedBy: session.user.username
    }

    // Don't allow updating certain fields
    delete updateData._id
    delete updateData.projectId
    delete updateData.createdAt
    delete updateData.createdBy

    console.log('Applying updates:', updateData)
    const result = await db.collection(dialogueCollection).findOneAndUpdate(
      { _id: new ObjectId(params.id) },
      { $set: updateData },
      { returnDocument: 'after' }
    )

    if (!result) {
      console.error('Failed to update dialogue:', {
        id: params.id,
        collection: dialogueCollection,
        updateData
      });
      return NextResponse.json({ error: 'Failed to update dialogue' }, { status: 500 })
    }

    console.log('Update successful:', {
      id: params.id,
      collection: dialogueCollection,
      status: result.status,
      voiceOverUrl: result.voiceOverUrl
    });

    // Transform ObjectIds to strings
    const serializedDialogue = {
      ...result,
      _id: result._id.toString(),
      projectId: result.projectId.toString()
    }

    return NextResponse.json(serializedDialogue)
  } catch (error) {
    console.error('Error updating dialogue:', error)
    return NextResponse.json(
      { error: 'Failed to update dialogue' },
      { status: 500 }
    )
  }
}

export async function PATCH(
  request: Request,
  { params }: { params: { id: string } }
) {
  console.log('=== PATCH /api/dialogues/[id] Debug ===');
  try {
    // Check authentication
    const session = await getServerSession(authOptions);
    if (!session) {
      console.log('Authentication failed: No session');
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    const { db } = await connectToDatabase();
    const data = await request.json();
    const dialogueId = params.id;

    console.log('Request data:', {
      dialogueId,
      data,
      userEmail: session.user?.email
    });

    // Validate required fields
    if (!data.dialogue || !data.projectId) {
      console.log('Validation failed:', { 
        hasDialogue: !!data.dialogue, 
        hasProjectId: !!data.projectId 
      });
      return NextResponse.json({ error: 'Missing required fields' }, { status: 400 });
    }

    // First try to find the dialogue
    let dialogue = null;
    let dialogueCollection = 'dialogues';

    console.log('Searching for dialogue in collections...');
    
    // Try to find the dialogue in any collection by checking all projects
    const projects = await db.collection('projects').find().toArray();
    
    for (const project of projects) {
      if (project.dialogue_collection) {
        console.log('Checking collection:', project.dialogue_collection);
        const tempDialogue = await db.collection(project.dialogue_collection).findOne({
          _id: new ObjectId(dialogueId)
        });
        if (tempDialogue) {
          dialogue = tempDialogue;
          dialogueCollection = project.dialogue_collection;
          console.log('Found dialogue in collection:', dialogueCollection);
          break;
        }
      }
    }

    // If still not found, try the default collection
    if (!dialogue) {
      dialogue = await db.collection('dialogues').findOne({
        _id: new ObjectId(dialogueId)
      });
      console.log('Dialogue search result:', { found: !!dialogue });
    }

    if (!dialogue) {
      console.log('Dialogue not found:', dialogueId);
      return NextResponse.json({ error: 'Dialogue not found' }, { status: 404 });
    }

    // Get project to verify access
    const project = await db.collection('projects').findOne({
      _id: new ObjectId(dialogue.projectId),
      'assignedTo': {
        $elemMatch: {
          username: session.user.username
        }
      }
    });

    console.log('Project access check:', {
      projectFound: !!project,
      username: session.user.username
    });

    if (!project) {
      return NextResponse.json({ error: 'Not authorized' }, { status: 403 });
    }

    // Prepare update data
    const updateData = {
      dialogue: data.dialogue,
      character: data.character,
      status: data.status,
      timeStart: data.timeStart,
      timeEnd: data.timeEnd,
      index: data.index,
      updatedAt: new Date(),
      updatedBy: session.user.email
    };

    // Update the dialogue in the correct collection
    const result = await db.collection(dialogueCollection).findOneAndUpdate(
      { _id: new ObjectId(dialogueId) },
      { $set: updateData },
      { returnDocument: 'after' }
    );

    if (!result) {
      return NextResponse.json(
        { error: 'Failed to update dialogue' },
        { status: 400 }
      );
    }

    // Transform ObjectIds to strings for response
    const serializedDialogue = {
      ...result,
      _id: result._id.toString(),
      projectId: result.projectId.toString()
    };

    return NextResponse.json(serializedDialogue);
  } catch (error) {
    console.error('Error updating dialogue:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}

export async function DELETE(
  request: Request,
  { params }: { params: { id: string } }
) {
  console.log('DELETE /api/dialogues/[id] - Started', { id: params.id })
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user) {
      console.error('Unauthorized access attempt to delete dialogue')
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    if (!ObjectId.isValid(params.id)) {
      console.error('Invalid dialogue ID format:', params.id)
      return NextResponse.json({ error: 'Invalid dialogue ID format' }, { status: 400 })
    }

    console.log('Connecting to database...')
    const { db } = await connectToDatabase()

    // First try to find the dialogue in any collection by checking project's dialogue_collection
    let dialogue = null;

    // Try to find the dialogue in any collection by checking all projects
    const projects = await db.collection('projects').find().toArray();
    
    for (const project of projects) {
      if (project.dialogue_collection) {
        const tempDialogue = await db.collection(project.dialogue_collection).findOne({
          _id: new ObjectId(params.id)
        });
        if (tempDialogue) {
          dialogue = tempDialogue;
          break;
        }
      }
    }

    // If still not found, try the default collection
    if (!dialogue) {
      dialogue = await db.collection('dialogues').findOne({
        _id: new ObjectId(params.id)
      });
    }

    if (!dialogue) {
      console.error('Dialogue not found:', params.id)
      return NextResponse.json({ error: 'Dialogue not found' }, { status: 404 })
    }

    // Check project access
    const project = await db.collection('projects').findOne({
      _id: new ObjectId(dialogue.projectId),
      'assignedTo': {
        $elemMatch: {
          username: session.user.username
        }
      }
    })

    if (!project) {
      console.error('User not authorized to delete this dialogue')
      return NextResponse.json({ error: 'Not authorized' }, { status: 403 })
    }

    console.log('Deleting dialogue:', params.id)
    const result = await db.collection('dialogues').deleteOne({
      _id: new ObjectId(params.id)
    })

    if (result.deletedCount === 0) {
      console.error('Failed to delete dialogue:', params.id)
      return NextResponse.json({ error: 'Failed to delete dialogue' }, { status: 500 })
    }

    return NextResponse.json({ success: true })
  } catch (error) {
    console.error('Error deleting dialogue:', error)
    return NextResponse.json(
      { error: 'Failed to delete dialogue' },
      { status: 500 }
    )
  }
} 
```

## File: app\api\projects\route.ts
```ts
import { NextResponse } from 'next/server'
import { connectToDatabase } from '@/lib/mongodb'

export async function GET() {
  try {
    const { db } = await connectToDatabase()
    console.log('Connected to database')
    const projects = await db.collection('projects').find({}).toArray()
    console.log('Found projects:', projects)
    return NextResponse.json(projects)
  } catch (error) {
    console.error('Failed to fetch projects:', error)
    return NextResponse.json({ error: 'Failed to fetch projects' }, { status: 500 })
  }
}

export async function POST(req: Request) {
  try {
    const { db } = await connectToDatabase()
    const projectData = await req.json()
    
    // Add assignedTo array if not present
    const projectToCreate = {
      ...projectData,
      assignedTo: [],
      createdAt: new Date(),
      updatedAt: new Date()
    }
    
    const result = await db.collection('projects').insertOne(projectToCreate)
    return NextResponse.json({ success: true, projectId: result.insertedId })
  } catch (error) {
    console.error('Failed to create project:', error)
    return NextResponse.json({ error: 'Failed to create project' }, { status: 500 })
  }
}


```

## File: app\api\projects\[id]\assign\route.ts
```ts
import { NextResponse } from 'next/server'
import { connectToDatabase } from '@/lib/mongodb'
import { ObjectId } from 'mongodb'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/app/api/auth/auth.config'

export async function POST(
  request: Request,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user || session.user.role !== 'admin') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { username, role } = await request.json()
    const projectId = params.id

    if (!username || !role || !projectId) {
      return NextResponse.json(
        { error: 'Missing required fields' },
        { status: 400 }
      )
    }

    const { db } = await connectToDatabase()

    // First get the current project to check if user is already assigned
    const project = await db.collection('projects').findOne({
      _id: new ObjectId(projectId)
    })

    if (!project) {
      return NextResponse.json(
        { error: 'Project not found' },
        { status: 404 }
      )
    }

    // Check if user is already assigned with the same role
    const isAlreadyAssigned = project.assignedTo?.some(
      (assignment: { username: string; role: string }) =>
        assignment.username === username && assignment.role === role
    )

    if (isAlreadyAssigned) {
      return NextResponse.json(
        { error: 'User is already assigned with this role' },
        { status: 400 }
      )
    }

    // Update the project with the new assignment
    const result = await db.collection('projects').findOneAndUpdate(
      { _id: new ObjectId(projectId) },
      {
        $addToSet: { 
          assignedTo: { username, role }
        },
        $set: { updatedAt: new Date() }
      },
      { returnDocument: 'after' }
    )

    if (!result) {
      return NextResponse.json(
        { error: 'Failed to update project' },
        { status: 500 }
      )
    }

    return NextResponse.json({
      message: 'User assigned successfully',
      project: {
        ...result,
        _id: result._id.toString()
      }
    })
  } catch (error) {
    console.error('Error assigning user to project:', error)
    return NextResponse.json(
      { error: 'Failed to assign user to project' },
      { status: 500 }
    )
  }
}


```

## File: app\api\upload-audio\route.ts
```ts
import { NextResponse } from 'next/server'
import { connectToDatabase } from '@/lib/mongodb'
import { ObjectId } from 'mongodb'
import { put } from '@vercel/blob'

export async function POST(req: Request) {
  try {
    const { db } = await connectToDatabase()
    const formData = await req.formData()
    const file = formData.get('audio') as File
    const dialogueId = formData.get('dialogueId') as string

    if (!file) {
      return NextResponse.json({ error: 'No file uploaded' }, { status: 400 })
    }

    const blob = await put(file.name, file, {
      access: 'public',
    })

    // Update the dialogue with the new audio URL
    await db.collection('dialogues').updateOne(
      { _id: new ObjectId(dialogueId) },
      { $set: { audioUrl: blob.url } }
    )

    return NextResponse.json({ success: true, url: blob.url })
  } catch (error) {
    console.error('Failed to upload audio:', error)
    return NextResponse.json({ error: 'Failed to upload audio' }, { status: 500 })
  }
}


```

## File: app\api\upload-voice-over\route.ts
```ts
import { NextResponse } from 'next/server';
import { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';
import { getServerSession } from 'next-auth';
import { authOptions } from '../auth/auth.config';
import { connectToDatabase } from '@/lib/mongodb';
import { ObjectId } from 'mongodb';

// Configure request size limit and parsing
export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';
export const maxDuration = 60;

const s3Client = new S3Client({
  region: 'auto',
  endpoint: process.env.R2_BUCKET_ENDPOINT,
  credentials: {
    accessKeyId: process.env.R2_ACCESS_KEY_ID!,
    secretAccessKey: process.env.R2_SECRET_ACCESS_KEY!,
  },
  forcePathStyle: true,
});

export async function POST(request: Request) {
  console.log('Upload voice-over API called');
  try {
    // Check authentication
    const session = await getServerSession(authOptions);
    if (!session) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    console.log('Session found:', session.user);
    const formData = await request.formData();
    const audio = formData.get('audio') as File;
    const dialogueId = formData.get('dialogueId') as string;
    const projectId = formData.get('projectId') as string;

    if (!audio || !dialogueId || !projectId) {
      console.error('Missing required fields:', { audio: !!audio, dialogueId, projectId });
      return NextResponse.json({ error: 'Missing required fields' }, { status: 400 });
    }

    // Get dialogue from database to ensure correct index
    const { db } = await connectToDatabase();
    
    // First try to find the dialogue in any collection by checking project's dialogue_collection
    let dialogue = null;
    let dialogueCollection = 'dialogues';

    // Try to find the dialogue in any collection by checking all projects
    const projects = await db.collection('projects').find().toArray();
    
    for (const project of projects) {
      if (project.dialogue_collection) {
        const tempDialogue = await db.collection(project.dialogue_collection).findOne({
          _id: new ObjectId(dialogueId)
        });
        if (tempDialogue) {
          dialogue = tempDialogue;
          dialogueCollection = project.dialogue_collection;
          break;
        }
      }
    }

    // If still not found, try the default collection
    if (!dialogue) {
      dialogue = await db.collection('dialogues').findOne({
        _id: new ObjectId(dialogueId)
      });
    }

    if (!dialogue) {
      console.error('Dialogue not found:', dialogueId);
      return NextResponse.json(
        { error: 'Dialogue not found' },
        { status: 404 }
      );
    }

    const project = await db.collection('projects').findOne({
      _id: new ObjectId(projectId)
    });

    if (!project) {
      console.error('Project not found:', projectId);
      return NextResponse.json(
        { error: 'Project not found' },
        { status: 404 }
      );
    }

    console.log('Project from DB:', project);
    console.log('Dialogue from DB:', dialogue);

    if (!project.title) {
      console.error('Project title is missing');
      return NextResponse.json(
        { error: 'Project title is missing' },
        { status: 400 }
      );
    }

    const folderPath = `${project.title}/recordings/`;
    // Use dialogue.index directly from the database
    const paddedIndex = dialogue.index.toString().padStart(2, '0');
    const filename = `${project.title}_Clip_${paddedIndex}.wav`;
    const fullPath = `${folderPath}${filename}`;

    // Convert File to Buffer
    const arrayBuffer = await audio.arrayBuffer();
    const buffer = Buffer.from(arrayBuffer);

    console.log('Upload details:', {
      folderPath,
      filename,
      fullPath,
      audioSize: buffer.length,
      contentType: audio.type
    });

    // Upload to R2
    const uploadParams = {
      Bucket: process.env.R2_BUCKET_NAME!,
      Key: fullPath,
      Body: buffer,
      ContentType: 'audio/wav',
    };

    await s3Client.send(new PutObjectCommand(uploadParams));

    // Generate public URL
    const publicUrl = `https://${process.env.R2_PUBLIC_URL}/${fullPath}`;

    return NextResponse.json({ url: publicUrl });
  } catch (error) {
    console.error('Error uploading voice-over:', error);
    return NextResponse.json(
      { error: 'Failed to upload voice-over' },
      { status: 500 }
    );
  }
} 
```

## File: app\api\users\me\route.ts
```ts
import { NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/app/api/auth/auth.config'

export async function GET() {
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }
    return NextResponse.json(session.user)
  } catch {
    return NextResponse.json(
      { error: 'Failed to fetch user data' },
      { status: 500 }
    )
  }
} 
```

## File: app\api\users\route.ts
```ts
import { NextResponse } from 'next/server'
import { connectToDatabase } from '@/lib/mongodb'
import { getServerSession } from 'next-auth'

// Configure route for dynamic rendering
export const dynamic = 'force-dynamic'
export const runtime = 'nodejs'

export async function GET() {
  try {
    const session = await getServerSession()
    if (!session) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { db } = await connectToDatabase()
    const users = await db.collection('users').find({}, {
      projection: {
        password: 0, // Exclude password from response
        lastLogin: 0,
        lastLogout: 0,
        sessionsLog: 0
      }
    }).toArray()

    return NextResponse.json(users)
  } catch (error) {
    console.error('Failed to fetch users:', error)
    return NextResponse.json({ error: 'Failed to fetch users' }, { status: 500 })
  }
} 
```

## File: app\api\voice-over\upload\route.ts
```ts
import { NextRequest, NextResponse } from 'next/server';
import { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/app/api/auth/auth.config';
import { connectToDatabase } from '@/lib/mongodb';
import { ObjectId } from 'mongodb';

// Configure request size limit and parsing
export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';
export const maxDuration = 60;

const s3Client = new S3Client({
  region: 'auto',
  endpoint: process.env.R2_BUCKET_ENDPOINT,
  credentials: {
    accessKeyId: process.env.R2_ACCESS_KEY_ID!,
    secretAccessKey: process.env.R2_SECRET_ACCESS_KEY!,
  },
  forcePathStyle: true,
});

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const formData = await request.formData();
    const file = formData.get('file') as File;
    if (!file) {
      return NextResponse.json({ error: 'No file uploaded' }, { status: 400 });
    }

    const objectId = new ObjectId();
    const key = `voiceovers/${objectId.toString()}`;

    const arrayBuffer = await file.arrayBuffer();
    const buffer = Buffer.from(arrayBuffer);

    const putObjectCommand = new PutObjectCommand({
      Bucket: process.env.R2_BUCKET_NAME!,
      Key: key,
      Body: buffer,
      ContentType: file.type,
    });

    await s3Client.send(putObjectCommand);
    
    const { db } = await connectToDatabase();
    const voiceover = {
      _id: objectId,
      key,
      userId: session.user.id,
      createdAt: new Date(),
    };
    await db.collection('voiceovers').insertOne(voiceover);

    const publicUrl = `https://${process.env.R2_PUBLIC_URL}/${key}`;
    return NextResponse.json({ url: publicUrl });
  } catch (error) {
    console.error('Error uploading file:', error);
    return NextResponse.json({ error: 'Failed to upload file' }, { status: 500 });
  }
} 
```

## File: app\components\Button.tsx
```tsx
'use client'

import React, { ButtonHTMLAttributes, useEffect } from 'react'
import { lightTheme, logThemeUsage } from '@/app/styles/theme'

interface ButtonProps extends ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'primary' | 'secondary' | 'danger' | 'success'
  size?: 'sm' | 'md' | 'lg'
}

const buttonStyles = {
  base: `
    inline-flex items-center justify-center
    border border-transparent
    rounded-${lightTheme.borderRadius.default}
    font-${lightTheme.typography.weights.medium}
    transition-all ${lightTheme.transitions.default}
    focus:outline-none focus:ring-2 focus:ring-offset-2
  `,
  variants: {
    primary: {
      bg: `bg-${lightTheme.colors.accent.primary} hover:bg-${lightTheme.colors.accent.hover}`,
      text: `text-${lightTheme.colors.background.primary}`,
      ring: `focus:ring-${lightTheme.colors.accent.focus}`
    },
    secondary: {
      bg: `bg-${lightTheme.colors.text.tertiary} hover:bg-${lightTheme.colors.text.secondary}`,
      text: `text-${lightTheme.colors.background.primary}`,
      ring: `focus:ring-${lightTheme.colors.text.secondary}`
    },
    danger: {
      bg: `bg-${lightTheme.colors.status.error} hover:bg-${lightTheme.colors.status.error}/90`,
      text: `text-${lightTheme.colors.background.primary}`,
      ring: `focus:ring-${lightTheme.colors.status.error}`
    },
    success: {
      bg: `bg-${lightTheme.colors.status.success} hover:bg-${lightTheme.colors.status.success}/90`,
      text: `text-${lightTheme.colors.background.primary}`,
      ring: `focus:ring-${lightTheme.colors.status.success}`
    }
  },
  sizes: {
    sm: `px-${lightTheme.spacing[2]} py-${lightTheme.spacing[1]} text-${lightTheme.typography.sizes.sm}`,
    md: `px-${lightTheme.spacing[4]} py-${lightTheme.spacing[2]} text-${lightTheme.typography.sizes.base}`,
    lg: `px-${lightTheme.spacing[6]} py-${lightTheme.spacing[3]} text-${lightTheme.typography.sizes.lg}`
  }
}

export default function Button({
  variant = 'primary',
  size = 'md',
  className = '',
  children,
  onClick,
  ...props
}: ButtonProps) {
  useEffect(() => {
    logThemeUsage('Button', {
      variant,
      size,
      appliedStyles: {
        base: buttonStyles.base,
        variant: buttonStyles.variants[variant],
        size: buttonStyles.sizes[size],
        custom: className
      }
    })
  }, [variant, size, className])

  const handleClick = (e: React.MouseEvent<HTMLButtonElement>) => {
    logThemeUsage('Button', {
      event: 'click',
      variant,
      size,
      styles: {
        variant: buttonStyles.variants[variant],
        size: buttonStyles.sizes[size]
      }
    })
    onClick?.(e)
  }

  const variantStyle = buttonStyles.variants[variant]
  const sizeStyle = buttonStyles.sizes[size]

  return (
    <button
      className={`
        ${buttonStyles.base}
        ${variantStyle.bg}
        ${variantStyle.text}
        ${variantStyle.ring}
        ${sizeStyle}
        ${className}
      `}
      onClick={handleClick}
      {...props}
    >
      {children}
    </button>
  )
} 
```

## File: app\components\Card.tsx
```tsx
'use client'

import React, { ReactNode, useEffect } from 'react'
import { lightTheme, logThemeUsage } from '@/app/styles/theme'

interface CardProps {
  children: ReactNode
  title?: string
  className?: string
  headerAction?: ReactNode
  onClick?: () => void
}

const cardStyles = {
  base: `
    bg-${lightTheme.colors.background.primary}
    rounded-${lightTheme.borderRadius.lg}
    ${lightTheme.shadows.md}
    overflow-hidden
    transition-all ${lightTheme.transitions.default}
  `,
  header: {
    wrapper: `
      px-${lightTheme.spacing[6]}
      py-${lightTheme.spacing[4]}
      border-b border-${lightTheme.colors.border.light}
      flex justify-between items-center
      bg-${lightTheme.colors.background.secondary}
    `,
    title: `
      text-${lightTheme.typography.sizes.lg}
      font-${lightTheme.typography.weights.medium}
      text-${lightTheme.colors.text.primary}
      leading-${lightTheme.typography.lineHeights.normal}
    `
  },
  content: `
    px-${lightTheme.spacing[6]}
    py-${lightTheme.spacing[4]}
  `,
  interactive: `
    cursor-pointer
    hover:${lightTheme.shadows.lg}
    active:${lightTheme.shadows.sm}
    focus:outline-none
    focus:ring-2
    focus:ring-${lightTheme.colors.accent.focus}
    focus:ring-offset-2
  `
}

export default function Card({ children, title, className = '', headerAction, onClick }: CardProps) {
  useEffect(() => {
    logThemeUsage('Card', {
      hasTitle: !!title,
      hasHeaderAction: !!headerAction,
      isClickable: !!onClick,
      appliedStyles: {
        base: cardStyles.base,
        header: cardStyles.header,
        content: cardStyles.content,
        interactive: onClick ? cardStyles.interactive : '',
        customClass: className
      }
    })
  }, [title, headerAction, onClick, className])

  const handleClick = () => {
    if (onClick) {
      logThemeUsage('Card', {
        event: 'click',
        styles: {
          base: cardStyles.base,
          interactive: cardStyles.interactive
        }
      })
      onClick()
    }
  }

  return (
    <div 
      className={`
        ${cardStyles.base}
        ${onClick ? cardStyles.interactive : ''}
        ${className}
      `}
      onClick={handleClick}
      role={onClick ? "button" : undefined}
      tabIndex={onClick ? 0 : undefined}
    >
      {(title || headerAction) && (
        <div className={cardStyles.header.wrapper}>
          {title && (
            <h3 className={cardStyles.header.title}>{title}</h3>
          )}
          {headerAction && <div>{headerAction}</div>}
        </div>
      )}
      <div className={cardStyles.content}>
        {children}
      </div>
    </div>
  )
} 
```

## File: app\components\ThemeToggle.tsx
```tsx
'use client'

import { useEffect, useState } from 'react'
import { Moon, Sun } from 'lucide-react'

export default function ThemeToggle() {
  const [theme, setTheme] = useState('dark')
  const [mounted, setMounted] = useState(false)

  useEffect(() => {
    // Check local storage or use dark as default
    const savedTheme = localStorage.getItem('theme') || 'dark'
    setTheme(savedTheme)
    document.documentElement.classList.toggle('dark', savedTheme === 'dark')
    setMounted(true)
  }, [])

  const toggleTheme = () => {
    const newTheme = theme === 'light' ? 'dark' : 'light'
    setTheme(newTheme)
    localStorage.setItem('theme', newTheme)
    document.documentElement.classList.toggle('dark')
  }

  // Prevent hydration mismatch by not rendering until mounted
  if (!mounted) {
    return null
  }

  return (
    <button
      type="button"
      onClick={toggleTheme}
      className="p-2 rounded-full bg-muted hover:bg-muted/80 transition-colors"
      aria-label="Toggle theme"
      suppressHydrationWarning
    >
      {theme === 'light' ? (
        <Moon className="h-5 w-5" />
      ) : (
        <Sun className="h-5 w-5" />
      )}
    </button>
  )
} 
```

## File: app\globals.css
```css
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --background: 0 0% 100%;
  --foreground: 222.2 84% 4.9%;
  --card: 0 0% 100%;
  --card-foreground: 222.2 84% 4.9%;
  --popover: 0 0% 100%;
  --popover-foreground: 222.2 84% 4.9%;
  --primary: 221.2 83.2% 53.3%;
  --primary-foreground: 210 40% 98%;
  --secondary: 210 40% 96.1%;
  --secondary-foreground: 222.2 47.4% 11.2%;
  --muted: 210 40% 96.1%;
  --muted-foreground: 215.4 16.3% 46.9%;
  --accent: 210 40% 96.1%;
  --accent-foreground: 222.2 47.4% 11.2%;
  --destructive: 0 84.2% 60.2%;
  --destructive-foreground: 210 40% 98%;
  --border: 214.3 31.8% 91.4%;
  --input: 214.3 31.8% 91.4%;
  --ring: 221.2 83.2% 53.3%;
  --radius: 0.5rem;
}

/* Dark theme colors */
.dark {
  --background: 222.2 84% 4.9%;
  --foreground: 210 40% 98%;
  --card: 222.2 84% 4.9%;
  --card-foreground: 210 40% 98%;
  --popover: 222.2 84% 4.9%;
  --popover-foreground: 210 40% 98%;
  --primary: 217.2 91.2% 59.8%;
  --primary-foreground: 222.2 47.4% 11.2%;
  --secondary: 217.2 32.6% 17.5%;
  --secondary-foreground: 210 40% 98%;
  --muted: 217.2 32.6% 17.5%;
  --muted-foreground: 215 20.2% 65.1%;
  --accent: 217.2 32.6% 17.5%;
  --accent-foreground: 210 40% 98%;
  --destructive: 0 62.8% 30.6%;
  --destructive-foreground: 210 40% 98%;
  --border: 217.2 32.6% 17.5%;
  --input: 217.2 32.6% 17.5%;
  --ring: 224.3 76.3% 48%;
}

/* Ensure proper text visibility in dark mode */
.dark body {
  @apply bg-background text-foreground;
}

/* Base styles */
body {
  @apply bg-background text-foreground;
}

/* Ensure text visibility in various contexts */
.text-gray-500 {
  @apply text-muted-foreground;
}

.text-gray-600 {
  @apply text-foreground/70;
}

.text-gray-700 {
  @apply text-foreground/80;
}

/* Ensure proper contrast for form elements */
input, select, textarea {
  @apply bg-background text-foreground border-input;
}

/* Ensure proper contrast for buttons */
button {
  @apply disabled:opacity-50 disabled:cursor-not-allowed;
}

/* Ensure proper contrast for cards and containers */
.bg-gray-50 {
  @apply bg-muted text-muted-foreground;
}

.bg-white {
  @apply bg-background text-foreground;
}

/* Dark mode specific overrides */
.dark .bg-white {
  @apply bg-background text-foreground;
}

.dark .border {
  @apply border-border;
}

.dark .shadow-lg {
  @apply shadow-[0_10px_15px_-3px_rgba(0,0,0,0.3)];
}

.dark input, .dark select, .dark textarea {
  @apply border-input bg-background text-foreground;
}


```

## File: app\layout.tsx
```tsx
import type { Metadata } from 'next'
import { Inter } from 'next/font/google'
import './globals.css'
import { Providers } from './providers'
import { SpeedInsights } from "@vercel/speed-insights/next"

const inter = Inter({ subsets: ['latin'] })

export const metadata: Metadata = {
  title: 'QA App',
  description: 'Quality Assurance Application',
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en" suppressHydrationWarning>
      <body className={inter.className}>
        <script
          dangerouslySetInnerHTML={{
            __html: `
              try {
                let theme = localStorage.getItem('theme')
                if (!theme) {
                  localStorage.setItem('theme', 'dark')
                  theme = 'dark'
                }
                if (theme === 'dark') {
                  document.documentElement.classList.add('dark')
                }
              } catch (e) {}
            `,
          }}
        />
        <Providers>
          {children}
        </Providers>
        <SpeedInsights />
      </body>
    </html>
  )
}


```

## File: app\login\page.tsx
```tsx
'use client'

import { useState } from 'react'
import { signIn } from 'next-auth/react'
import ThemeToggle from '../components/ThemeToggle'

export default function Login() {
  const [email, setEmail] = useState('')
  const [password, setPassword] = useState('')
  const [error, setError] = useState('')
  const [isLoading, setIsLoading] = useState(false)

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    setIsLoading(true)
    setError('')

    try {
      const result = await signIn('credentials', {
        email,
        password,
        redirect: true,
        callbackUrl: '/allDashboards'
      })

      if (result?.error) {
        setError(result.error)
      }
    } catch (err) {
      setError('An error occurred during login')
      console.error('Login error:', err)
    } finally {
      setIsLoading(false)
    }
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-background">
      <div className="fixed top-4 right-4">
        <ThemeToggle />
      </div>
      
      <div className="bg-card p-8 rounded-lg shadow-lg w-full max-w-md">
        <h1 className="text-2xl font-bold text-center mb-6 text-foreground">Login</h1>
        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <label htmlFor="email" className="block text-sm font-medium text-foreground mb-1">
              Email
            </label>
            <input
              type="email"
              id="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              className="w-full p-2 rounded-md border bg-background text-foreground"
              required
            />
          </div>
          <div>
            <label htmlFor="password" className="block text-sm font-medium text-foreground mb-1">
              Password
            </label>
            <input
              type="password"
              id="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              className="w-full p-2 rounded-md border bg-background text-foreground"
              required
            />
          </div>
          {error && (
            <div className="text-destructive text-sm">{error}</div>
          )}
          <button
            type="submit"
            className={`w-full bg-primary text-primary-foreground p-2 rounded-md hover:bg-primary/90 transition-colors ${
              isLoading ? 'opacity-50 cursor-not-allowed' : ''
            }`}
            disabled={isLoading}
          >
            {isLoading ? 'Logging in...' : 'Log In'}
          </button>
        </form>
      </div>
    </div>
  )
}


```

## File: app\page.tsx
```tsx
import { redirect } from "next/navigation"

export default function Home() {
  redirect("/allDashboards")
}


```

## File: app\providers.tsx
```tsx
'use client'

import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { SessionProvider } from 'next-auth/react'
import { useState } from 'react'

export function Providers({ children }: { children: React.ReactNode }) {
  const [queryClient] = useState(() => new QueryClient({
    defaultOptions: {
      queries: {
        staleTime: 5 * 60 * 1000, // 5 minutes
        gcTime: 30 * 60 * 1000, // 30 minutes
        refetchOnWindowFocus: false,
        retry: 1
      }
    }
  }))

  return (
    <QueryClientProvider client={queryClient}>
      <SessionProvider>{children}</SessionProvider>
    </QueryClientProvider>
  )
} 
```

## File: app\styles\styleLogger.ts
```ts
import { CSSProperties } from 'react';

type StyleValue = string | number | CSSProperties;
type StyleMap = Record<string, StyleValue>;

interface LoggerOptions {
  prefix?: string;
  suffix?: string;
  separator?: string;
}

class StyleLogger {
  private styles: StyleMap;
  private options: LoggerOptions;

  constructor(options: LoggerOptions = {}) {
    this.styles = {};
    this.options = {
      prefix: options.prefix || '',
      suffix: options.suffix || '',
      separator: options.separator || ' ',
    };
  }

  log(key: string, value: StyleValue): void {
    this.styles[key] = value;
  }

  logMultiple(styles: StyleMap): void {
    Object.entries(styles).forEach(([key, value]) => {
      this.log(key, value);
    });
  }

  getStyleString(): string {
    return Object.entries(this.styles)
      .map(([key, value]) => {
        if (typeof value === 'object') {
          return Object.entries(value as CSSProperties)
            .map(([prop, val]) => `${key}-${prop}: ${val}`)
            .join(this.options.separator);
        }
        return `${key}: ${value}`;
      })
      .join(this.options.separator);
  }

  getFormattedStyle(customOptions?: Partial<LoggerOptions>): string {
    const options = { ...this.options, ...customOptions };
    const styleString = this.getStyleString();
    return `${options.prefix}${styleString}${options.suffix}`;
  }

  clear(): void {
    this.styles = {};
  }

  getStyles(): StyleMap {
    return { ...this.styles };
  }

  setOptions(options: Partial<LoggerOptions>): void {
    this.options = { ...this.options, ...options };
  }

  getOptions(): LoggerOptions {
    return { ...this.options };
  }
}

export default StyleLogger; 
```

## File: app\styles\theme.ts
```ts
export const lightTheme = {
  colors: {
    background: {
      primary: '#ffffff',
      secondary: '#f9fafb',
      tertiary: '#f3f4f6'
    },
    text: {
      primary: '#111827',
      secondary: '#374151',
      tertiary: '#6b7280'
    },
    accent: {
      primary: '#2563eb',
      hover: '#1d4ed8',
      focus: '#3b82f6'
    },
    border: {
      light: '#e5e7eb',
      default: '#d1d5db',
      dark: '#9ca3af'
    },
    status: {
      success: '#22c55e',
      error: '#ef4444',
      warning: '#f59e0b',
      info: '#3b82f6'
    }
  },
  spacing: {
    0: '0px',
    1: '0.25rem',
    2: '0.5rem',
    3: '0.75rem',
    4: '1rem',
    5: '1.25rem',
    6: '1.5rem',
    8: '2rem',
    10: '2.5rem',
    12: '3rem',
    16: '4rem'
  },
  borderRadius: {
    none: '0px',
    sm: '0.125rem',
    default: '0.25rem',
    md: '0.375rem',
    lg: '0.5rem',
    xl: '0.75rem',
    '2xl': '1rem',
    full: '9999px'
  },
  typography: {
    fonts: {
      sans: 'ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
      mono: 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace'
    },
    sizes: {
      xs: '0.75rem',
      sm: '0.875rem',
      base: '1rem',
      lg: '1.125rem',
      xl: '1.25rem',
      '2xl': '1.5rem',
      '3xl': '1.875rem',
      '4xl': '2.25rem'
    },
    weights: {
      normal: '400',
      medium: '500',
      semibold: '600',
      bold: '700'
    },
    lineHeights: {
      none: '1',
      tight: '1.25',
      normal: '1.5',
      relaxed: '1.75'
    }
  },
  shadows: {
    none: 'none',
    sm: '0 1px 2px 0 rgba(0, 0, 0, 0.05)',
    default: '0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px -1px rgba(0, 0, 0, 0.1)',
    md: '0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1)',
    lg: '0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -4px rgba(0, 0, 0, 0.1)',
    xl: '0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 8px 10px -6px rgba(0, 0, 0, 0.1)'
  },
  transitions: {
    default: '150ms cubic-bezier(0.4, 0, 0.2, 1)',
    fast: '100ms cubic-bezier(0.4, 0, 0.2, 1)',
    slow: '300ms cubic-bezier(0.4, 0, 0.2, 1)'
  }
} as const;

export type Theme = typeof lightTheme;

// Type-safe utility functions
export const styleUtils = {
  getColor: (path: keyof Theme['colors']) => lightTheme.colors[path],
  getSpacing: (size: keyof Theme['spacing']) => lightTheme.spacing[size],
  getRadius: (size: keyof Theme['borderRadius']) => lightTheme.borderRadius[size],
  getShadow: (size: keyof Theme['shadows']) => lightTheme.shadows[size],
  getFontSize: (size: keyof Theme['typography']['sizes']) => lightTheme.typography.sizes[size],
  getFontWeight: (weight: keyof Theme['typography']['weights']) => lightTheme.typography.weights[weight],
  getLineHeight: (height: keyof Theme['typography']['lineHeights']) => lightTheme.typography.lineHeights[height],
  getTransition: (speed: keyof Theme['transitions']) => lightTheme.transitions[speed]
};

// Logging utility
export const logThemeUsage = (component: string, styles: Record<string, unknown>) => {
  console.log(`Theme Usage - ${component}:`, {
    timestamp: new Date().toISOString(),
    component,
    appliedStyles: styles,
    themeTokens: {
      colors: Object.keys(lightTheme.colors),
      spacing: Object.keys(lightTheme.spacing),
      borderRadius: Object.keys(lightTheme.borderRadius),
      typography: {
        sizes: Object.keys(lightTheme.typography.sizes),
        weights: Object.keys(lightTheme.typography.weights),
        lineHeights: Object.keys(lightTheme.typography.lineHeights)
      },
      shadows: Object.keys(lightTheme.shadows),
      transitions: Object.keys(lightTheme.transitions)
    }
  });
}; 
```

## File: components\AdminView.tsx
```tsx
import { Project, ProjectStatus } from '@/types/project'
import { User, UserRole } from '@/types/user'
import { useState } from 'react'
import { useRouter } from 'next/navigation'
import { useQueryClient, useQuery } from '@tanstack/react-query'
import axios from 'axios'
import { Search, Plus, Filter, MoreVertical, Users, Settings, ChartBar, Trash2, Edit3, UserPlus, UserMinus } from 'lucide-react'

interface AdminViewProps {
  projects: Project[];
  refetchProjects: () => Promise<any>;
}

const STATUS_COLORS = {
  'pending': 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900/50 dark:text-yellow-300',
  'in-progress': 'bg-blue-100 text-blue-800 dark:bg-blue-900/50 dark:text-blue-300',
  'completed': 'bg-green-100 text-green-800 dark:bg-green-900/50 dark:text-green-300',
  'on-hold': 'bg-red-100 text-red-800 dark:bg-red-900/50 dark:text-red-300'
} as const;

type Tab = 'projects' | 'users';

export default function AdminView({ projects, refetchProjects }: AdminViewProps) {
  const [activeTab, setActiveTab] = useState<Tab>('projects');
  const [isCreating, setIsCreating] = useState(false);
  const [isCreatingUser, setIsCreatingUser] = useState(false);
  const [searchTerm, setSearchTerm] = useState('');
  const [filterStatus, setFilterStatus] = useState<ProjectStatus | 'all'>('all');
  const [selectedProject, setSelectedProject] = useState<Project | null>(null);
  const [selectedUser, setSelectedUser] = useState<User | null>(null);
  const [showDeleteConfirm, setShowDeleteConfirm] = useState(false);
  const [showUserDeleteConfirm, setShowUserDeleteConfirm] = useState(false);
  const [isEditing, setIsEditing] = useState(false);
  const [viewMode, setViewMode] = useState<'grid' | 'list'>('grid');
  const [sortBy, setSortBy] = useState<'title' | 'date' | 'status'>('date');
  
  const [newProject, setNewProject] = useState({
    title: '',
    description: '',
    sourceLanguage: '',
    targetLanguage: '',
    dialogue_collection: '',
    status: 'pending' as ProjectStatus
  });

  const [newUser, setNewUser] = useState({
    username: '',
    email: '',
    password: '',
    role: 'transcriber' as UserRole,
    isActive: true
  });
  
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');
  const router = useRouter();
  const queryClient = useQueryClient();
  const [isAssigning, setIsAssigning] = useState(false);
  const [selectedUsernames, setSelectedUsernames] = useState<string[]>([]);

  const { data: users = [], isLoading: isLoadingUsers } = useQuery<User[]>({
    queryKey: ['users'],
    queryFn: async () => {
      const response = await axios.get('/api/admin/users');
      return response.data.data;
    }
  });

  // Filter and sort projects
  const filteredProjects = projects
    .filter((project: Project) => {
      const matchesSearch = project.title.toLowerCase().includes(searchTerm.toLowerCase()) ||
                          project.description.toLowerCase().includes(searchTerm.toLowerCase());
      const matchesStatus = filterStatus === 'all' || project.status === filterStatus;
      return matchesSearch && matchesStatus;
    })
    .sort((a: Project, b: Project) => {
      switch (sortBy) {
        case 'title':
          return a.title.localeCompare(b.title);
        case 'status':
          return a.status.localeCompare(b.status);
        case 'date':
        default:
          return new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime();
      }
    });

  // Filter users
  const filteredUsers = users.filter(user =>
    user.username.toLowerCase().includes(searchTerm.toLowerCase()) ||
    user.email.toLowerCase().includes(searchTerm.toLowerCase())
  );

  const handleCreateProject = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      console.log('Creating project with payload:', newProject);
      
      // Validate required fields
      const requiredFields = ['title', 'description', 'sourceLanguage', 'targetLanguage', 'dialogue_collection'];
      const missingFields = requiredFields.filter(field => !newProject[field as keyof typeof newProject]);
      
      if (missingFields.length > 0) {
        console.error('Missing required fields:', missingFields);
        setError(`Missing required fields: ${missingFields.join(', ')}`);
        return;
      }

      const response = await axios.post('/api/admin/projects', newProject);
      console.log('Project creation response:', response.data);

      if (response.data.success) {
        console.log('Project created successfully:', response.data);
        setIsCreating(false);
        setNewProject({
          title: '',
          description: '',
          sourceLanguage: '',
          targetLanguage: '',
          dialogue_collection: '',
          status: 'pending'
        });
        
        if (typeof refetchProjects === 'function') {
          try {
            await refetchProjects();
          } catch (refetchError) {
            console.error('Error refetching projects:', refetchError);
          }
        } else {
          console.warn('refetchProjects is not available, projects list may be stale');
        }
        
        setSuccess('Project created successfully');
        setTimeout(() => setSuccess(''), 3000);
      } else {
        console.error('Project creation failed:', response.data);
        setError(response.data.message || 'Failed to create project');
        setTimeout(() => setError(''), 3000);
      }
    } catch (err: any) {
      console.error('Project creation error:', err);
      const errorMessage = err.response?.data?.message || err.message || 'Failed to create project';
      console.error('Error details:', errorMessage);
      setError(errorMessage);
      setTimeout(() => setError(''), 3000);
    }
  };

  const handleCreateUser = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      const response = await axios.post('/api/admin/users', newUser);
      if (response.data.success) {
        setIsCreatingUser(false);
        setNewUser({
          username: '',
          email: '',
          password: '',
          role: 'transcriber',
          isActive: true
        });
        queryClient.invalidateQueries({ queryKey: ['users'] });
        setSuccess('User created successfully');
        setTimeout(() => setSuccess(''), 3000);
      }
    } catch (err) {
      setError('Failed to create user');
      setTimeout(() => setError(''), 3000);
    }
  };

  const handleUpdateStatus = async (projectId: string, newStatus: ProjectStatus) => {
    try {
      await axios.patch(`/api/admin/projects/${projectId}`, { status: newStatus });
      if (typeof refetchProjects === 'function') {
        await refetchProjects();
      }
      setSuccess('Status updated successfully');
      setTimeout(() => setSuccess(''), 3000);
    } catch (err) {
      setError('Failed to update project status');
      setTimeout(() => setError(''), 3000);
    }
  };

  const handleDeleteProject = async (projectId: string) => {
    try {
      await axios.delete(`/api/admin/projects/${projectId}`);
      if (typeof refetchProjects === 'function') {
        await refetchProjects();
      }
      setShowDeleteConfirm(false);
      setSelectedProject(null);
      setSuccess('Project deleted successfully');
      setTimeout(() => setSuccess(''), 3000);
    } catch (err) {
      console.error('Delete project error:', err);
      setError('Failed to delete project');
      setTimeout(() => setError(''), 3000);
    }
  };

  const handleDeleteUser = async (userId: string) => {
    try {
      await axios.delete(`/api/admin/users/${userId}`);
      queryClient.invalidateQueries({ queryKey: ['users'] });
      setShowUserDeleteConfirm(false);
      setSelectedUser(null);
      setSuccess('User deleted successfully');
      setTimeout(() => setSuccess(''), 3000);
    } catch (err) {
      setError('Failed to delete user');
      setTimeout(() => setError(''), 3000);
    }
  };

  const handleToggleUserActive = async (userId: string, isActive: boolean) => {
    try {
      await axios.patch(`/api/admin/users/${userId}`, { isActive });
      queryClient.invalidateQueries({ queryKey: ['users'] });
      setSuccess(`User ${isActive ? 'activated' : 'deactivated'} successfully`);
      setTimeout(() => setSuccess(''), 3000);
    } catch (err) {
      setError(`Failed to ${isActive ? 'activate' : 'deactivate'} user`);
      setTimeout(() => setError(''), 3000);
    }
  };

  const handleAssignUsers = async () => {
    try {
      if (!selectedProject) return;
      
      await axios.post(`/api/admin/projects/${selectedProject._id}/assign`, {
        usernames: selectedUsernames
      });
      
      if (typeof refetchProjects === 'function') {
        await refetchProjects();
      }
      setIsAssigning(false);
      setSelectedUsernames([]);
      setSelectedProject(null);
      setSuccess('Users assigned successfully');
      setTimeout(() => setSuccess(''), 3000);
    } catch (err) {
      setError('Failed to assign users');
      setTimeout(() => setError(''), 3000);
    }
  };

  const handleRemoveUser = async (projectId: string, username: string) => {
    try {
      await axios.delete(`/api/admin/projects/${projectId}/assign`, {
        data: { usernames: [username] }
      });
      
      if (refetchProjects) {
        await refetchProjects();
      }
      setSuccess('User removed successfully');
      setTimeout(() => setSuccess(''), 3000);
    } catch (err) {
      setError('Failed to remove user');
      setTimeout(() => setError(''), 3000);
    }
  };

  return (
    <div className="min-h-screen bg-gray-50 dark:bg-gray-900">
      {/* Top Bar */}
      <div className="bg-white dark:bg-gray-800 shadow">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4">
          <div className="flex items-center justify-between">
            <div className="flex items-center space-x-4">
              <h1 className="text-2xl font-bold text-gray-900 dark:text-white">Admin Dashboard</h1>
              <div className="flex space-x-2">
                <button
                  onClick={() => setActiveTab('projects')}
                  className={`px-4 py-2 rounded-lg transition-colors ${
                    activeTab === 'projects'
                      ? 'bg-blue-500 text-white'
                      : 'text-gray-600 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700'
                  }`}
                >
                  Projects
                </button>
                <button
                  onClick={() => setActiveTab('users')}
                  className={`px-4 py-2 rounded-lg transition-colors ${
                    activeTab === 'users'
                      ? 'bg-blue-500 text-white'
                      : 'text-gray-600 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700'
                  }`}
                >
                  Users
                </button>
              </div>
            </div>
            <div className="flex items-center space-x-4">
              {activeTab === 'projects' && (
                <>
                  <button
                    onClick={() => setViewMode(prev => prev === 'grid' ? 'list' : 'grid')}
                    className="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-700 text-gray-600 dark:text-gray-300"
                  >
                    {viewMode === 'grid' ? 'List View' : 'Grid View'}
                  </button>
                  <button
                    onClick={() => setIsCreating(true)}
                    className="flex items-center px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors"
                  >
                    <Plus className="w-4 h-4 mr-2" />
                    Create Project
                  </button>
                </>
              )}
              {activeTab === 'users' && (
                <button
                  onClick={() => setIsCreatingUser(true)}
                  className="flex items-center px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors"
                >
                  <UserPlus className="w-4 h-4 mr-2" />
                  Create User
                </button>
              )}
            </div>
          </div>
        </div>
      </div>

      {/* Search and Filters */}
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6">
        <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center space-y-4 sm:space-y-0 sm:space-x-4">
          <div className="flex-1 w-full sm:w-auto">
            <div className="relative">
              <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 dark:text-gray-500 w-5 h-5" />
              <input
                type="text"
                placeholder={`Search ${activeTab}...`}
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                className="w-full pl-10 pr-4 py-2 border rounded-lg bg-white dark:bg-gray-800 border-gray-300 dark:border-gray-600 text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-gray-400 focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:border-transparent"
              />
            </div>
          </div>
          {activeTab === 'projects' && (
            <div className="flex items-center space-x-4 w-full sm:w-auto">
              <select
                value={filterStatus}
                onChange={(e) => setFilterStatus(e.target.value as ProjectStatus | 'all')}
                className="px-3 py-2 border rounded-lg bg-white dark:bg-gray-800 border-gray-300 dark:border-gray-600 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:border-transparent"
              >
                <option value="all">All Status</option>
                <option value="pending">Pending</option>
                <option value="in-progress">In Progress</option>
                <option value="completed">Completed</option>
                <option value="on-hold">On Hold</option>
              </select>
              <select
                value={sortBy}
                onChange={(e) => setSortBy(e.target.value as 'title' | 'date' | 'status')}
                className="px-3 py-2 border rounded-lg bg-white dark:bg-gray-800 border-gray-300 dark:border-gray-600 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:border-transparent"
              >
                <option value="date">Sort by Date</option>
                <option value="title">Sort by Title</option>
                <option value="status">Sort by Status</option>
              </select>
            </div>
          )}
        </div>
      </div>

      {/* Notifications */}
      {error && (
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 mb-6">
          <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative">
            {error}
          </div>
        </div>
      )}
      {success && (
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 mb-6">
          <div className="bg-green-100 border border-green-400 text-green-700 px-4 py-3 rounded relative">
            {success}
          </div>
        </div>
      )}

      {/* Content */}
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        {activeTab === 'projects' ? (
          // Projects Grid/List
          <div className={viewMode === 'grid' ? 
            "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6" : 
            "space-y-4"
          }>
            {filteredProjects.map((project) => (
              <div
                key={project._id}
                className={`bg-white dark:bg-gray-800 rounded-lg shadow hover:shadow-lg transition-shadow duration-200 ${
                  viewMode === 'list' ? 'p-4' : 'p-6'
                }`}
              >
                <div className={`${viewMode === 'list' ? 'flex items-center justify-between' : 'space-y-4'}`}>
                  <div className={viewMode === 'list' ? 'flex-1' : ''}>
                    <div className="flex justify-between items-start">
                      <h2 className="text-xl font-semibold text-gray-900 dark:text-white">{project.title}</h2>
                      <div className="flex items-center space-x-2">
                        <select
                          value={project.status}
                          onChange={(e) => handleUpdateStatus(project._id, e.target.value as ProjectStatus)}
                          className={`text-sm px-2 py-1 rounded ${STATUS_COLORS[project.status as keyof typeof STATUS_COLORS]}`}
                        >
                          <option value="pending">Pending</option>
                          <option value="in-progress">In Progress</option>
                          <option value="completed">Completed</option>
                          <option value="on-hold">On Hold</option>
                        </select>
                        <div className="relative">
                          <button
                            onClick={() => setSelectedProject(project)}
                            className="p-1 hover:bg-gray-100 dark:hover:bg-gray-700 rounded text-gray-600 dark:text-gray-300"
                          >
                            <MoreVertical className="w-5 h-5" />
                          </button>
                          {selectedProject?._id === project._id && (
                            <div className="absolute right-0 mt-2 w-48 bg-white dark:bg-gray-800 rounded-lg shadow-lg z-10 border dark:border-gray-700">
                              <div className="py-1">
                                <button
                                  onClick={() => router.push(`/admin/project/${project._id}`)}
                                  className="flex items-center w-full px-4 py-2 text-sm text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-700"
                                >
                                  <Settings className="w-4 h-4 mr-2" />
                                  Manage
                                </button>
                                <button
                                  onClick={() => router.push(`/admin/project/${project._id}/progress`)}
                                  className="flex items-center w-full px-4 py-2 text-sm text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-700"
                                >
                                  <ChartBar className="w-4 h-4 mr-2" />
                                  Progress
                                </button>
                                <button
                                  onClick={() => {
                                    setIsEditing(true);
                                    setSelectedProject(project);
                                  }}
                                  className="flex items-center w-full px-4 py-2 text-sm text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-700"
                                >
                                  <Edit3 className="w-4 h-4 mr-2" />
                                  Edit
                                </button>
                                <button
                                  onClick={() => {
                                    setIsAssigning(true);
                                    setSelectedProject(project);
                                  }}
                                  className="flex items-center w-full px-4 py-2 text-sm text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-700"
                                >
                                  <Users className="w-4 h-4 mr-2" />
                                  Assign Users
                                </button>
                                <button
                                  onClick={() => {
                                    setShowDeleteConfirm(true);
                                    setSelectedProject(project);
                                  }}
                                  className="flex items-center w-full px-4 py-2 text-sm text-red-600 dark:text-red-400 hover:bg-gray-100 dark:hover:bg-gray-700"
                                >
                                  <Trash2 className="w-4 h-4 mr-2" />
                                  Delete
                                </button>
                              </div>
                            </div>
                          )}
                        </div>
                      </div>
                    </div>
                    {viewMode === 'grid' && (
                      <>
                        <p className="text-gray-600 dark:text-gray-300 mt-2">{project.description}</p>
                        <div className="flex flex-col gap-2 mt-4">
                          <div className="flex justify-between text-sm">
                            <span className="text-gray-500 dark:text-gray-400">
                              Language: {project.sourceLanguage} → {project.targetLanguage}
                            </span>
                          </div>
                          <div className="flex justify-between text-sm">
                            <span className="text-gray-500 dark:text-gray-400">
                              Collection: {project.dialogue_collection}
                            </span>
                          </div>
                          {project.videoPath && (
                            <div className="flex justify-between text-sm">
                              <span className="text-gray-500 dark:text-gray-400">
                                Video Path: {project.videoPath}
                              </span>
                            </div>
                          )}
                          <div className="flex justify-between text-sm">
                            <span className="text-gray-500 dark:text-gray-400">
                              Last Updated: {new Date(project.updatedAt).toLocaleDateString()}
                            </span>
                          </div>
                        </div>
                      </>
                    )}
                    {project.assignedTo.length > 0 && (
                      <div className={viewMode === 'grid' ? 'mt-4' : 'mt-2'}>
                        <div className="flex flex-wrap gap-2">
                          {project.assignedTo.map((user, index) => (
                            <span
                              key={index}
                              className={`inline-flex items-center px-2 py-1 rounded-full text-xs font-medium ${
                                user.role === 'transcriber' ? 'bg-purple-100 text-purple-800 dark:bg-purple-900/50 dark:text-purple-300' :
                                user.role === 'translator' ? 'bg-blue-100 text-blue-800 dark:bg-blue-900/50 dark:text-blue-300' :
                                user.role === 'voice-over' ? 'bg-green-100 text-green-800 dark:bg-green-900/50 dark:text-green-300' :
                                user.role === 'director' ? 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900/50 dark:text-yellow-300' :
                                'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300'
                              }`}
                            >
                              {user.username} ({user.role})
                            </span>
                          ))}
                        </div>
                      </div>
                    )}
                  </div>
                </div>
              </div>
            ))}
          </div>
        ) : (
          // Users List
          <div className="bg-white dark:bg-gray-800 shadow rounded-lg overflow-hidden">
            <table className="min-w-full divide-y divide-gray-200 dark:divide-gray-700">
              <thead className="bg-gray-50 dark:bg-gray-900">
                <tr>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                    User
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                    Role
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                    Status
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                    Projects
                  </th>
                  <th className="px-6 py-3 text-right text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                    Actions
                  </th>
                </tr>
              </thead>
              <tbody className="bg-white dark:bg-gray-800 divide-y divide-gray-200 dark:divide-gray-700">
                {filteredUsers.map((user) => (
                  <tr key={user._id}>
                    <td className="px-6 py-4 whitespace-nowrap">
                      <div className="flex items-center">
                        <div>
                          <div className="text-sm font-medium text-gray-900 dark:text-white">
                            {user.username}
                          </div>
                          <div className="text-sm text-gray-500 dark:text-gray-400">
                            {user.email}
                          </div>
                        </div>
                      </div>
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap">
                      <span className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${
                        user.role === 'transcriber' ? 'bg-purple-100 text-purple-800 dark:bg-purple-900/50 dark:text-purple-300' :
                        user.role === 'translator' ? 'bg-blue-100 text-blue-800 dark:bg-blue-900/50 dark:text-blue-300' :
                        user.role === 'voice-over' ? 'bg-green-100 text-green-800 dark:bg-green-900/50 dark:text-green-300' :
                        user.role === 'director' ? 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900/50 dark:text-yellow-300' :
                        'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300'
                      }`}>
                        {user.role}
                      </span>
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap">
                      <button
                        onClick={() => handleToggleUserActive(user._id, !user.isActive)}
                        className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${
                          user.isActive
                            ? 'bg-green-100 text-green-800 dark:bg-green-900/50 dark:text-green-300'
                            : 'bg-red-100 text-red-800 dark:bg-red-900/50 dark:text-red-300'
                        }`}
                      >
                        {user.isActive ? 'Active' : 'Inactive'}
                      </button>
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400">
                      {user.assignedProjects?.length || 0} projects
                      <div className="text-xs text-gray-400 dark:text-gray-500">
                        Last login: {user.lastLogin ? new Date(user.lastLogin).toLocaleDateString() : 'Never'}
                      </div>
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                      <button
                        onClick={() => {
                          setSelectedUser(user);
                          setShowUserDeleteConfirm(true);
                        }}
                        className="text-red-600 dark:text-red-400 hover:text-red-900 dark:hover:text-red-300"
                      >
                        Delete
                      </button>
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        )}
      </div>

      {/* Create Project Modal */}
      {isCreating && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
          <div className="bg-white dark:bg-gray-800 rounded-lg p-6 max-w-md w-full">
            <h2 className="text-xl font-semibold mb-4 text-gray-900 dark:text-white">Create New Project</h2>
            <form onSubmit={handleCreateProject} className="space-y-4">
              <div>
                <label className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300">Title</label>
                <input
                  type="text"
                  value={newProject.title}
                  onChange={(e) => setNewProject(prev => ({ ...prev, title: e.target.value }))}
                  className="w-full p-2 border rounded bg-white dark:bg-gray-800 border-gray-300 dark:border-gray-600 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:border-transparent"
                  required
                />
              </div>
              <div>
                <label className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300">Description</label>
                <textarea
                  value={newProject.description}
                  onChange={(e) => setNewProject(prev => ({ ...prev, description: e.target.value }))}
                  className="w-full p-2 border rounded bg-white dark:bg-gray-800 border-gray-300 dark:border-gray-600 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:border-transparent"
                  rows={3}
                  required
                />
              </div>
              <div className="grid grid-cols-2 gap-4">
                <div>
                  <label className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300">Source Language</label>
                  <input
                    type="text"
                    value={newProject.sourceLanguage}
                    onChange={(e) => setNewProject(prev => ({ ...prev, sourceLanguage: e.target.value }))}
                    className="w-full p-2 border rounded bg-white dark:bg-gray-800 border-gray-300 dark:border-gray-600 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:border-transparent"
                    required
                  />
                </div>
                <div>
                  <label className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300">Target Language</label>
                  <input
                    type="text"
                    value={newProject.targetLanguage}
                    onChange={(e) => setNewProject(prev => ({ ...prev, targetLanguage: e.target.value }))}
                    className="w-full p-2 border rounded bg-white dark:bg-gray-800 border-gray-300 dark:border-gray-600 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:border-transparent"
                    required
                  />
                </div>
              </div>
              <div>
                <label className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300">Collection Name</label>
                <input
                  type="text"
                  value={newProject.dialogue_collection}
                  onChange={(e) => setNewProject(prev => ({ ...prev, dialogue_collection: e.target.value }))}
                  className="w-full p-2 border rounded bg-white dark:bg-gray-800 border-gray-300 dark:border-gray-600 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:border-transparent"
                  required
                />
              </div>
              <div className="flex justify-end gap-2 mt-4">
                <button
                  type="button"
                  onClick={() => setIsCreating(false)}
                  className="px-4 py-2 text-gray-600 dark:text-gray-400 hover:text-gray-800 dark:hover:text-gray-200 transition-colors"
                >
                  Cancel
                </button>
                <button
                  type="submit"
                  className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:ring-offset-2 dark:focus:ring-offset-gray-800"
                >
                  Create Project
                </button>
              </div>
            </form>
          </div>
        </div>
      )}

      {/* Create User Modal */}
      {isCreatingUser && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
          <div className="bg-white dark:bg-gray-800 rounded-lg p-6 max-w-md w-full">
            <h2 className="text-xl font-semibold mb-4 text-gray-900 dark:text-white">Create New User</h2>
            <form onSubmit={handleCreateUser} className="space-y-4">
              <div>
                <label className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300">Username</label>
                <input
                  type="text"
                  value={newUser.username}
                  onChange={(e) => setNewUser(prev => ({ ...prev, username: e.target.value }))}
                  className="w-full p-2 border rounded bg-white dark:bg-gray-800 border-gray-300 dark:border-gray-600 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:border-transparent"
                  required
                />
              </div>
              <div>
                <label className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300">Email</label>
                <input
                  type="email"
                  value={newUser.email}
                  onChange={(e) => setNewUser(prev => ({ ...prev, email: e.target.value }))}
                  className="w-full p-2 border rounded bg-white dark:bg-gray-800 border-gray-300 dark:border-gray-600 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:border-transparent"
                  required
                />
              </div>
              <div>
                <label className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300">Password</label>
                <input
                  type="password"
                  value={newUser.password}
                  onChange={(e) => setNewUser(prev => ({ ...prev, password: e.target.value }))}
                  className="w-full p-2 border rounded bg-white dark:bg-gray-800 border-gray-300 dark:border-gray-600 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:border-transparent"
                  required
                />
              </div>
              <div>
                <label className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300">Role</label>
                <select
                  value={newUser.role === 'admin' ? 'director' : newUser.role}
                  onChange={(e) => setNewUser(prev => ({ ...prev, role: e.target.value as UserRole }))}
                  className="w-full p-2 border rounded bg-white dark:bg-gray-800 border-gray-300 dark:border-gray-600 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:border-transparent"
                  required
                >
                  <option value="transcriber">Transcriber</option>
                  <option value="translator">Translator</option>
                  <option value="voice-over">Voice Over</option>
                  <option value="director">Director</option>
                  <option value="admin">Admin</option>
                </select>
              </div>
              <div className="flex justify-end gap-2 mt-4">
                <button
                  type="button"
                  onClick={() => setIsCreatingUser(false)}
                  className="px-4 py-2 text-gray-600 dark:text-gray-400 hover:text-gray-800 dark:hover:text-gray-200 transition-colors"
                >
                  Cancel
                </button>
                <button
                  type="submit"
                  className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:ring-offset-2 dark:focus:ring-offset-gray-800"
                >
                  Create User
                </button>
              </div>
            </form>
          </div>
        </div>
      )}

      {/* Delete User Confirmation Modal */}
      {showUserDeleteConfirm && selectedUser && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
          <div className="bg-white dark:bg-gray-800 rounded-lg p-6 max-w-md w-full">
            <h2 className="text-xl font-semibold mb-4 text-gray-900 dark:text-white">Delete User</h2>
            <p className="text-gray-600 dark:text-gray-300 mb-4">
              Are you sure you want to delete "{selectedUser.username}"? This action cannot be undone.
            </p>
            <div className="flex justify-end gap-2">
              <button
                onClick={() => {
                  setShowUserDeleteConfirm(false);
                  setSelectedUser(null);
                }}
                className="px-4 py-2 text-gray-600 dark:text-gray-400 hover:text-gray-800 dark:hover:text-gray-200 transition-colors"
              >
                Cancel
              </button>
              <button
                onClick={() => handleDeleteUser(selectedUser._id)}
                className="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600 transition-colors focus:ring-2 focus:ring-red-500 dark:focus:ring-red-400 focus:ring-offset-2 dark:focus:ring-offset-gray-800"
              >
                Delete
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Assign Users Modal */}
      {isAssigning && selectedProject && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
          <div className="bg-white dark:bg-gray-800 rounded-lg p-6 max-w-2xl w-full">
            <h2 className="text-xl font-semibold mb-4 text-gray-900 dark:text-white">
              Assign Users to {selectedProject.title}
            </h2>
            <div className="mb-6">
              <h3 className="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Currently Assigned</h3>
              <div className="flex flex-wrap gap-2">
                {selectedProject.assignedTo.map((user) => (
                  <div
                    key={user.username}
                    className={`flex items-center gap-2 px-3 py-1 rounded-full ${
                      user.role === 'transcriber' ? 'bg-purple-100 text-purple-800 dark:bg-purple-900/50 dark:text-purple-300' :
                      user.role === 'translator' ? 'bg-blue-100 text-blue-800 dark:bg-blue-900/50 dark:text-blue-300' :
                      user.role === 'voice-over' ? 'bg-green-100 text-green-800 dark:bg-green-900/50 dark:text-green-300' :
                      user.role === 'director' ? 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900/50 dark:text-yellow-300' :
                      'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300'
                    }`}
                  >
                    <span className="text-sm">
                      {user.username} ({user.role})
                    </span>
                    <button
                      onClick={() => handleRemoveUser(selectedProject._id, user.username)}
                      className="text-red-500 hover:text-red-700 dark:text-red-400 dark:hover:text-red-300"
                    >
                      ×
                    </button>
                  </div>
                ))}
                {selectedProject.assignedTo.length === 0 && (
                  <span className="text-sm text-gray-500 dark:text-gray-400">No users assigned</span>
                )}
              </div>
            </div>
            <div className="mb-6">
              <h3 className="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Available Users</h3>
              <div className="max-h-60 overflow-y-auto border dark:border-gray-700 rounded-lg">
                {users
                  .filter(user => user.isActive && !selectedProject.assignedTo.some(assigned => assigned.username === user.username))
                  .map((user) => (
                    <label
                      key={user._id}
                      className="flex items-center px-4 py-2 hover:bg-gray-50 dark:hover:bg-gray-700 cursor-pointer"
                    >
                      <input
                        type="checkbox"
                        checked={selectedUsernames.includes(user.username)}
                        onChange={(e) => {
                          if (e.target.checked) {
                            setSelectedUsernames(prev => [...prev, user.username]);
                          } else {
                            setSelectedUsernames(prev => prev.filter(name => name !== user.username));
                          }
                        }}
                        className="rounded border-gray-300 dark:border-gray-600 text-blue-500 focus:ring-blue-500 dark:focus:ring-blue-400"
                      />
                      <div className="ml-3">
                        <div className="text-sm font-medium text-gray-900 dark:text-white">{user.username}</div>
                        <div className="text-sm text-gray-500 dark:text-gray-400">
                          {user.email} • {user.role} • Last login: {user.lastLogin ? new Date(user.lastLogin).toLocaleDateString() : 'Never'}
                        </div>
                      </div>
                    </label>
                  ))}
              </div>
            </div>
            <div className="flex justify-end gap-2">
              <button
                onClick={() => {
                  setIsAssigning(false);
                  setSelectedProject(null);
                  setSelectedUsernames([]);
                }}
                className="px-4 py-2 text-gray-600 dark:text-gray-400 hover:text-gray-800 dark:hover:text-gray-200 transition-colors"
              >
                Cancel
              </button>
              <button
                onClick={handleAssignUsers}
                disabled={selectedUsernames.length === 0}
                className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:ring-offset-2 dark:focus:ring-offset-gray-800 disabled:opacity-50 disabled:cursor-not-allowed"
              >
                Assign Selected Users
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Edit Project Modal */}
      {isEditing && selectedProject && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
          <div className="bg-white dark:bg-gray-800 rounded-lg p-6 max-w-md w-full">
            <h2 className="text-xl font-semibold mb-4 text-gray-900 dark:text-white">Edit Project</h2>
            <form onSubmit={async (e) => {
              e.preventDefault();
              try {
                await axios.patch(`/api/admin/projects/${selectedProject._id}`, {
                  title: selectedProject.title,
                  description: selectedProject.description,
                  sourceLanguage: selectedProject.sourceLanguage,
                  targetLanguage: selectedProject.targetLanguage,
                  dialogue_collection: selectedProject.dialogue_collection,
                  status: selectedProject.status
                });
                await refetchProjects();
                setIsEditing(false);
                setSelectedProject(null);
                setSuccess('Project updated successfully');
                setTimeout(() => setSuccess(''), 3000);
              } catch (err) {
                setError('Failed to update project');
                setTimeout(() => setError(''), 3000);
              }
            }} className="space-y-4">
              <div>
                <label className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300">Title</label>
                <input
                  type="text"
                  value={selectedProject.title}
                  onChange={(e) => setSelectedProject(prev => prev ? { ...prev, title: e.target.value } : null)}
                  className="w-full p-2 border rounded bg-white dark:bg-gray-800 border-gray-300 dark:border-gray-600 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:border-transparent"
                  required
                />
              </div>
              <div>
                <label className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300">Description</label>
                <textarea
                  value={selectedProject.description}
                  onChange={(e) => setSelectedProject(prev => prev ? { ...prev, description: e.target.value } : null)}
                  className="w-full p-2 border rounded bg-white dark:bg-gray-800 border-gray-300 dark:border-gray-600 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:border-transparent"
                  rows={3}
                  required
                />
              </div>
              <div className="grid grid-cols-2 gap-4">
                <div>
                  <label className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300">Source Language</label>
                  <input
                    type="text"
                    value={selectedProject.sourceLanguage}
                    onChange={(e) => setSelectedProject(prev => prev ? { ...prev, sourceLanguage: e.target.value } : null)}
                    className="w-full p-2 border rounded bg-white dark:bg-gray-800 border-gray-300 dark:border-gray-600 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:border-transparent"
                    required
                  />
                </div>
                <div>
                  <label className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300">Target Language</label>
                  <input
                    type="text"
                    value={selectedProject.targetLanguage}
                    onChange={(e) => setSelectedProject(prev => prev ? { ...prev, targetLanguage: e.target.value } : null)}
                    className="w-full p-2 border rounded bg-white dark:bg-gray-800 border-gray-300 dark:border-gray-600 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:border-transparent"
                    required
                  />
                </div>
              </div>
              <div>
                <label className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300">Collection Name</label>
                <input
                  type="text"
                  value={selectedProject.dialogue_collection}
                  onChange={(e) => setSelectedProject(prev => prev ? { ...prev, dialogue_collection: e.target.value } : null)}
                  className="w-full p-2 border rounded bg-white dark:bg-gray-800 border-gray-300 dark:border-gray-600 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:border-transparent"
                  required
                />
              </div>
              <div className="flex justify-end gap-2 mt-4">
                <button
                  type="button"
                  onClick={() => {
                    setIsEditing(false);
                    setSelectedProject(null);
                  }}
                  className="px-4 py-2 text-gray-600 dark:text-gray-400 hover:text-gray-800 dark:hover:text-gray-200 transition-colors"
                >
                  Cancel
                </button>
                <button
                  type="submit"
                  className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:ring-offset-2 dark:focus:ring-offset-gray-800"
                >
                  Save Changes
                </button>
              </div>
            </form>
          </div>
        </div>
      )}

      {/* Delete Project Confirmation Modal */}
      {showDeleteConfirm && selectedProject && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
          <div className="bg-white dark:bg-gray-800 rounded-lg p-6 max-w-md w-full">
            <h2 className="text-xl font-semibold mb-4 text-gray-900 dark:text-white">Delete Project</h2>
            <p className="text-gray-600 dark:text-gray-300 mb-4">
              Are you sure you want to delete "{selectedProject.title}"? This action cannot be undone.
            </p>
            <div className="flex justify-end gap-2">
              <button
                onClick={() => {
                  setShowDeleteConfirm(false);
                  setSelectedProject(null);
                }}
                className="px-4 py-2 text-gray-600 dark:text-gray-400 hover:text-gray-800 dark:hover:text-gray-200 transition-colors"
              >
                Cancel
              </button>
              <button
                onClick={() => handleDeleteProject(selectedProject._id)}
                className="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600 transition-colors focus:ring-2 focus:ring-red-500 dark:focus:ring-red-400 focus:ring-offset-2 dark:focus:ring-offset-gray-800"
              >
                Delete
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}


```

## File: components\AudioVisualizer.tsx
```tsx
import React, { useEffect, useRef } from 'react';

interface AudioVisualizerProps {
  audioStream: MediaStream;
  maxDuration: number;
}

// Add type for webkitAudioContext
declare global {
  interface Window {
    webkitAudioContext: typeof AudioContext;
  }
}

const AudioVisualizer: React.FC<AudioVisualizerProps> = ({ audioStream, maxDuration }) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const animationFrameId = useRef<number | null>(null);
  const analyserRef = useRef<AnalyserNode | null>(null);

  useEffect(() => {
    if (!audioStream || !canvasRef.current) return;

    const audioContext = new (window.webkitAudioContext || window.AudioContext)();
    const analyser = audioContext.createAnalyser();
    const source = audioContext.createMediaStreamSource(audioStream);
    
    analyser.fftSize = 256;
    source.connect(analyser);
    analyserRef.current = analyser;

    const bufferLength = analyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    const draw = () => {
      animationFrameId.current = requestAnimationFrame(draw);

      analyser.getByteFrequencyData(dataArray);
      
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.beginPath();
      const sliceWidth = (canvas.width * 1.0) / bufferLength;
      let x = 0;

      for (let i = 0; i < bufferLength; i++) {
        const barHeight = (dataArray[i] / 255) * canvas.height;
        const y = canvas.height - barHeight;

        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }

        x += sliceWidth;
      }

      ctx.lineTo(canvas.width, canvas.height);
      ctx.lineTo(0, canvas.height);
      ctx.closePath();
      ctx.fillStyle = 'rgba(34, 198, 94, 0.5)';
      ctx.fill();

      const currentTime = audioContext.currentTime;
      const progress = (currentTime / maxDuration) * canvas.width;
      ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
      ctx.fillRect(0, 0, progress, canvas.height);
    };

    draw();

    return () => {
      if (animationFrameId.current) {
        cancelAnimationFrame(animationFrameId.current);
      }
      audioContext.close();
    };
  }, [audioStream, maxDuration]);

  return (
    <canvas
      ref={canvasRef}
      className="w-full h-16 rounded-md bg-gray-900 shadow-xl"
      width={300}
      height={64}
    />
  );
};

export default AudioVisualizer; 
```

## File: components\Button.tsx
```tsx
'use client'

import React, { ButtonHTMLAttributes } from 'react'

interface ButtonProps extends ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'primary' | 'secondary' | 'danger' | 'success'
  size?: 'sm' | 'md' | 'lg'
}

const variantClasses = {
  primary: 'bg-blue-600 hover:bg-blue-700 text-white',
  secondary: 'bg-gray-600 hover:bg-gray-700 text-white',
  danger: 'bg-red-600 hover:bg-red-700 text-white',
  success: 'bg-green-600 hover:bg-green-700 text-white'
}

const sizeClasses = {
  sm: 'px-2 py-1 text-sm',
  md: 'px-4 py-2',
  lg: 'px-6 py-3 text-lg'
}

export default function Button({
  variant = 'primary',
  size = 'md',
  className = '',
  children,
  ...props
}: ButtonProps) {
  const baseClasses = 'inline-flex items-center justify-center border border-transparent rounded-md font-medium focus:outline-none focus:ring-2 focus:ring-offset-2 transition-colors duration-200'
  const variantClass = variantClasses[variant]
  const sizeClass = sizeClasses[size]
  const focusRingColor = `focus:ring-${variant === 'primary' ? 'blue' : variant === 'secondary' ? 'gray' : variant === 'danger' ? 'red' : 'green'}-500`

  return (
    <button
      className={`${baseClasses} ${variantClass} ${sizeClass} ${focusRingColor} ${className}`}
      {...props}
    >
      {children}
    </button>
  )
} 
```

## File: components\Card.tsx
```tsx
'use client'

import React, { ReactNode } from 'react'

interface CardProps {
  children: ReactNode
  title?: string
  className?: string
  headerAction?: ReactNode
  onClick?: () => void
}

export default function Card({ children, title, className = '', headerAction, onClick }: CardProps) {
  return (
    <div 
      className={`bg-white rounded-lg shadow-md overflow-hidden ${className}`}
      onClick={onClick}
      role={onClick ? "button" : undefined}
      tabIndex={onClick ? 0 : undefined}
    >
      {(title || headerAction) && (
        <div className="px-6 py-4 border-b border-gray-200 flex justify-between items-center">
          {title && <h3 className="text-lg font-medium text-gray-900">{title}</h3>}
          {headerAction && <div>{headerAction}</div>}
        </div>
      )}
      <div className="px-6 py-4">
        {children}
      </div>
    </div>
  )
} 
```

## File: components\DashboardLayout.tsx
```tsx
'use client'

import React, { ReactNode } from 'react'
import { signOut } from 'next-auth/react'

interface DashboardLayoutProps {
  children: ReactNode
  title: string
}

export default function DashboardLayout({ children, title }: DashboardLayoutProps) {
  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-50 to-gray-100">
      {/* Navigation Bar */}
      <nav className="bg-white shadow-lg">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="flex justify-between h-16">
            <div className="flex items-center">
              <span className="text-2xl font-bold text-gray-800">{title}</span>
            </div>
            <div className="flex items-center">
              <button
                onClick={() => signOut({ callbackUrl: '/login' })}
                className="inline-flex items-center px-4 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-red-600 hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 transition-colors duration-200"
              >
                Logout
              </button>
            </div>
          </div>
        </div>
      </nav>

      {/* Main Content */}
      <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <div className="bg-white rounded-lg shadow-md p-6">
          {children}
        </div>
      </main>

      {/* Footer */}
      <footer className="bg-white shadow-lg mt-auto">
        <div className="max-w-7xl mx-auto py-4 px-4 sm:px-6 lg:px-8">
          <p className="text-center text-gray-500 text-sm">
            © {new Date().getFullYear()} QA App. All rights reserved.
          </p>
        </div>
      </footer>
    </div>
  )
} 
```

## File: components\DirectorDialogueView.tsx
```tsx
import { useState, useRef, useEffect } from 'react'
import { useQueryClient } from '@tanstack/react-query'
import { motion, useMotionValue, useTransform, useAnimation, type PanInfo } from 'framer-motion'
import axios from 'axios'

interface Dialogue {
  _id: string
  index: number
  timeStart: string
  timeEnd: string
  character: string
  videoUrl: string
  dialogue: {
    original: string
    translated: string
    adapted: string
  }
  status: string
  voiceOverUrl?: string
  voiceOverNotes?: string
  directorNotes?: string
  revisionRequested?: boolean
}

interface DialogueViewProps {
  dialogues: Dialogue[]
  projectId: string
}

type QueryData = {
  data: Dialogue[];
  status: string;
  timestamp: number;
};

export default function DirectorDialogueView({ dialogues: initialDialogues, projectId }: DialogueViewProps) {
  const [dialoguesList, setDialoguesList] = useState(initialDialogues);
  const [currentDialogueIndex, setCurrentDialogueIndex] = useState(0);
  const [isSaving, setIsSaving] = useState(false);
  const [showSaveSuccess, setShowSaveSuccess] = useState(false);
  const [error, setError] = useState<string>('');
  const [directorNotes, setDirectorNotes] = useState('');
  const [revisionRequested, setRevisionRequested] = useState(false);
  const [showConfirmation, setShowConfirmation] = useState(false);
  const videoRef = useRef<HTMLVideoElement>(null);
  const queryClient = useQueryClient();
  const [isPlaying, setIsPlaying] = useState(false);
  const [playbackRate, setPlaybackRate] = useState(1);

  const currentDialogue = dialoguesList[currentDialogueIndex];

  // Check for unsaved changes
  const hasChanges = () => {
    if (!currentDialogue) return false;
    return (
      directorNotes !== (currentDialogue.directorNotes || '') ||
      revisionRequested !== (currentDialogue.revisionRequested || false)
    );
  };

  // Navigation handlers
  const handleNext = () => {
    if (hasChanges()) {
      setShowConfirmation(true);
    } else if (currentDialogueIndex < dialoguesList.length - 1) {
      setCurrentDialogueIndex(prev => prev + 1);
    }
  };

  const handlePrevious = () => {
    if (currentDialogueIndex > 0) {
      if (hasChanges()) {
        setShowConfirmation(true);
      } else {
        setCurrentDialogueIndex(prev => prev - 1);
      }
    }
  };

  // Reset changes and continue navigation
  const handleDiscardChanges = () => {
    setShowConfirmation(false);
    if (currentDialogue) {
      setDirectorNotes(currentDialogue.directorNotes || '');
      setRevisionRequested(currentDialogue.revisionRequested || false);
    }
  };

  // Save changes with approval
  const handleApproveAndSave = async () => {
    if (!currentDialogue) return;
    
    try {
      setIsSaving(true);
      
      const updateData = {
        dialogue: currentDialogue.dialogue,
        character: currentDialogue.character,
        status: revisionRequested ? 'revision-requested' : 'approved',
        timeStart: currentDialogue.timeStart,
        timeEnd: currentDialogue.timeEnd,
        index: currentDialogue.index,
        voiceOverUrl: currentDialogue.voiceOverUrl,
        voiceOverNotes: currentDialogue.voiceOverNotes,
        directorNotes,
        revisionRequested,
      };
      
      const { data: responseData } = await axios.patch(`/api/dialogues/${currentDialogue._id}`, updateData, {
        headers: {
          'Content-Type': 'application/json',
        },
      });
      
      setDialoguesList(prevDialogues => 
        prevDialogues.map(d => 
          d._id === currentDialogue._id ? responseData : d
        )
      );

      queryClient.setQueryData(['dialogues', projectId], (oldData: QueryData | undefined) => {
        if (!oldData?.data) return oldData;
        return {
          ...oldData,
          data: oldData.data.map((d: Dialogue) => 
            d._id === currentDialogue._id ? responseData : d
          )
        };
      });

      setShowSaveSuccess(true);
      setShowConfirmation(false);
      setTimeout(() => setShowSaveSuccess(false), 2000);

      if (currentDialogueIndex < dialoguesList.length - 1) {
        setCurrentDialogueIndex(prev => prev + 1);
      }
    } catch (error) {
      console.error('Error saving review:', error);
      setError(error instanceof Error ? error.message : 'Failed to save review');
      setTimeout(() => setError(''), 3000);
    } finally {
      setIsSaving(false);
    }
  };

  // Motion values for swipe animation
  const x = useMotionValue(0)
  const rotate = useTransform(x, [-200, 200], [-10, 10])
  const opacity = useTransform(x, [-200, -150, 0, 150, 200], [0.5, 1, 1, 1, 0.5])
  const scale = useTransform(x, [-200, -150, 0, 150, 200], [0.8, 0.9, 1, 0.9, 0.8])
  const animControls = useAnimation()

  useEffect(() => {
    if (currentDialogue) {
      setDirectorNotes(currentDialogue.directorNotes || '')
      setRevisionRequested(currentDialogue.revisionRequested || false)
    }
  }, [currentDialogue])

  const handleDragEnd = (event: MouseEvent | TouchEvent | PointerEvent, info: PanInfo) => {
    if (Math.abs(info.offset.x) < 100) {
      animControls.start({ x: 0, opacity: 1 })
    } else {
      const direction = info.offset.x > 0 ? 'right' : 'left'
      if (direction === 'left' && currentDialogueIndex < dialoguesList.length - 1) {
        handleNext();
      } else if (direction === 'right' && currentDialogueIndex > 0) {
        handlePrevious();
      }
    }
  };

  const togglePlayPause = () => {
    if (videoRef.current) {
      if (isPlaying) {
        videoRef.current.pause();
      } else {
        videoRef.current.play();
      }
      setIsPlaying(!isPlaying);
    }
  };

  const rewindFiveSeconds = () => {
    if (videoRef.current) {
      videoRef.current.currentTime = Math.max(0, videoRef.current.currentTime - 5);
    }
  };

  const changePlaybackRate = (rate: number) => {
    if (videoRef.current) {
      videoRef.current.playbackRate = rate;
      setPlaybackRate(rate);
    }
  };

  useEffect(() => {
    const video = videoRef.current;
    if (video) {
      const handlePlay = () => setIsPlaying(true);
      const handlePause = () => setIsPlaying(false);
      
      video.addEventListener('play', handlePlay);
      video.addEventListener('pause', handlePause);
      
      return () => {
        video.removeEventListener('play', handlePlay);
        video.removeEventListener('pause', handlePause);
      };
    }
  }, []);

  if (!currentDialogue) {
    return <div className="text-center p-4">No dialogues available.</div>
  }

  return (
    <div className="w-full max-w-4xl mx-auto px-4 space-y-4 sm:space-y-6">
      {/* Video Player Card */}
      <div className="bg-white border border-gray-200 rounded-lg shadow dark:bg-gray-800 dark:border-gray-700 overflow-hidden">
        <video
          ref={videoRef}
          src={currentDialogue.videoUrl}
          controls
          className="w-full"
        />
        
        {/* Video Controls */}
        <div className="p-3 sm:p-4 border-t border-gray-200 dark:border-gray-700">
          <div className="flex flex-col sm:flex-row items-center justify-center gap-3 sm:gap-4">
            <div className="flex items-center gap-2">
              <button
                onClick={rewindFiveSeconds}
                className="px-3 py-1 bg-blue-500 text-white rounded hover:bg-blue-600 text-sm"
              >
                -5s
              </button>
              <button
                onClick={togglePlayPause}
                className="px-4 py-1 bg-blue-500 text-white rounded hover:bg-blue-600 text-sm"
              >
                {isPlaying ? 'Pause' : 'Play'}
              </button>
            </div>
            <div className="flex items-center gap-2 flex-wrap justify-center">
              <span className="text-sm text-gray-600 dark:text-gray-300">Speed:</span>
              {[0.5, 0.75, 1, 1.25, 1.5].map((rate) => (
                <button
                  key={rate}
                  onClick={() => changePlaybackRate(rate)}
                  className={`px-2 py-1 rounded text-sm ${
                    playbackRate === rate
                      ? 'bg-blue-500 text-white'
                      : 'bg-gray-200 text-gray-700 hover:bg-gray-300 dark:bg-gray-700 dark:text-gray-300'
                  }`}
                >
                  {rate}x
                </button>
              ))}
            </div>
          </div>
        </div>
      </div>

      {/* Dialogue Information Card */}
      <motion.div
        className="bg-white border border-gray-200 rounded-lg shadow dark:bg-gray-800 dark:border-gray-700"
        drag="x"
        dragConstraints={{ left: 0, right: 0 }}
        dragElastic={0.2}
        animate={animControls}
        style={{ x, rotate, opacity, scale }}
        onDragEnd={handleDragEnd}
        whileTap={{ cursor: 'grabbing' }}
        transition={{ 
          type: "spring", 
          stiffness: 300, 
          damping: 30,
          opacity: { duration: 0.2 },
          scale: { duration: 0.2 }
        }}
      >
        <div className="p-5 space-y-4">
          {/* Time Display */}
          <div className="flex items-center gap-4 text-sm">
            <div className="flex items-center gap-2">
              <span className="font-medium text-gray-900 dark:text-white">Start:</span>
              <p className="px-2 py-1 rounded-md border border-gray-300 bg-gray-50 text-gray-900 dark:bg-gray-700 dark:border-gray-600 dark:text-white min-w-[100px] text-center">
                {currentDialogue.timeStart || '00:00.000'}
              </p>
            </div>
            <div className="flex items-center gap-2">
              <span className="font-medium text-gray-900 dark:text-white">End:</span>
              <p className="px-2 py-1 rounded-md border border-gray-300 bg-gray-50 text-gray-900 dark:bg-gray-700 dark:border-gray-600 dark:text-white min-w-[100px] text-center">
                {currentDialogue.timeEnd || '00:00.000'}
              </p>
            </div>
          </div>

          {/* All Text Versions */}
          <div className="grid grid-cols-3 gap-4">
            <div>
              <label className="block text-sm font-medium mb-1 text-gray-900 dark:text-white">
                Original Text
              </label>
              <div className="w-full p-2.5 text-sm rounded-lg border border-gray-300 bg-gray-50 text-gray-900 dark:bg-gray-700 dark:border-gray-600 dark:text-white">
                {currentDialogue.dialogue.original}
              </div>
            </div>
            <div>
              <label className="block text-sm font-medium mb-1 text-gray-900 dark:text-white">
                Translated Text
              </label>
              <div className="w-full p-2.5 text-sm rounded-lg border border-gray-300 bg-gray-50 text-gray-900 dark:bg-gray-700 dark:border-gray-600 dark:text-white">
                {currentDialogue.dialogue.translated}
              </div>
            </div>
            <div>
              <label className="block text-sm font-medium mb-1 text-gray-900 dark:text-white">
                Adapted Text
              </label>
              <div className="w-full p-2.5 text-sm rounded-lg border border-gray-300 bg-gray-50 text-gray-900 dark:bg-gray-700 dark:border-gray-600 dark:text-white">
                {currentDialogue.dialogue.adapted}
              </div>
            </div>
          </div>

          {/* Voice-over Player */}
          {currentDialogue.voiceOverUrl && (
            <div className="flex items-center justify-center">
              <audio controls src={currentDialogue.voiceOverUrl} className="w-64" />
            </div>
          )}

          {/* Voice-over Notes Display */}
          {currentDialogue.voiceOverNotes && (
            <div>
              <label className="block text-sm font-medium mb-1 text-gray-900 dark:text-white">
                Voice-over Notes
              </label>
              <div className="w-full p-2.5 text-sm rounded-lg border border-gray-300 bg-gray-50 text-gray-900 dark:bg-gray-700 dark:border-gray-600 dark:text-white">
                {currentDialogue.voiceOverNotes}
              </div>
            </div>
          )}

          {/* Director Notes */}
          <div>
            <label htmlFor="directorNotes" className="block text-sm font-medium mb-1 text-gray-900 dark:text-white">
              Director Notes
            </label>
            <textarea
              id="directorNotes"
              value={directorNotes}
              onChange={(e) => setDirectorNotes(e.target.value)}
              rows={3}
              className="w-full p-2.5 text-sm rounded-lg border border-gray-300 bg-gray-50 text-gray-900 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white"
              placeholder="Add review notes, suggestions, or requirements..."
            />
          </div>

          {/* Revision Request Toggle */}
          <div className="flex items-center space-x-2">
            <input
              type="checkbox"
              id="revisionRequested"
              checked={revisionRequested}
              onChange={(e) => setRevisionRequested(e.target.checked)}
              className="w-4 h-4 text-blue-600 bg-gray-100 border-gray-300 rounded focus:ring-blue-500 dark:focus:ring-blue-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600"
            />
            <label htmlFor="revisionRequested" className="text-sm font-medium text-gray-900 dark:text-white">
              Request Revision
            </label>
          </div>

          {/* Navigation and Info */}
          <div className="flex items-center justify-center pt-4 mt-4 border-t border-gray-200 dark:border-gray-600">
            <div className="text-center">
              <div className="text-sm font-medium text-gray-900 dark:text-white">
                Dialogue {currentDialogueIndex + 1} of {dialoguesList.length}
              </div>
              <div className="text-xs text-gray-500 dark:text-gray-400">
                {currentDialogue.timeStart} - {currentDialogue.timeEnd}
              </div>
            </div>
          </div>
        </div>
      </motion.div>

      {/* Confirmation Modal */}
      {showConfirmation && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-xl max-w-md w-full">
            <h3 className="text-lg font-semibold mb-4">Unsaved Changes</h3>
            <p className="mb-4">You have unsaved changes. What would you like to do?</p>
            <div className="flex justify-end space-x-4">
              <button
                onClick={handleDiscardChanges}
                className="px-4 py-2 text-gray-600 hover:text-gray-800 dark:text-gray-300 dark:hover:text-white"
              >
                Discard Changes
              </button>
              <button
                onClick={() => setShowConfirmation(false)}
                className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
              >
                Keep Editing
              </button>
              <button
                onClick={handleApproveAndSave}
                disabled={isSaving}
                className="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600 disabled:opacity-50 disabled:cursor-not-allowed"
              >
                {isSaving ? 'Saving...' : revisionRequested ? 'Request Revision' : 'Approve'}
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Feedback Messages */}
      {isSaving && (
        <div className="fixed top-4 right-4 bg-blue-500 text-white px-4 py-2 rounded shadow-lg z-50">
          Saving review...
        </div>
      )}
      
      {showSaveSuccess && (
        <div className="fixed top-4 right-4 bg-green-500 text-white px-4 py-2 rounded shadow-lg z-50">
          Review saved successfully!
        </div>
      )}
      
      {error && (
        <div className="fixed top-4 right-4 bg-red-500 text-white px-4 py-2 rounded shadow-lg z-50">
          {error}
        </div>
      )}
    </div>
  )
} 
```

## File: components\DirectorView.tsx
```tsx
'use client'

import { useSession, signOut } from 'next-auth/react'
import { useRouter } from 'next/navigation'
import { useState } from 'react'

interface Project {
  _id: string
  title: string
  description: string
  sourceLanguage: string
  targetLanguage: string
  status: string
  assignedTo: Array<{
    username: string
    role: string
  }>
}

export default function DirectorView({ projects }: { projects: Project[] }) {
  const { data: session } = useSession()
  const router = useRouter()
  const [isLoggingOut, setIsLoggingOut] = useState(false)

  // Filter projects assigned to current user as director
  const assignedProjects = projects.filter(project => 
    project.assignedTo.some(assignment => 
      assignment.username === session?.user?.username && 
      assignment.role === 'director'
    )
  )

  const handleLogout = async () => {
    try {
      setIsLoggingOut(true)
      // Clear any client-side session data
      if (typeof window !== 'undefined') {
        window.localStorage.clear()
      }
      // Use direct redirect
      await signOut({ 
        redirect: true,
        callbackUrl: '/login'
      })
    } catch (error) {
      console.error('Error during signOut:', error)
      // Fallback redirect if signOut fails
      router.replace('/login')
    } finally {
      setIsLoggingOut(false)
    }
  }

  return (
    <div className="min-h-screen bg-background">
      <div className="max-w-7xl mx-auto px-4 py-6">
        <div className="flex justify-between items-center mb-6 w-full">
          <h1 className="text-2xl font-bold text-foreground">Your Projects</h1>
          <button 
            onClick={handleLogout}
            disabled={isLoggingOut}
            className={`z-50 px-4 py-2 rounded transition-colors ${
              isLoggingOut 
                ? 'bg-gray-400 cursor-not-allowed' 
                : 'bg-red-500 hover:bg-red-600'
            } text-white`}
          >
            {isLoggingOut ? 'Logging out...' : 'Logout'}
          </button>
        </div>

        {assignedProjects.length === 0 ? (
          <div className="text-center p-4">No projects assigned to you as a director.</div>
        ) : (
          <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
            {assignedProjects.map((project) => (
              <div
                key={project._id}
                onClick={() => router.push(`/allDashboards/director/${project._id}`)}
                className="bg-card rounded-lg shadow-lg p-6 cursor-pointer hover:shadow-xl transition-shadow"
              >
                <h2 className="text-xl font-semibold mb-2">{project.title}</h2>
                <p className="text-muted-foreground mb-4">{project.description}</p>
                <div className="text-sm text-muted-foreground">
                  <p>Source Language: {project.sourceLanguage}</p>
                  <p>Status: {project.status}</p>
                </div>
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  )
}


```

## File: components\RecordingTimer.tsx
```tsx
import React, { useState, useEffect } from 'react';
import { Alert } from './ui/alert';

interface RecordingTimerProps {
  isRecording: boolean;
  maxDuration: number;
}

const RecordingTimer: React.FC<RecordingTimerProps> = ({ isRecording, maxDuration }) => {
  const [time, setTime] = useState(0);
  const [showWarning, setShowWarning] = useState(false);

  useEffect(() => {
    let interval: NodeJS.Timeout;
    if (isRecording) {
      interval = setInterval(() => {
        setTime(prev => {
          const newTime = prev + 1;
          if (newTime >= maxDuration * 0.8 && !showWarning) {
            setShowWarning(true);
          }
          if (newTime >= maxDuration) {
            return maxDuration;
          }
          return newTime;
        });
      }, 1000);
    } else {
      setTime(0);
      setShowWarning(false);
    }

    return () => clearInterval(interval);
  }, [isRecording, maxDuration, showWarning]);

  useEffect(() => {
    if (time < maxDuration * 0.8 && showWarning) {
      setShowWarning(false);
    }
  }, [time, maxDuration, showWarning]);

  return (
    <div className="space-y-2">
      <div className="flex justify-between text-sm">
        <span>{String(Math.floor(time / 60)).padStart(2, '0')}:{String(time % 60).padStart(2, '0')}</span>
        <span className="text-gray-500">Max: {maxDuration}s</span>
      </div>
      <div className="h-1.5 bg-gray-200 rounded-full overflow-hidden">
        <div 
          className={`h-full transition-all duration-300 ${
            time / maxDuration > 0.8 ? 'bg-red-500' : 
            time / maxDuration > 0.5 ? 'bg-yellow-500' : 'bg-green-500'
          }`}
          style={{ width: `${(time / maxDuration) * 100}%` }}
        />
      </div>
      {showWarning && (
        <Alert className="py-1 text-sm">
          Recording will stop in {maxDuration - time} seconds
        </Alert>
      )}
    </div>
  );
};

export default RecordingTimer; 
```

## File: components\TranscriberDialogueView.tsx
```tsx
import { useState, useRef, useEffect } from 'react'
import { useQueryClient } from '@tanstack/react-query'
import { motion, useMotionValue, useTransform, useAnimation, type PanInfo } from 'framer-motion'
import axios from 'axios'

interface Dialogue {
  _id: string
  index: number
  timeStart: string
  timeEnd: string
  character: string
  videoUrl: string
  projectId?: string
  dialogue: {
    original: string
    translated: string
    adapted: string
  }
  status: string
}

interface DialogueViewProps {
  dialogues: Dialogue[]
  projectId: string
}

type QueryData = {
  data: Dialogue[];
  status: string;
  timestamp: number;
};

export default function TranscriberDialogueView({ dialogues: initialDialogues, projectId }: DialogueViewProps) {
  const [dialoguesList, setDialoguesList] = useState(initialDialogues);
  const [currentDialogueIndex, setCurrentDialogueIndex] = useState(0);
  const [isSaving, setIsSaving] = useState(false);
  const [showSaveSuccess, setShowSaveSuccess] = useState(false);
  const [error, setError] = useState<string>('');
  const [character, setCharacter] = useState('');
  const [pendingOriginalText, setPendingOriginalText] = useState('');
  const [showConfirmation, setShowConfirmation] = useState(false);
  const [timeStart, setTimeStart] = useState('');
  const [timeEnd, setTimeEnd] = useState('');
  const [isPlaying, setIsPlaying] = useState(false);
  const videoRef = useRef<HTMLVideoElement>(null);
  const queryClient = useQueryClient();
  const [networkStatus, setNetworkStatus] = useState<'idle' | 'saving' | 'error' | 'success'>('idle');
  const [currentTimestamp, setCurrentTimestamp] = useState('00:00.000');
  const [playbackRate, setPlaybackRate] = useState(1);
  const [isVideoLoading, setIsVideoLoading] = useState(true);

  const currentDialogue = dialoguesList[currentDialogueIndex];

  // Video control functions
  const togglePlayPause = () => {
    if (videoRef.current) {
      if (isPlaying) {
        videoRef.current.pause();
      } else {
        videoRef.current.play();
      }
      setIsPlaying(!isPlaying);
    }
  };

  // Check for unsaved changes
  const hasChanges = () => {
    if (!currentDialogue) return false;
    return (
      character !== currentDialogue.character ||
      pendingOriginalText !== currentDialogue.dialogue.original ||
      timeStart !== currentDialogue.timeStart ||
      timeEnd !== currentDialogue.timeEnd
    );
  };

  // Navigation handlers
  const handleNext = () => {
    if (hasChanges()) {
      setShowConfirmation(true);
    } else if (currentDialogueIndex < dialoguesList.length - 1) {
      setCurrentDialogueIndex(prev => prev + 1);
    }
  };

  const handlePrevious = () => {
    if (currentDialogueIndex > 0) {
      if (hasChanges()) {
        setShowConfirmation(true);
      } else {
        setCurrentDialogueIndex(prev => prev - 1);
      }
    }
  };

  // Reset changes and continue navigation
  const handleDiscardChanges = () => {
    setShowConfirmation(false);
    if (currentDialogue) {
      setCharacter(currentDialogue.character || '');
      setPendingOriginalText(currentDialogue.dialogue.original || '');
      setTimeStart(currentDialogue.timeStart);
      setTimeEnd(currentDialogue.timeEnd);
    }
  };

  // Save changes with approval
  const handleApproveAndSave = async () => {
    if (!currentDialogue) return;
    
    try {
      setNetworkStatus('saving');
      setIsSaving(true);
      
      if (currentDialogue.projectId !== projectId) {
        throw new Error('Project ID mismatch');
      }
      
      const updateData = {
        dialogue: {
          original: pendingOriginalText || currentDialogue.dialogue.original,
          translated: currentDialogue.dialogue.translated || '',
          adapted: currentDialogue.dialogue.adapted || '',
        },
        character: character || currentDialogue.character || '',
        status: 'transcribed',
        timeStart: timeStart || currentDialogue.timeStart,
        timeEnd: timeEnd || currentDialogue.timeEnd,
        index: currentDialogue.index,
        projectId
      };
      
      console.log('Save attempt:', {
        dialogueId: currentDialogue._id,
        currentProjectId: projectId,
        dialogueProjectId: currentDialogue.projectId,
        updateData
      });
      
      const { data: responseData } = await axios.patch(
        `/api/dialogues/${currentDialogue._id}`,
        updateData
      );
      
      setDialoguesList(prevDialogues => 
        prevDialogues.map(d => 
          d._id === currentDialogue._id ? responseData : d
        )
      );

      queryClient.setQueryData(['dialogues', projectId], (oldData: QueryData | undefined) => {
        if (!oldData?.data) return oldData;
        return {
          ...oldData,
          data: oldData.data.map((d: Dialogue) => 
            d._id === currentDialogue._id ? responseData : d
          )
        };
      });

      setNetworkStatus('success');
      setShowConfirmation(false);
      setTimeout(() => setNetworkStatus('idle'), 2000);

      if (currentDialogueIndex < dialoguesList.length - 1) {
        setCurrentDialogueIndex(prev => prev + 1);
      }
    } catch (error) {
      console.error('Save error details:', {
        error,
        dialogue: currentDialogue,
        projectContext: {
          componentProjectId: projectId,
          dialogueProjectId: currentDialogue.projectId,
          dialogueId: currentDialogue._id
        },
        requestData: {
          character,
          pendingOriginalText,
          timeStart,
          timeEnd,
        }
      });
      
      setNetworkStatus('error');
      setError(
        error instanceof Error 
          ? `Save failed: ${error.message}` 
          : 'Failed to save transcription'
      );
    } finally {
      setIsSaving(false);
    }
  };

  // Motion values for swipe animation
  const x = useMotionValue(0)
  const rotate = useTransform(x, [-90, 90], [-10, 10])
  const opacity = useTransform(x, [-200, -150, 0, 150, 200], [0.5, 1, 1, 1, 0.5])
  const scale = useTransform(x, [-200, -150, 0, 150, 200], [0.8, 0.9, 1, 0.9, 0.8])
  const animControls = useAnimation()

  useEffect(() => {
    if (currentDialogue) {
      setCharacter(currentDialogue.character || '')
      setPendingOriginalText(currentDialogue.dialogue.original || '')
      setTimeStart(currentDialogue.timeStart)
      setTimeEnd(currentDialogue.timeEnd)
    }
  }, [currentDialogue])

  useEffect(() => {
    const video = videoRef.current;
    if (video) {
      const handlePlay = () => setIsPlaying(true);
      const handlePause = () => setIsPlaying(false);
      
      video.addEventListener('play', handlePlay);
      video.addEventListener('pause', handlePause);
      
      return () => {
        video.removeEventListener('play', handlePlay);
        video.removeEventListener('pause', handlePause);
      };
    }
  }, []);

  const handleDragEnd = (event: MouseEvent | TouchEvent | PointerEvent, info: PanInfo) => {
    const SWIPE_THRESHOLD = 50;
    const velocity = Math.abs(info.velocity.x);
    const offset = Math.abs(info.offset.x);

    if (offset < SWIPE_THRESHOLD || velocity < 0.5) {
      animControls.start({ x: 0, opacity: 1 })
      return;
    }

    const direction = info.offset.x > 0 ? 'right' : 'left'
    
    if (direction === 'left' && currentDialogueIndex < dialoguesList.length - 1) {
      animControls.start({ 
        x: -200, 
        opacity: 0,
        transition: { duration: 0.2 }
      }).then(() => {
        handleNext();
        animControls.set({ x: 0, opacity: 1 });
      });
    } else if (direction === 'right' && currentDialogueIndex > 0) {
      animControls.start({ 
        x: 200, 
        opacity: 0,
        transition: { duration: 0.2 }
      }).then(() => {
        handlePrevious();
        animControls.set({ x: 0, opacity: 1 });
      });
    }
  };

  // Add new keyboard controls
  useEffect(() => {
    const handleKeyPress = (e: KeyboardEvent) => {
      if (e.target instanceof HTMLTextAreaElement || e.target instanceof HTMLInputElement) {
        return; // Don't trigger shortcuts when typing
      }
      
      switch(e.key.toLowerCase()) {
        case ' ':
          e.preventDefault();
          togglePlayPause();
          break;
        case 'arrowleft':
          e.preventDefault();
          handlePrevious();
          break;
        case 'arrowright':
          e.preventDefault();
          handleNext();
          break;
        case 's':
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            if (hasChanges()) {
              handleApproveAndSave();
            }
          }
          break;
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [togglePlayPause, handlePrevious, handleNext, hasChanges, handleApproveAndSave]);

  // Add timestamp marker functionality
  const formatTime = (seconds: number): string => {
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = Math.floor(seconds % 60);
    const milliseconds = Math.floor((seconds % 1) * 1000);
    return `${String(minutes).padStart(2, '0')}:${String(remainingSeconds).padStart(2, '0')}.${String(milliseconds).padStart(3, '0')}`;
  };

  const handleVideoTimeUpdate = () => {
    if (videoRef.current) {
      const currentTime = videoRef.current.currentTime;
      setCurrentTimestamp(formatTime(currentTime));
    }
  };

  // Add auto-save functionality
  useEffect(() => {
    let autoSaveTimeout: NodeJS.Timeout;

    if (hasChanges()) {
      autoSaveTimeout = setTimeout(() => {
        handleApproveAndSave();
      }, 30000); // Auto-save after 30 seconds of inactivity
    }

    return () => clearTimeout(autoSaveTimeout);
  }, [pendingOriginalText, character, timeStart, timeEnd]);

  // Add status indicator component
  const NetworkStatusIndicator = () => {
    const statusConfig = {
      saving: { bg: 'bg-blue-500', text: 'Saving...' },
      error: { bg: 'bg-red-500', text: 'Error saving' },
      success: { bg: 'bg-green-500', text: 'Saved!' },
    };

    if (networkStatus === 'idle') return null;

    const config = statusConfig[networkStatus as keyof typeof statusConfig];
    
    return (
      <div className={`fixed bottom-20 left-1/2 transform -translate-x-1/2 ${config.bg} text-white px-4 py-2 rounded-full shadow-lg text-sm`}>
        {config.text}
      </div>
    );
  };

  // Add video control functions
  const rewindFiveSeconds = () => {
    if (videoRef.current) {
      videoRef.current.currentTime = Math.max(0, videoRef.current.currentTime - 5);
    }
  };

  const changePlaybackRate = (rate: number) => {
    if (videoRef.current) {
      videoRef.current.playbackRate = rate;
      setPlaybackRate(rate);
    }
  };

  // Add video loading event handlers
  useEffect(() => {
    const video = videoRef.current;
    if (video) {
      const handleLoadStart = () => setIsVideoLoading(true);
      const handleCanPlay = () => setIsVideoLoading(false);
      const handleWaiting = () => setIsVideoLoading(true);
      const handlePlaying = () => setIsVideoLoading(false);
      
      video.addEventListener('loadstart', handleLoadStart);
      video.addEventListener('canplay', handleCanPlay);
      video.addEventListener('waiting', handleWaiting);
      video.addEventListener('playing', handlePlaying);
      
      return () => {
        video.removeEventListener('loadstart', handleLoadStart);
        video.removeEventListener('canplay', handleCanPlay);
        video.removeEventListener('waiting', handleWaiting);
        video.removeEventListener('playing', handlePlaying);
      };
    }
  }, []);

  if (!currentDialogue) {
    return <div className="text-center p-4">No dialogues available.</div>
  }

  return (
    <div className="w-full max-w-4xl mx-auto px-4 space-y-4 sm:space-y-6">
      {/* Video Player Card */}
      <div className="bg-white border border-gray-200 rounded-lg shadow dark:bg-gray-800 dark:border-gray-700 overflow-hidden">
        <div className="relative">
          <video
            ref={videoRef}
            src={currentDialogue.videoUrl}
            className="w-full"
          />
          {isVideoLoading && (
            <div className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-50">
              <div className="flex flex-col items-center gap-2">
                <div className="animate-spin rounded-full h-10 w-10 border-b-2 border-white"></div>
                <span className="text-sm text-white">Loading video...</span>
              </div>
            </div>
          )}
        </div>
        
        {/* Video Controls */}
        <div className="p-3 flex items-center justify-center gap-2 flex-wrap">
          <div className="flex items-center gap-2">
            <button
              onClick={rewindFiveSeconds}
              className="px-3 py-1 bg-blue-500 text-white rounded hover:bg-blue-600"
            >
              -5s
            </button>
            <button
              onClick={togglePlayPause}
              className="px-4 py-1 bg-blue-500 text-white rounded hover:bg-blue-600"
            >
              {isPlaying ? 'Pause' : 'Play'}
            </button>
          </div>
          <div className="flex items-center gap-2">
            <span className="text-gray-700 dark:text-gray-300">Speed:</span>
            {[0.5, 0.75, 1].map((rate) => (
              <button
                key={rate}
                onClick={() => changePlaybackRate(rate)}
                className={`px-2 py-1 rounded ${
                  playbackRate === rate
                    ? 'bg-blue-500 text-white'
                    : 'bg-gray-100 text-gray-700 hover:bg-gray-200 dark:bg-gray-700 dark:text-gray-300 dark:hover:bg-gray-600'
                }`}
              >
                {rate}x
              </button>
            ))}
          </div>
        </div>
      </div>

      {/* Dialogue Information Card */}
      <motion.div
        className="bg-white border border-gray-200 rounded-lg shadow dark:bg-gray-800 dark:border-gray-700"
        drag="x"
        dragConstraints={{ left: 0, right: 0 }}
        dragElastic={0.2}
        animate={animControls}
        style={{ x, rotate, opacity, scale }}
        onDragEnd={handleDragEnd}
        whileTap={{ cursor: 'grabbing' }}
        transition={{ 
          type: "spring", 
          stiffness: 300, 
          damping: 30,
          opacity: { duration: 0.2 },
          scale: { duration: 0.2 }
        }}
      >
        <div className="p-3 sm:p-5 space-y-3 sm:space-y-4">
          {/* Character Input */}
          <div>
            <label htmlFor="character" className="block text-sm font-medium mb-1 text-gray-900 dark:text-white">
              Character
            </label>
            <input
              type="text"
              id="character"
              value={character}
              onChange={(e) => setCharacter(e.target.value)}
              className="w-full p-2 text-sm rounded-lg border border-gray-300 bg-gray-50 text-gray-900 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white"
            />
          </div>

          {/* Transcription Text */}
          <div>
            <label htmlFor="originalText" className="block text-sm font-medium mb-1 text-gray-900 dark:text-white">
              Transcription
            </label>
            <textarea
              id="originalText"
              value={pendingOriginalText}
              onChange={(e) => setPendingOriginalText(e.target.value)}
              rows={3}
              className="w-full p-2 text-sm rounded-lg border border-gray-300 bg-gray-50 text-gray-900 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white resize-y min-h-[100px]"
              placeholder="Type the dialogue transcription here..."
            />
          </div>

          {/* Navigation and Info */}
          <div className="flex items-center justify-center pt-3 sm:pt-4 mt-3 sm:mt-4 border-t border-gray-200 dark:border-gray-600">
            <div className="text-center">
              <div className="text-sm font-medium text-gray-900 dark:text-white">
                Dialogue {currentDialogueIndex + 1} of {dialoguesList.length}
              </div>
              <div className="text-xs text-gray-500 dark:text-gray-400">
                {timeStart} - {timeEnd}
              </div>
            </div>
          </div>
        </div>
      </motion.div>

      {/* Confirmation Modal */}
      {showConfirmation && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
          <div className="bg-white dark:bg-gray-800 p-4 sm:p-6 rounded-lg shadow-xl max-w-md w-full">
            <h3 className="text-lg font-semibold mb-4">Unsaved Changes</h3>
            <p className="mb-4">You have unsaved changes. What would you like to do?</p>
            <div className="flex flex-col sm:flex-row justify-end gap-2 sm:gap-4">
              <button
                onClick={handleDiscardChanges}
                className="px-4 py-2 text-gray-600 hover:text-gray-800 dark:text-gray-300 dark:hover:text-white text-sm"
              >
                Discard Changes
              </button>
              <button
                onClick={() => setShowConfirmation(false)}
                className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 text-sm"
              >
                Keep Editing
              </button>
              <button
                onClick={handleApproveAndSave}
                disabled={isSaving}
                className="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600 disabled:opacity-50 disabled:cursor-not-allowed text-sm"
              >
                {isSaving ? 'Saving...' : 'Save Transcription'}
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Feedback Messages */}
      <div className="fixed top-4 right-4 left-4 sm:left-auto z-50 flex flex-col gap-2">
        {isSaving && (
          <div className="bg-blue-500 text-white px-4 py-2 rounded shadow-lg text-sm text-center sm:text-left">
            Saving transcription...
          </div>
        )}
        
        {showSaveSuccess && (
          <div className="bg-green-500 text-white px-4 py-2 rounded shadow-lg text-sm text-center sm:text-left">
            Transcription saved successfully!
          </div>
        )}
        
        {error && (
          <div className="bg-red-500 text-white px-4 py-2 rounded shadow-lg text-sm text-center sm:text-left">
            {error}
          </div>
        )}
      </div>

      {/* Network status indicator */}
      <NetworkStatusIndicator />
    </div>
  )
} 
```

## File: components\TranscriberView.tsx
```tsx
'use client'

import { useSession, signOut } from 'next-auth/react'
import { useRouter } from 'next/navigation'
import { useState } from 'react'

interface Project {
  _id: string
  title: string
  description: string
  sourceLanguage: string
  targetLanguage: string
  status: string
  assignedTo: Array<{
    username: string
    role: string
  }>
}

export default function TranscriberView({ projects }: { projects: Project[] }) {
  const { data: session } = useSession()
  const router = useRouter()
  const [isLoggingOut, setIsLoggingOut] = useState(false)

  // Filter projects assigned to current user as transcriber
  const assignedProjects = projects.filter(project => 
    project.assignedTo.some(assignment => 
      assignment.username === session?.user?.username && 
      assignment.role === 'transcriber'
    )
  )

  const handleLogout = async () => {
    try {
      setIsLoggingOut(true)
      // Clear any client-side session data
      if (typeof window !== 'undefined') {
        window.localStorage.clear()
      }
      // Use direct redirect
      await signOut({ 
        redirect: true,
        callbackUrl: '/login'
      })
    } catch (error) {
      console.error('Error during signOut:', error)
      // Fallback redirect if signOut fails
      router.replace('/login')
    } finally {
      setIsLoggingOut(false)
    }
  }

  return (
    <div className="min-h-screen bg-background">
      <div className="max-w-7xl mx-auto px-4 py-6">
        <div className="flex justify-between items-center mb-6 w-full">
          <h1 className="text-2xl font-bold text-foreground">Your Projects</h1>
          <button 
            onClick={handleLogout}
            disabled={isLoggingOut}
            className={`z-50 px-4 py-2 rounded transition-colors ${
              isLoggingOut 
                ? 'bg-gray-400 cursor-not-allowed' 
                : 'bg-red-500 hover:bg-red-600'
            } text-white`}
          >
            {isLoggingOut ? 'Logging out...' : 'Logout'}
          </button>
        </div>

        {assignedProjects.length === 0 ? (
          <div className="text-center p-4">No projects assigned to you as a transcriber.</div>
        ) : (
          <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
            {assignedProjects.map((project) => (
              <div
                key={project._id}
                onClick={() => router.push(`/allDashboards/transcriber/${project._id}`)}
                className="bg-card rounded-lg shadow-lg p-6 cursor-pointer hover:shadow-xl transition-shadow"
              >
                <h2 className="text-xl font-semibold mb-2">{project.title}</h2>
                <p className="text-muted-foreground mb-4">{project.description}</p>
                <div className="text-sm text-muted-foreground">
                  <p>Source Language: {project.sourceLanguage}</p>
                  <p>Status: {project.status}</p>
                </div>
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  )
}


```

## File: components\TranslatorDialogueView.tsx
```tsx
import { useState, useRef, useEffect } from 'react'
import { useQueryClient } from '@tanstack/react-query'
import { motion, useMotionValue, useTransform, useAnimation, type PanInfo } from 'framer-motion'
import axios from 'axios'

interface Dialogue {
  _id: string
  index: number
  timeStart: string
  timeEnd: string
  character: string
  videoUrl: string
  dialogue: {
    original: string
    translated: string
    adapted: string
  }
  status: string
}

interface DialogueViewProps {
  dialogues: Dialogue[]
  projectId: string
}

type QueryData = {
  data: Dialogue[];
  status: string;
  timestamp: number;
};

export default function TranslatorDialogueView({ dialogues: initialDialogues, projectId }: DialogueViewProps) {
  const [dialoguesList, setDialoguesList] = useState(initialDialogues);
  const [currentDialogueIndex, setCurrentDialogueIndex] = useState(0);
  const [isSaving, setIsSaving] = useState(false);
  const [showSaveSuccess, setShowSaveSuccess] = useState(false);
  const [error, setError] = useState<string>('');
  const [pendingTranslatedText, setPendingTranslatedText] = useState('');
  const [pendingAdaptedText, setPendingAdaptedText] = useState('');
  const [showConfirmation, setShowConfirmation] = useState(false);
  const videoRef = useRef<HTMLVideoElement>(null);
  const queryClient = useQueryClient();
  const [isPlaying, setIsPlaying] = useState(false);
  const [playbackRate, setPlaybackRate] = useState(1);
  const [isVideoLoading, setIsVideoLoading] = useState(true);
  const translationTextareaRef = useRef<HTMLTextAreaElement>(null);
  const adaptedTextareaRef = useRef<HTMLTextAreaElement>(null);

  const currentDialogue = dialoguesList[currentDialogueIndex];

  // Check for unsaved changes
  const hasChanges = () => {
    if (!currentDialogue) return false;
    return pendingTranslatedText !== currentDialogue.dialogue.translated || 
           pendingAdaptedText !== currentDialogue.dialogue.adapted;
  };

  // Navigation handlers
  const handleNext = () => {
    if (hasChanges()) {
      setShowConfirmation(true);
    } else if (currentDialogueIndex < dialoguesList.length - 1) {
      setCurrentDialogueIndex(prev => prev + 1);
    }
  };

  const handlePrevious = () => {
    if (currentDialogueIndex > 0) {
      if (hasChanges()) {
        setShowConfirmation(true);
      } else {
        setCurrentDialogueIndex(prev => prev - 1);
      }
    }
  };

  // Reset changes and continue navigation
  const handleDiscardChanges = () => {
    setShowConfirmation(false);
    if (currentDialogue) {
      setPendingTranslatedText(currentDialogue.dialogue.translated || '');
      setPendingAdaptedText(currentDialogue.dialogue.adapted || '');
    }
  };

  // Save changes with approval
  const handleApproveAndSave = async () => {
    if (!currentDialogue) return;
    
    try {
      setIsSaving(true);
      
      const updateData = {
        dialogue: {
          original: currentDialogue.dialogue.original || '',
          translated: pendingTranslatedText || '',
          adapted: pendingAdaptedText || '',
        },
        character: currentDialogue.character || '',
        status: 'translated',
        timeStart: currentDialogue.timeStart || '',
        timeEnd: currentDialogue.timeEnd || '',
        index: currentDialogue.index,
        projectId
      };
      
      console.log('Translation save attempt:', {
        dialogueId: currentDialogue._id,
        projectId,
        updateData
      });
      
      const { data: responseData } = await axios.patch(
        `/api/dialogues/${currentDialogue._id}`,
        updateData
      );
      
      setDialoguesList(prevDialogues => 
        prevDialogues.map(d => 
          d._id === currentDialogue._id ? responseData : d
        )
      );

      queryClient.setQueryData(['dialogues', projectId], (oldData: QueryData | undefined) => {
        if (!oldData?.data) return oldData;
        return {
          ...oldData,
          data: oldData.data.map((d: Dialogue) => 
            d._id === currentDialogue._id ? responseData : d
          )
        };
      });

      setShowSaveSuccess(true);
      setShowConfirmation(false);
      setTimeout(() => setShowSaveSuccess(false), 2000);

      if (currentDialogueIndex < dialoguesList.length - 1) {
        setCurrentDialogueIndex(prev => prev + 1);
      }
    } catch (error) {
      console.error('Translation save error:', {
        error,
        dialogue: currentDialogue,
        projectId,
        requestData: {
          translated: pendingTranslatedText,
          adapted: pendingAdaptedText
        }
      });
      setError(error instanceof Error ? error.message : 'Failed to save translation');
      setTimeout(() => setError(''), 3000);
    } finally {
      setIsSaving(false);
    }
  };

  // Motion values for swipe animation
  const x = useMotionValue(0)
  const rotate = useTransform(x, [-90, 90], [-10, 10])
  const opacity = useTransform(x, [-200, -150, 0, 150, 200], [0.5, 1, 1, 1, 0.5])
  const scale = useTransform(x, [-200, -150, 0, 150, 200], [0.8, 0.9, 1, 0.9, 0.8])
  const animControls = useAnimation()

  useEffect(() => {
    if (currentDialogue) {
      setPendingTranslatedText(currentDialogue.dialogue.translated || '')
      setPendingAdaptedText(currentDialogue.dialogue.adapted || '')
    }
  }, [currentDialogue])

  const handleDragEnd = (event: MouseEvent | TouchEvent | PointerEvent, info: PanInfo) => {
    const SWIPE_THRESHOLD = 50;
    const velocity = Math.abs(info.velocity.x);
    const offset = Math.abs(info.offset.x);

    if (offset < SWIPE_THRESHOLD || velocity < 0.5) {
      animControls.start({ x: 0, opacity: 1 })
      return;
    }

    const direction = info.offset.x > 0 ? 'right' : 'left'
    
    if (direction === 'left' && currentDialogueIndex < dialoguesList.length - 1) {
      animControls.start({ 
        x: -200, 
        opacity: 0,
        transition: { duration: 0.2 }
      }).then(() => {
        handleNext();
        animControls.set({ x: 0, opacity: 1 });
      });
    } else if (direction === 'right' && currentDialogueIndex > 0) {
      animControls.start({ 
        x: 200, 
        opacity: 0,
        transition: { duration: 0.2 }
      }).then(() => {
        handlePrevious();
        animControls.set({ x: 0, opacity: 1 });
      });
    }
  };


  // Add video control functions
  const togglePlayPause = () => {
    if (videoRef.current) {
      if (isPlaying) {
        videoRef.current.pause();
      } else {
        videoRef.current.play();
      }
      setIsPlaying(!isPlaying);
    }
  };

  const rewindFiveSeconds = () => {
    if (videoRef.current) {
      videoRef.current.currentTime = Math.max(0, videoRef.current.currentTime - 5);
    }
  };

  const changePlaybackRate = (rate: number) => {
    if (videoRef.current) {
      videoRef.current.playbackRate = rate;
      setPlaybackRate(rate);
    }
  };

  // Add useEffect for video event listeners
  useEffect(() => {
    const video = videoRef.current;
    if (video) {
      const handlePlay = () => setIsPlaying(true);
      const handlePause = () => setIsPlaying(false);
      
      video.addEventListener('play', handlePlay);
      video.addEventListener('pause', handlePause);
      
      return () => {
        video.removeEventListener('play', handlePlay);
        video.removeEventListener('pause', handlePause);
      };
    }
  }, []);

  // Add video loading event handlers
  useEffect(() => {
    const video = videoRef.current;
    if (video) {
      const handleLoadStart = () => setIsVideoLoading(true);
      const handleCanPlay = () => setIsVideoLoading(false);
      const handleWaiting = () => setIsVideoLoading(true);
      const handlePlaying = () => setIsVideoLoading(false);
      
      video.addEventListener('loadstart', handleLoadStart);
      video.addEventListener('canplay', handleCanPlay);
      video.addEventListener('waiting', handleWaiting);
      video.addEventListener('playing', handlePlaying);
      
      return () => {
        video.removeEventListener('loadstart', handleLoadStart);
        video.removeEventListener('canplay', handleCanPlay);
        video.removeEventListener('waiting', handleWaiting);
        video.removeEventListener('playing', handlePlaying);
      };
    }
  }, []);

  // Function to adjust textarea height
  const adjustTextareaHeight = (textarea: HTMLTextAreaElement | null) => {
    if (textarea) {
      textarea.style.height = 'auto';
      textarea.style.height = `${textarea.scrollHeight}px`;
    }
  };

  // Adjust heights when text changes
  useEffect(() => {
    adjustTextareaHeight(translationTextareaRef.current);
  }, [pendingTranslatedText]);

  useEffect(() => {
    adjustTextareaHeight(adaptedTextareaRef.current);
  }, [pendingAdaptedText]);

  // Adjust heights when dialogue changes
  useEffect(() => {
    if (currentDialogue) {
      setPendingTranslatedText(currentDialogue.dialogue.translated || '');
      setPendingAdaptedText(currentDialogue.dialogue.adapted || '');
      // Add small delay to ensure state is updated before adjusting height
      setTimeout(() => {
        adjustTextareaHeight(translationTextareaRef.current);
        adjustTextareaHeight(adaptedTextareaRef.current);
      }, 0);
    }
  }, [currentDialogue]);

  if (!currentDialogue) {
    return <div className="text-center p-4">No dialogues available.</div>
  }

  return (
    <div className="w-full max-w-4xl mx-auto px-4 space-y-4 sm:space-y-6">
      {/* Video Player Card */}
      <div className="bg-white border border-gray-200 rounded-lg shadow dark:bg-gray-800 dark:border-gray-700 overflow-hidden">
        <div className="relative">
          <video
            ref={videoRef}
            src={currentDialogue.videoUrl}
            className="w-full"
          />
          {isVideoLoading && (
            <div className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-50">
              <div className="flex flex-col items-center gap-2">
                <div className="animate-spin rounded-full h-10 w-10 border-b-2 border-white"></div>
                <span className="text-sm text-white">Loading video...</span>
              </div>
            </div>
          )}
        </div>
        
        {/* Video Controls */}
        <div className="p-3 flex items-center justify-center gap-2 flex-wrap">
          <div className="flex items-center gap-2">
            <button
              onClick={rewindFiveSeconds}
              className="px-3 py-1 bg-blue-500 text-white rounded hover:bg-blue-600"
            >
              -5s
            </button>
            <button
              onClick={togglePlayPause}
              className="px-4 py-1 bg-blue-500 text-white rounded hover:bg-blue-600"
            >
              {isPlaying ? 'Pause' : 'Play'}
            </button>
          </div>
          <div className="flex items-center gap-2">
            <span className="text-gray-700 dark:text-gray-300">Speed:</span>
            {[0.5, 0.75, 1].map((rate) => (
              <button
                key={rate}
                onClick={() => changePlaybackRate(rate)}
                className={`px-2 py-1 rounded ${
                  playbackRate === rate
                    ? 'bg-blue-500 text-white'
                    : 'bg-gray-100 text-gray-700 hover:bg-gray-200 dark:bg-gray-700 dark:text-gray-300 dark:hover:bg-gray-600'
                }`}
              >
                {rate}x
              </button>
            ))}
          </div>
        </div>
      </div>

      {/* Main Content Card */}
      <motion.div
        className="bg-white border border-gray-200 rounded-lg shadow dark:bg-gray-800 dark:border-gray-700"
        drag="x"
        dragConstraints={{ left: 0, right: 0 }}
        dragElastic={0.2}
        animate={animControls}
        style={{ x, rotate, opacity, scale }}
        onDragEnd={handleDragEnd}
        whileTap={{ cursor: 'grabbing' }}
        transition={{ 
          type: "spring", 
          stiffness: 300, 
          damping: 30,
          opacity: { duration: 0.2 },
          scale: { duration: 0.2 }
        }}
      >
        <div className="p-3 sm:p-5 space-y-3 sm:space-y-4">
          {/* Character Display */}
          {/* <div className="flex items-center gap-2">
            <span className="text-sm font-medium text-gray-900 dark:text-white">
              Character:
            </span>
            <span className="text-gray-900 dark:text-white">
              {currentDialogue.character}
            </span>
          </div> */}

          {/* Original Text */}
          <div>
            <label className="block text-sm font-medium mb-1 text-gray-900 dark:text-white">
              Original Text
            </label>
            <div className="w-full p-2 text-gray-900 dark:text-white">
              {currentDialogue.dialogue.original}
            </div>
          </div>

          {/* Translation Input */}
          <div>
            <label htmlFor="translatedText" className="block text-sm font-medium mb-1 text-gray-900 dark:text-white">
              Translation
            </label>
            <textarea
              ref={translationTextareaRef}
              id="translatedText"
              value={pendingTranslatedText}
              onChange={(e) => setPendingTranslatedText(e.target.value)}
              className="w-full p-2 rounded-lg border border-gray-300 bg-gray-50 text-gray-900 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white resize-none"
            />
          </div>

          {/* Adapted Text Input */}
          <div>
            <label htmlFor="adaptedText" className="block text-sm font-medium mb-1 text-gray-900 dark:text-white">
              Adapted
            </label>
            <textarea
              ref={adaptedTextareaRef}
              id="adaptedText"
              value={pendingAdaptedText}
              onChange={(e) => setPendingAdaptedText(e.target.value)}
              className="w-full p-2 rounded-lg border border-gray-300 bg-gray-50 text-gray-900 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white resize-none"
            />
          </div>

          {/* Navigation and Info */}
          <div className="flex items-center justify-center pt-3 sm:pt-4 mt-3 sm:mt-4 border-t border-gray-200 dark:border-gray-600">
            <div className="text-center">
              <div className="text-sm font-medium text-gray-900 dark:text-white">
                Dialogue {currentDialogueIndex + 1} of {dialoguesList.length}
              </div>
              <div className="text-xs text-gray-500 dark:text-gray-400">
                {currentDialogue.timeStart} - {currentDialogue.timeEnd}
              </div>
            </div>
          </div>
        </div>
      </motion.div>

      {/* Confirmation Modal */}
      {showConfirmation && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
          <div className="bg-white dark:bg-gray-800 p-4 sm:p-6 rounded-lg shadow-xl max-w-md w-full">
            <h3 className="text-lg font-semibold mb-4">Unsaved Changes</h3>
            <p className="mb-4">You have unsaved changes. What would you like to do?</p>
            <div className="flex justify-end gap-2 sm:gap-4">
              <button
                onClick={handleDiscardChanges}
                className="px-4 py-2 text-gray-600 hover:text-gray-800 dark:text-gray-300 dark:hover:text-white text-sm"
              >
                Discard Changes
              </button>
              <button
                onClick={() => setShowConfirmation(false)}
                className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 text-sm"
              >
                Keep Editing
              </button>
              <button
                onClick={handleApproveAndSave}
                disabled={isSaving}
                className="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600 disabled:opacity-50 disabled:cursor-not-allowed text-sm"
              >
                {isSaving ? 'Saving...' : 'Save Translation'}
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Feedback Messages */}
      <div className="fixed top-4 right-4 left-4 sm:left-auto z-50 flex flex-col gap-2">
        {isSaving && (
          <div className="bg-blue-500 text-white px-4 py-2 rounded shadow-lg text-sm text-center sm:text-left">
            Saving translation...
          </div>
        )}
        
        {showSaveSuccess && (
          <div className="bg-green-500 text-white px-4 py-2 rounded shadow-lg text-sm text-center sm:text-left">
            Translation saved successfully!
          </div>
        )}
        
        {error && (
          <div className="bg-red-500 text-white px-4 py-2 rounded shadow-lg text-sm text-center sm:text-left">
            {error}
          </div>
        )}
      </div>
    </div>
  )
} 
```

## File: components\TranslatorView.tsx
```tsx
'use client'

import { useSession, signOut } from 'next-auth/react'
import { useRouter } from 'next/navigation'
import { useState } from 'react'

interface Project {
  _id: string
  title: string
  description: string
  sourceLanguage: string
  targetLanguage: string
  status: string
  assignedTo: Array<{
    username: string
    role: string
  }>
}

export default function TranslatorView({ projects }: { projects: Project[] }) {
  const { data: session } = useSession()
  const router = useRouter()
  const [isLoggingOut, setIsLoggingOut] = useState(false)

  // Filter projects assigned to current user as translator
  const assignedProjects = projects.filter(project => 
    project.assignedTo.some(assignment => 
      assignment.username === session?.user?.username && 
      assignment.role === 'translator'
    )
  )

  const handleLogout = async () => {
    try {
      setIsLoggingOut(true)
      // Clear any client-side session data
      if (typeof window !== 'undefined') {
        window.localStorage.clear()
      }
      // Use direct redirect
      await signOut({ 
        redirect: true,
        callbackUrl: '/login'
      })
    } catch (error) {
      console.error('Error during signOut:', error)
      // Fallback redirect if signOut fails
      router.replace('/login')
    } finally {
      setIsLoggingOut(false)
    }
  }

  return (
    <div className="min-h-screen bg-background">
      <div className="max-w-7xl mx-auto px-4 py-6">
        <div className="flex justify-between items-center mb-6 w-full">
          <h1 className="text-2xl font-bold text-foreground">Your Projects</h1>
          <button 
            onClick={handleLogout}
            disabled={isLoggingOut}
            className={`z-50 px-4 py-2 rounded transition-colors ${
              isLoggingOut 
                ? 'bg-gray-400 cursor-not-allowed' 
                : 'bg-red-500 hover:bg-red-600'
            } text-white`}
          >
            {isLoggingOut ? 'Logging out...' : 'Logout'}
          </button>
        </div>

        {assignedProjects.length === 0 ? (
          <div className="text-center p-4">No projects assigned to you as a translator.</div>
        ) : (
          <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
            {assignedProjects.map((project) => (
              <div
                key={project._id}
                onClick={() => router.push(`/allDashboards/translator/${project._id}`)}
                className="bg-card rounded-lg shadow-lg p-6 cursor-pointer hover:shadow-xl transition-shadow"
              >
                <h2 className="text-xl font-semibold mb-2">{project.title}</h2>
                <p className="text-muted-foreground mb-4">{project.description}</p>
                <div className="text-sm text-muted-foreground">
                  <p>Source Language: {project.sourceLanguage}</p>
                  <p>Status: {project.status}</p>
                </div>
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  )
} 
```

## File: components\ui\alert.tsx
```tsx
import React from 'react';
import { cn } from '../../utils/cn';

interface AlertProps extends React.HTMLAttributes<HTMLDivElement> {
  variant?: 'default' | 'destructive';
  className?: string;
  children: React.ReactNode;
}

export const Alert: React.FC<AlertProps> = ({
  className,
  variant = 'default',
  children,
  ...props
}) => {
  return (
    <div
      role="alert"
      className={cn(
        'rounded-lg border px-4 py-3 text-sm',
        variant === 'default' && 'bg-yellow-50 border-yellow-200 text-yellow-800',
        variant === 'destructive' && 'bg-red-50 border-red-200 text-red-800',
        className
      )}
      {...props}
    >
      {children}
    </div>
  );
}; 
```

## File: components\VoiceOverDialogueView.tsx
```tsx
// VoiceOverDialougeView.tsx

import React, { useState, useRef, useEffect, useCallback } from 'react'
import { useQueryClient } from '@tanstack/react-query'
import { motion, useMotionValue, useAnimation, type PanInfo } from 'framer-motion'
import { type Dialogue } from '../types/dialogue'
import { formatTime, getNumberValue, calculateDuration } from '../utils/formatters'
import { useAudioRecording } from '../hooks/useAudioRecording'
import axios from 'axios'
import AudioVisualizer from './AudioVisualizer'
import RecordingTimer from './RecordingTimer'

// Add new type for recording status
type RecordingStatus = 'available' | 'unavailable' | 'checking';

// Sub-components
const CharacterInfo = React.memo(({ 
  character, 
  voiceOverUrl 
}: { 
  character: string;
  voiceOverUrl?: string;
}) => {
  const [recordingStatus, setRecordingStatus] = useState<RecordingStatus>('checking');

  useEffect(() => {
    const checkRecordingStatus = async () => {
      if (!voiceOverUrl) {
        setRecordingStatus('unavailable');
        return;
      }

      try {
        await axios.head(voiceOverUrl);
        setRecordingStatus('available');
      } catch (error) {
        console.error('Error checking recording status:', error);
        setRecordingStatus('unavailable');
      }
    };

    checkRecordingStatus();
  }, [voiceOverUrl]);

  return (
    <div className="p-2 bg-gray-800">
      <div className="flex items-center justify-center gap-2">
        <span className="text-gray-400">Character:</span>
        <div className="flex items-center gap-2">
          <span className="text-white">{character}</span>
          <div 
            className={`w-3 h-3 rounded-full ${
              recordingStatus === 'checking' 
                ? 'bg-yellow-500 animate-pulse'
                : recordingStatus === 'available'
                ? 'bg-green-500'
                : 'bg-red-500'
            }`}
            title={
              recordingStatus === 'checking'
                ? 'Checking recording status...'
                : recordingStatus === 'available'
                ? 'Recording available'
                : 'Recording not available'
            }
          />
        </div>
      </div>
    </div>
  );
});

CharacterInfo.displayName = 'CharacterInfo';

const VideoPlayer = React.memo(({ 
  videoRef, 
  videoUrl, 
  isVideoLoading 
}: { 
  videoRef: React.RefObject<HTMLVideoElement>,
  videoUrl: string,
  isVideoLoading: boolean
}) => (
  <div className="relative">
    <video
      ref={videoRef}
      src={videoUrl}
      className="w-full aspect-video max-h-[200px] object-contain bg-black"
      aria-label="Dialogue video player"
    />
    {isVideoLoading && (
      <div className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-50">
        <div className="animate-spin rounded-full h-10 w-10 border-b-2 border-white"></div>
      </div>
    )}
  </div>
));

VideoPlayer.displayName = 'VideoPlayer';

const VideoControls = React.memo(({
  isPlaying,
  togglePlayPause,
  handleSyncedPlayback,
  isSyncedPlaying,
  hasRecording,
  audioDuration,
  videoDuration,
}: {
  isPlaying: boolean,
  togglePlayPause: () => void,
  handleSyncedPlayback: () => void,
  isSyncedPlaying: boolean,
  hasRecording: boolean,
  audioDuration: number,
  videoDuration: number,
}) => {
  const durationMatches = Math.abs(audioDuration - videoDuration) < 0.1; // Allow 100ms tolerance

  return (
    <div className="p-2 bg-gray-800 flex flex-col items-center gap-2">
      <div className="flex gap-2 items-center">
        <button
          onClick={togglePlayPause}
          className="px-4 py-1 bg-blue-500 text-white rounded hover:bg-blue-600 text-sm"
          aria-label={isPlaying ? 'Pause video' : 'Play video'}
        >
          {isPlaying ? 'Pause' : 'Play'}
        </button>
        {hasRecording && (
          <div className="flex items-center gap-2">
            <button
              onClick={handleSyncedPlayback}
              className="px-4 py-1 bg-purple-500 text-white rounded hover:bg-purple-600 text-sm"
              aria-label={isSyncedPlaying ? 'Stop synced playback' : 'Play with audio'}
            >
              {isSyncedPlaying ? 'Stop Synced' : 'Play with Audio'}
            </button>
            <div 
              className={`w-3 h-3 rounded-full ${durationMatches ? 'bg-green-500' : 'bg-red-500'}`}
              title={durationMatches 
                ? 'Audio and video durations match' 
                : `Duration mismatch - Video: ${videoDuration.toFixed(3)}s, Audio: ${audioDuration.toFixed(3)}s`}
            />
          </div>
        )}
      </div>
    </div>
  );
});

VideoControls.displayName = 'VideoControls';

const EmotionsDisplay = React.memo(({ emotions }: { emotions: Dialogue['emotions'] }) => (
  <div className="grid grid-cols-2 gap-4">
    <div>
      <span className="text-gray-400">Primary Emotion:</span>
      <p className="text-white">
        {emotions?.primary?.emotion ?? 'Not specified'} 
        {emotions?.primary?.intensity !== undefined && 
          `(Intensity: ${getNumberValue(emotions.primary.intensity)})`
        }
      </p>
    </div>
  </div>
));

EmotionsDisplay.displayName = 'EmotionsDisplay';

const RecordingControls = React.memo(({
  isRecording,
  isPlayingRecording,
  startRecording,
  stopRecording,
  handlePlayRecording,
  hasRecording,
  hasExistingRecording,
  currentIndex,
  totalCount,
  onReRecord,
  onDelete,
  localAudioBlob,
  isProcessing,
  countdown,
  isWaitingForVoice
}: {
  isRecording: boolean,
  isPlayingRecording: boolean,
  startRecording: () => Promise<void>,
  stopRecording: () => void,
  handlePlayRecording: () => void,
  hasRecording: boolean,
  hasExistingRecording: boolean,
  currentIndex: number,
  totalCount: number,
  onReRecord: () => void,
  onDelete: () => void,
  localAudioBlob: Blob | null,
  isProcessing: boolean,
  countdown: number,
  isWaitingForVoice: boolean
}) => {
  const handleStartRecording = async () => {
    if (isProcessing) return;
    
    try {
      await startRecording();
    } catch (error) {
      console.error('Failed to start recording:', error);
    }
  };

  const handleStopRecording = () => {
    try {
      stopRecording();
    } catch (error) {
      console.error('Failed to stop recording:', error);
    }
  };

  return (
    <div className="flex-shrink-0 fixed bottom-0 left-0 right-0 bg-gray-800 border-t border-gray-700">
      <div className="flex flex-col items-center py-4 space-y-4">
        <div className="flex items-center space-x-4">
          {!isRecording && hasExistingRecording && !localAudioBlob && (
            <button
              onClick={onReRecord}
              className="px-6 py-2 rounded-full bg-purple-500 hover:bg-purple-600 text-white transition-colors"
              aria-label="Re-record audio"
              title="Record a new version to replace existing audio"
              disabled={isProcessing}
            >
              Re-Record
            </button>
          )}

          {(!hasExistingRecording || isRecording || localAudioBlob) && (
            <button
              onClick={isRecording ? handleStopRecording : handleStartRecording}
              className={`px-6 py-2 rounded-full ${
                isRecording
                  ? 'bg-red-500 hover:bg-red-600'
                  : 'bg-blue-500 hover:bg-blue-600'
              } text-white transition-colors`}
              aria-label={isRecording ? 'Stop recording' : 'Start recording'}
              disabled={isProcessing}
            >
              {isProcessing && countdown > 0 ? (
                <span className="flex items-center">
                  <span className="text-lg font-bold mr-2">{countdown}</span>
                  Starting...
                </span>
              ) : isWaitingForVoice ? (
                <span className="flex items-center">
                  <span className="animate-pulse">Waiting for voice...</span>
                </span>
              ) : isRecording ? (
                'Stop Recording'
              ) : (
                'Start Recording'
              )}
            </button>
          )}

          {!isRecording && hasRecording && (
            <button
              onClick={handlePlayRecording}
              className={`px-6 py-2 rounded-full ${
                isPlayingRecording
                  ? 'bg-yellow-500 hover:bg-yellow-600'
                  : 'bg-green-500 hover:bg-green-600'
              } text-white transition-colors`}
              aria-label={isPlayingRecording ? 'Stop playing' : 'Play recorded audio'}
              title={isPlayingRecording ? 'Stop current playback' : 'Play recorded audio'}
              disabled={isProcessing}
            >
              {isPlayingRecording ? 'Stop Playing' : 'Play Recorded Audio'}
            </button>
          )}
        </div>

        <div className="text-sm text-gray-300">
          Dialogue {currentIndex + 1} of {totalCount}
        </div>
      </div>
    </div>
  );
});

RecordingControls.displayName = 'RecordingControls';

// Update the ConfirmationModal interface
interface ConfirmationModalProps {
  isOpen: boolean;
  onClose: () => void;
  onDiscard: () => void;
  onApprove: () => void;
  isSaving: boolean;
  type: 'navigation' | 'discard';
  direction?: 'next' | 'previous';
}

const ConfirmationModal = ({
  isOpen,
  onClose,
  onDiscard,
  onApprove,
  isSaving,
  type,
  direction
}: ConfirmationModalProps) => {
  if (!isOpen) return null;
  
  const getTitle = () => {
    if (type === 'navigation') {
      return 'Unsaved Changes - Navigation';
    }
    return 'Unsaved Changes';
  };

  const getMessage = () => {
    if (type === 'navigation') {
      return `You have unsaved changes. Would you like to save them before moving to the ${direction} dialogue?`;
    }
    return 'You have unsaved changes. What would you like to do?';
  };

  const getDiscardButtonText = () => {
    if (type === 'navigation') {
      return 'Discard and Continue';
    }
    return 'Delete Recording';
  };

  const getApproveButtonText = () => {
    if (isSaving) return 'Saving...';
    if (type === 'navigation') {
      return 'Save and Continue';
    }
    return 'Save';
  };
  
  return (
    <div 
      className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50"
      onClick={(e: React.MouseEvent<HTMLDivElement>) => {
        if (e.target === e.currentTarget) {
          onClose();
        }
      }}
      role="dialog"
      aria-modal="true"
      aria-labelledby="modal-title"
    >
      <div className="bg-gray-800 p-6 rounded-lg shadow-xl max-w-md w-full">
        <h3 id="modal-title" className="text-lg font-semibold mb-4 text-white">
          {getTitle()}
        </h3>
        <p className="mb-4 text-gray-300">
          {getMessage()}
        </p>
        <div className="flex justify-end space-x-4">
          <button
            onClick={onDiscard}
            className="px-4 py-2 text-gray-400 hover:text-white transition-colors"
            disabled={isSaving}
          >
            {getDiscardButtonText()}
          </button>
          <button
            onClick={onApprove}
            disabled={isSaving}
            className="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
          >
            {getApproveButtonText()}
          </button>
        </div>
      </div>
    </div>
  );
};

const Notifications = ({
  isSaving,
  showSaveSuccess,
  error
}: {
  isSaving: boolean,
  showSaveSuccess: boolean,
  error: string
}) => (
  <>
    {isSaving && (
      <div className="fixed top-4 right-4 bg-blue-500 text-white px-4 py-2 rounded shadow-lg z-50" role="alert">
        Approving voice-over...
      </div>
    )}
    
    {showSaveSuccess && (
      <div className="fixed top-4 right-4 bg-green-500 text-white px-4 py-2 rounded shadow-lg z-50" role="alert">
        Voice-over saved successfully!
      </div>
    )}
    
    {error && (
      <div className="fixed top-4 right-4 bg-red-500 text-white px-4 py-2 rounded shadow-lg z-50" role="alert">
        {error}
      </div>
    )}
  </>
)

const LoadingSpinner = () => (
  <div className="flex items-center justify-center h-screen bg-gray-900">
    <div className="animate-spin rounded-full h-16 w-16 border-b-2 border-white"></div>
  </div>
)

interface ErrorFallbackProps {
  error: AppError;
  resetError: () => void;
}

const ErrorFallback = ({ error, resetError }: ErrorFallbackProps) => (
  <div className="flex flex-col items-center justify-center h-screen bg-gray-900 text-white p-4">
    <h2 className="text-xl font-bold mb-4">Something went wrong</h2>
    <pre className="bg-gray-800 p-4 rounded mb-4 max-w-lg overflow-auto">
      {error.message}
      {error.code && <div className="text-sm text-gray-400 mt-2">Error code: {error.code}</div>}
      {error.status && <div className="text-sm text-gray-400">Status: {error.status}</div>}
    </pre>
    <button
      onClick={resetError}
      className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
    >
      Try again
    </button>
  </div>
)

interface DialogueViewProps {
  dialogues: Dialogue[];
  projectId: string;
}

interface QueryData {
  data: Dialogue[];
  status: string;
  timestamp: number;
}

interface AppError extends Error {
  code?: string;
  status?: number;
}

// Add logging utility
const logEvent = (message: string, data?: Record<string, unknown>): void => {
  console.log(message, data);
};

export default function VoiceOverDialogueView({ dialogues: initialDialogues, projectId }: DialogueViewProps) {
  const [dialoguesList, setDialoguesList] = useState(initialDialogues);
  const [currentDialogueIndex, setCurrentDialogueIndex] = useState(0);
  const [isSaving, setIsSaving] = useState(false);
  const [showSaveSuccess, setShowSaveSuccess] = useState(false);
  const [error, setError] = useState<string>('');
  const [showConfirmation, setShowConfirmation] = useState(false);
  const [isVideoLoading, setIsVideoLoading] = useState(false);
  const [localAudioBlob, setLocalAudioBlob] = useState<Blob | null>(null);
  const videoRef = useRef<HTMLVideoElement>(null);
  const queryClient = useQueryClient();
  const [isPlaying, setIsPlaying] = useState(false);
  const dragX = useMotionValue(0);
  const dragControls = useAnimation();
  const [confirmationType, setConfirmationType] = useState<'navigation' | 'discard'>('discard');
  const [navigationDirection, setNavigationDirection] = useState<'next' | 'previous' | undefined>();
  const [pendingNavigationIndex, setPendingNavigationIndex] = useState<number | null>(null);
  const [isSyncedPlaying, setIsSyncedPlaying] = useState(false);
  const audioRef = useRef<HTMLAudioElement | null>(null);
  const [audioDuration, setAudioDuration] = useState(0);

  const currentDialogue = dialoguesList[currentDialogueIndex];
  const maxDuration = currentDialogue ? calculateDuration(currentDialogue.timeStart, currentDialogue.timeEnd) : 0;

  const {
    audioBlob,
    isRecording,
    recordingDuration,
    isPlayingRecording,
    startRecording,
    stopRecording,
    handlePlayRecording,
    setPlayingState,
    isProcessing,
    countdown,
    isWaitingForVoice,
    audioStream
  } = useAudioRecording(currentDialogue);

  // Add audio player ref for remote audio
  const audioPlayerRef = useRef<HTMLAudioElement | null>(null);

  // Function to handle playing remote audio
  const handlePlayRemoteAudio = useCallback(() => {
    if (!currentDialogue?.voiceOverUrl) return;

    if (audioPlayerRef.current) {
      audioPlayerRef.current.pause();
      audioPlayerRef.current = null;
      setPlayingState(false);
      return;
    }

    const audio = new Audio(currentDialogue.voiceOverUrl);
    audioPlayerRef.current = audio;

    audio.addEventListener('ended', () => {
      setPlayingState(false);
      audioPlayerRef.current = null;
    });

    audio.addEventListener('error', () => {
      setPlayingState(false);
      audioPlayerRef.current = null;
      setError('Failed to play audio');
    });

    audio.play().then(() => {
      setPlayingState(true);
    }).catch(error => {
      console.error('Failed to play audio:', error);
      setError('Failed to play audio');
      audioPlayerRef.current = null;
    });
  }, [currentDialogue?.voiceOverUrl, setPlayingState]);

  // Combined play function
  const handlePlayAudio = useCallback(() => {
    if (localAudioBlob) {
      handlePlayRecording();
    } else if (currentDialogue?.voiceOverUrl) {
      handlePlayRemoteAudio();
    }
  }, [localAudioBlob, currentDialogue?.voiceOverUrl, handlePlayRecording, handlePlayRemoteAudio]);

  // Cleanup audio on unmount or dialogue change
  useEffect(() => {
    return () => {
      if (audioPlayerRef.current) {
        audioPlayerRef.current.pause();
        audioPlayerRef.current = null;
      }
    };
  }, [currentDialogue?._id]);

  // Update local audio blob when recording changes
  useEffect(() => {
    setLocalAudioBlob(audioBlob);
  }, [audioBlob]);

  // Navigation handlers
  const hasChanges = useCallback(() => {
    return localAudioBlob !== null;
  }, [localAudioBlob]);

  const handleNext = useCallback(() => {
    if (hasChanges()) {
      setConfirmationType('navigation');
      setNavigationDirection('next');
      setPendingNavigationIndex(currentDialogueIndex + 1);
      setShowConfirmation(true);
    } else if (currentDialogueIndex < dialoguesList.length - 1) {
      setCurrentDialogueIndex(prev => prev + 1);
    }
  }, [currentDialogueIndex, dialoguesList.length, hasChanges, setConfirmationType, setNavigationDirection, setPendingNavigationIndex, setShowConfirmation]);

  const handlePrevious = useCallback(() => {
    if (currentDialogueIndex > 0) {
      if (hasChanges()) {
        setConfirmationType('navigation');
        setNavigationDirection('previous');
        setPendingNavigationIndex(currentDialogueIndex - 1);
        setShowConfirmation(true);
      } else {
        setCurrentDialogueIndex(prev => prev - 1);
      }
    }
  }, [currentDialogueIndex, hasChanges]);

  const handleDeleteRecording = async () => {
    if (!currentDialogue) return;

    try {
      setIsSaving(true);
      logEvent('Deleting voice-over recording', { dialogueId: currentDialogue._id });

      const updateData = {
        dialogue: currentDialogue.dialogue,
        character: currentDialogue.character,
        timeStart: currentDialogue.timeStart,
        timeEnd: currentDialogue.timeEnd,
        index: currentDialogue.index,
        deleteVoiceOver: true
      };

      const response = await axios.put(`/api/dialogues/${currentDialogue._id}`, updateData);

      if (!response.data || !response.data._id) {
        throw new Error('Failed to delete recording: Invalid response');
      }

      // Update local state
      const updatedDialogues = dialoguesList.map(dialogue => 
        dialogue._id === currentDialogue._id 
          ? { ...dialogue, voiceOverUrl: undefined, status: 'pending' }
          : dialogue
      );
      setDialoguesList(updatedDialogues);

      // Clear local audio blob
      setLocalAudioBlob(null);

      // Show success message
      setShowSaveSuccess(true);
      setTimeout(() => setShowSaveSuccess(false), 3000);

      // Invalidate queries to refetch data
      await queryClient.invalidateQueries({ queryKey: ['dialogues', projectId] });

      logEvent('Voice-over recording deleted successfully', { dialogueId: currentDialogue._id });
    } catch (error) {
      console.error('Error deleting recording:', error);
      setError('Failed to delete recording');
      setTimeout(() => setError(''), 3000);
    } finally {
      setIsSaving(false);
    }
  };

  const handleDiscardChanges = async () => {
    try {
      if (confirmationType === 'navigation') {
        if (pendingNavigationIndex !== null) {
          setCurrentDialogueIndex(pendingNavigationIndex);
          setPendingNavigationIndex(null);
        }
      } else {
        await handleDeleteRecording();
      }

      // Close confirmation modal
      setShowConfirmation(false);
      setNavigationDirection(undefined);
    } catch (error) {
      console.error('Error discarding changes:', error);
      setError('Failed to delete recording');
      setTimeout(() => setError(''), 3000);
    }
  };

  // Video control functions
  const togglePlayPause = useCallback(() => {
    if (videoRef.current) {
      if (isPlaying) {
        videoRef.current.pause();
      } else {
        videoRef.current.play();
      }
      setIsPlaying(!isPlaying);
    }
  }, [isPlaying]);

  // Add video event listeners
  useEffect(() => {
    const video = videoRef.current;
    if (video) {
      const handlePlay = () => setIsPlaying(true);
      const handlePause = () => setIsPlaying(false);
      const handleLoadStart = () => setIsVideoLoading(true);
      const handleLoadEnd = () => setIsVideoLoading(false);

      video.addEventListener('play', handlePlay);
      video.addEventListener('pause', handlePause);
      video.addEventListener('loadstart', handleLoadStart);
      video.addEventListener('canplay', handleLoadEnd);
      video.addEventListener('error', handleLoadEnd);
      
      return () => {
        video.removeEventListener('play', handlePlay);
        video.removeEventListener('pause', handlePause);
        video.removeEventListener('loadstart', handleLoadStart);
        video.removeEventListener('canplay', handleLoadEnd);
        video.removeEventListener('error', handleLoadEnd);
      };
    }
  }, [currentDialogue?.videoUrl]);

  // Save changes with approval
  const handleApproveAndSave = async () => {
    if (!currentDialogue) return;
    
    try {
      setIsSaving(true);
      logEvent('Starting save process', {
        dialogueId: currentDialogue._id,
        hasNewRecording: !!localAudioBlob,
        hasExistingRecording: !!currentDialogue.voiceOverUrl
      });
      
      let voiceOverUrl = currentDialogue.voiceOverUrl;
      
      // Upload audio if new recording exists
      if (localAudioBlob) {
        logEvent('Preparing to upload audio', {
          dialogueId: currentDialogue._id,
          blobSize: localAudioBlob.size
        });

        const formData = new FormData();
        formData.append('audio', localAudioBlob);
        formData.append('dialogueId', currentDialogue._id);
        formData.append('dialogueIndex', currentDialogue.index.toString());
        formData.append('projectId', projectId);
        
        logEvent('Uploading audio file');
        try {
          const uploadResponse = await axios.post('/api/upload-voice-over', formData, {
            headers: {
              'Content-Type': 'multipart/form-data',
            },
            validateStatus: function (status) {
              return status < 500; // Resolve only if the status code is less than 500
            }
          });
          
          if (!uploadResponse.data.url) {
            logEvent('Upload failed', {
              status: uploadResponse.status,
              error: uploadResponse.data.error || 'No URL returned'
            });
            throw new Error(uploadResponse.data.error || 'Failed to upload voice-over recording');
          }
          
          const { url } = uploadResponse.data;
          voiceOverUrl = url;
          logEvent('Audio upload successful', { url });
        } catch (error: unknown) {
          const uploadError = error as { message: string; response?: { status: number } };
          logEvent('Upload failed', {
            error: uploadError.message,
            status: uploadError.response?.status
          });
          throw new Error('Failed to upload voice-over recording: ' + uploadError.message);
        }
      }
      
      // Only check for voiceOverUrl if we're not uploading a new recording
      if (!localAudioBlob && !voiceOverUrl && !currentDialogue.voiceOverUrl) {
        logEvent('No voice-over URL available', { dialogueId: currentDialogue._id });
        throw new Error('No voice-over recording available to save');
      }
      
      const updateData = {
        dialogue: currentDialogue.dialogue,
        character: currentDialogue.character,
        status: 'voice-over-added',
        timeStart: currentDialogue.timeStart,
        timeEnd: currentDialogue.timeEnd,
        index: currentDialogue.index,
        voiceOverUrl: voiceOverUrl || currentDialogue.voiceOverUrl,
      };
      
      logEvent('Updating dialogue metadata', { 
        dialogueId: currentDialogue._id,
        voiceOverUrl: updateData.voiceOverUrl
      });
      
      const response = await axios.put(`/api/dialogues/${currentDialogue._id}`, updateData);
      
      if (!response.data || !response.data._id) {
        logEvent('Metadata update failed', {
          status: response.status,
          error: response.data?.error || 'No response data'
        });
        throw new Error(response.data?.error || 'Failed to save voice-over: Invalid response');
      }

      // Get fresh copy of dialogues list to avoid race conditions
      const currentDialogues = [...dialoguesList];
      const updatedDialogues = currentDialogues.map(dialogue => 
        dialogue._id === currentDialogue._id ? { ...dialogue, ...response.data } : dialogue
      );
      setDialoguesList(updatedDialogues);

      // Clear local audio blob
      setLocalAudioBlob(null);

      // Show success message
      setShowSaveSuccess(true);
      setTimeout(() => setShowSaveSuccess(false), 3000);

      // Close confirmation modal if open
      setShowConfirmation(false);

      // Invalidate queries to refetch data
      await queryClient.invalidateQueries({ queryKey: ['dialogues', projectId] });

      logEvent('Save process completed successfully', {
        dialogueId: currentDialogue._id
      });

      // Handle navigation after save
      if (pendingNavigationIndex !== null) {
        logEvent('Navigating to next dialogue', {
          from: currentDialogueIndex,
          to: pendingNavigationIndex
        });
        setCurrentDialogueIndex(pendingNavigationIndex);
        setPendingNavigationIndex(null);
      } else if (currentDialogueIndex < dialoguesList.length - 1) {
        logEvent('Auto-advancing to next dialogue', {
          from: currentDialogueIndex,
          to: currentDialogueIndex + 1
        });
        setCurrentDialogueIndex(prev => prev + 1);
      }
    } catch (err) {
      console.error('Error saving voice-over:', err);
      const error = err as AppError;
      logEvent('Save process failed', {
        error: error.message,
        dialogueId: currentDialogue._id,
        hasLocalBlob: !!localAudioBlob,
        hasExistingUrl: !!currentDialogue.voiceOverUrl
      });
      setError(error.message || 'Failed to save voice-over');
      setTimeout(() => setError(''), 3000);
    } finally {
      setIsSaving(false);
      setNavigationDirection(undefined);
    }
  };

  const handleDragEnd = async (event: MouseEvent | TouchEvent | PointerEvent, info: PanInfo): Promise<void> => {
    const threshold = 100;
    const velocity = info.velocity.x;
    const offset = info.offset.x;

    if (Math.abs(velocity) >= 500 || Math.abs(offset) >= threshold) {
      if (velocity > 0 || offset > threshold) {
        // Swipe right - go to previous
        if (currentDialogueIndex > 0) {
          if (hasChanges()) {
            setConfirmationType('navigation');
            setNavigationDirection('previous');
            setPendingNavigationIndex(currentDialogueIndex - 1);
            setShowConfirmation(true);
          } else {
            setCurrentDialogueIndex(prev => prev - 1);
          }
        }
      } else {
        // Swipe left - go to next
        if (currentDialogueIndex < dialoguesList.length - 1) {
          if (localAudioBlob) {
            setConfirmationType('navigation');
            setNavigationDirection('next');
            setPendingNavigationIndex(currentDialogueIndex + 1);
            setShowConfirmation(true);
          } else {
            setCurrentDialogueIndex(prev => prev + 1);
          }
        }
      }
    }
    
    await dragControls.start({ x: 0 });
  };

  // Add recording state logging
  useEffect(() => {
    if (isRecording) {
      logEvent('Recording started', {
        dialogueId: currentDialogue?._id,
        maxDuration,
        dialogueIndex: currentDialogueIndex + 1,
        totalDialogues: dialoguesList.length
      });
    }
  }, [isRecording]);

  // Add audio blob logging
  useEffect(() => {
    if (localAudioBlob) {
      logEvent('New recording created', {
        dialogueId: currentDialogue?._id,
        blobSize: localAudioBlob.size,
        blobType: localAudioBlob.type,
        duration: recordingDuration
      });
    }
  }, [localAudioBlob]);

  // Optimize audio blob state effect
  useEffect(() => {
    const hasLocalBlob = !!localAudioBlob;
    const hasExistingRecording = !!currentDialogue?.voiceOverUrl;
    
    // Only log if there's an actual change in the state
    if (hasLocalBlob || hasExistingRecording) {
      logEvent('Audio blob state changed:', {
        hasLocalBlob,
        localBlobSize: localAudioBlob?.size,
        hasExistingRecording
      });
    }
  }, [localAudioBlob, currentDialogue?.voiceOverUrl]);

  const handleReRecord = useCallback(() => {
    try {
      logEvent('Re-record button clicked', {
        dialogueId: currentDialogue?._id,
        existingUrl: currentDialogue?.voiceOverUrl
      });

      // Show confirmation modal before starting re-record
      setConfirmationType('discard');
      setShowConfirmation(true);
    } catch (error) {
      console.error('Failed to handle re-record:', error);
      setError('Failed to start re-recording');
    }
  }, [currentDialogue, setConfirmationType, setShowConfirmation, setError]);

  useEffect(() => {
    if (currentDialogue?._id && recordingDuration && maxDuration) {
      const key = `recording_duration_${currentDialogue._id}`;
      localStorage.setItem(key, recordingDuration.toString());
    }
  }, [currentDialogue?._id, recordingDuration, maxDuration]);

  useEffect(() => {
    if (currentDialogue?._id && currentDialogueIndex < dialoguesList.length) {
      // Your existing effect logic
      const handleKeyPress = (event: KeyboardEvent) => {
        if (event.key === 'ArrowRight') {
          handleNext();
        } else if (event.key === 'ArrowLeft') {
          handlePrevious();
        }
      };
      window.addEventListener('keydown', handleKeyPress);
      return () => window.removeEventListener('keydown', handleKeyPress);
    }
  }, [currentDialogue?._id, currentDialogueIndex, dialoguesList.length, maxDuration, handleNext, handlePrevious]);

  // Add cleanup effect for dialogue changes
  useEffect(() => {
    // Clean up audio when switching dialogues
    if (audioPlayerRef.current) {
      audioPlayerRef.current.pause();
      audioPlayerRef.current = null;
    }
    
    // Reset states
    setIsPlaying(false);
    setLocalAudioBlob(null);
    
    return () => {
      // Cleanup on unmount
      if (audioPlayerRef.current) {
        audioPlayerRef.current.pause();
        audioPlayerRef.current = null;
      }
    };
  }, [currentDialogue?._id]);

  // Add function to handle synced playback
  const handleSyncedPlayback = useCallback(() => {
    if (isSyncedPlaying) {
      // Stop both video and audio
      if (videoRef.current) {
        videoRef.current.pause();
      }
      if (audioRef.current) {
        audioRef.current.pause();
        audioRef.current = null;
      }
      setIsSyncedPlaying(false);
      setIsPlaying(false);
      return;
    }

    const playSync = async () => {
      try {
        if (!videoRef.current) return;

        // Create audio element
        const audio = new Audio();
        if (localAudioBlob) {
          audio.src = URL.createObjectURL(localAudioBlob);
        } else if (currentDialogue?.voiceOverUrl) {
          audio.src = currentDialogue.voiceOverUrl;
        } else {
          return;
        }

        audioRef.current = audio;

        // Set up cleanup on audio end
        audio.addEventListener('ended', () => {
          setIsSyncedPlaying(false);
          setIsPlaying(false);
          if (videoRef.current) {
            videoRef.current.pause();
            videoRef.current.muted = false; // Restore video audio
          }
          URL.revokeObjectURL(audio.src);
          audioRef.current = null;
        });

        // Mute video audio
        videoRef.current.muted = true;

        // Start playback
        videoRef.current.currentTime = 0;
        await Promise.all([
          videoRef.current.play(),
          audio.play()
        ]);

        setIsSyncedPlaying(true);
        setIsPlaying(true);
      } catch (error) {
        console.error('Failed to start synced playback:', error);
        setIsSyncedPlaying(false);
        setIsPlaying(false);
        if (audioRef.current) {
          audioRef.current.pause();
          audioRef.current = null;
        }
        if (videoRef.current) {
          videoRef.current.pause();
          videoRef.current.muted = false; // Restore video audio on error
        }
      }
    };

    playSync();
  }, [localAudioBlob, currentDialogue?.voiceOverUrl, isSyncedPlaying]);

  // Add cleanup for synced playback
  useEffect(() => {
    return () => {
      if (audioRef.current) {
        audioRef.current.pause();
        audioRef.current = null;
      }
    };
  }, [currentDialogue?._id]);

  // Add function to get audio duration
  const updateAudioDuration = useCallback(async (blob: Blob | string) => {
    try {
      const audio = new Audio();
      if (blob instanceof Blob) {
        audio.src = URL.createObjectURL(blob);
      } else {
        audio.src = blob;
      }

      await new Promise((resolve) => {
        audio.addEventListener('loadedmetadata', () => {
          setAudioDuration(audio.duration);
          resolve(true);
        });
        audio.addEventListener('error', () => {
          console.error('Error loading audio duration');
          setAudioDuration(0);
          resolve(false);
        });
      });

      if (blob instanceof Blob) {
        URL.revokeObjectURL(audio.src);
      }
    } catch (error) {
      console.error('Error getting audio duration:', error);
      setAudioDuration(0);
    }
  }, []);

  // Update audio duration when audio blob or URL changes
  useEffect(() => {
    if (localAudioBlob) {
      updateAudioDuration(localAudioBlob);
    } else if (currentDialogue?.voiceOverUrl) {
      updateAudioDuration(currentDialogue.voiceOverUrl);
    } else {
      setAudioDuration(0);
    }
  }, [localAudioBlob, currentDialogue?.voiceOverUrl, updateAudioDuration]);

  return (
    <div className="w-full h-screen flex flex-col bg-gray-900">
      <CharacterInfo 
        character={currentDialogue.character} 
        voiceOverUrl={currentDialogue.voiceOverUrl}
      />
      
      <VideoPlayer 
        videoRef={videoRef}
        videoUrl={currentDialogue.videoUrl}
        isVideoLoading={isVideoLoading}
      />
      
      <VideoControls 
        isPlaying={isPlaying}
        togglePlayPause={togglePlayPause}
        handleSyncedPlayback={handleSyncedPlayback}
        isSyncedPlaying={isSyncedPlaying}
        hasRecording={!!localAudioBlob || !!currentDialogue?.voiceOverUrl}
        audioDuration={audioDuration}
        videoDuration={maxDuration}
      />

      <motion.div 
        className="flex-grow overflow-y-auto p-4"
        drag="x"
        dragConstraints={{ left: 0, right: 0 }}
        dragElastic={0.2}
        onDragEnd={handleDragEnd}
        animate={dragControls}
        style={{ x: dragX }}
      >
        <EmotionsDisplay emotions={currentDialogue.emotions} />
        
        <div className="mt-4">
          <span className="text-gray-400">Adapted Text:</span>
          <p className="text-white">{currentDialogue.dialogue.adapted}</p>
        </div>

        {isRecording && audioStream && (
          <div className="mt-4 space-y-4">
            <AudioVisualizer
              audioStream={audioStream}
              maxDuration={maxDuration}
            />
            <RecordingTimer
              isRecording={isRecording}
              maxDuration={maxDuration}
            />
          </div>
        )}

        <div className="flex flex-col items-center justify-center text-sm text-gray-400 space-y-2 mt-4">
          <span>Recording duration limit: {formatTime(maxDuration)}</span>
          {isRecording && (
            <span>Recording time: {formatTime(recordingDuration)}</span>
          )}
        </div>
      </motion.div>

      <RecordingControls 
        isRecording={isRecording}
        isPlayingRecording={isPlayingRecording}
        startRecording={startRecording}
        stopRecording={stopRecording}
        handlePlayRecording={handlePlayAudio}
        hasRecording={!!localAudioBlob || !!currentDialogue?.voiceOverUrl}
        hasExistingRecording={!!currentDialogue?.voiceOverUrl}
        currentIndex={currentDialogueIndex}
        totalCount={dialoguesList.length}
        onReRecord={handleReRecord}
        onDelete={handleDeleteRecording}
        localAudioBlob={localAudioBlob}
        isProcessing={isProcessing}
        countdown={countdown}
        isWaitingForVoice={isWaitingForVoice}
      />

      <ConfirmationModal 
        isOpen={showConfirmation}
        onClose={() => {
          setShowConfirmation(false);
          setPendingNavigationIndex(null);
          setNavigationDirection(undefined);
        }}
        onDiscard={handleDiscardChanges}
        onApprove={handleApproveAndSave}
        isSaving={isSaving}
        type={confirmationType}
        direction={navigationDirection}
      />

      <Notifications 
        isSaving={isSaving}
        showSaveSuccess={showSaveSuccess}
        error={error}
      />
    </div>
  );
} 
```

## File: components\VoiceOverView.tsx
```tsx
'use client'

import { useSession, signOut } from 'next-auth/react'
import { useRouter } from 'next/navigation'
import { useState } from 'react'

interface Project {
  _id: string
  title: string
  description: string
  sourceLanguage: string
  targetLanguage: string
  status: string
  assignedTo: Array<{
    username: string
    role: string
  }>
}

export default function VoiceOverView({ projects }: { projects: Project[] }) {
  const { data: session } = useSession()
  const router = useRouter()
  const [isLoggingOut, setIsLoggingOut] = useState(false)

  // Filter projects assigned to current user as voice-over
  const assignedProjects = projects.filter(project => 
    project.assignedTo.some(assignment => 
      assignment.username === session?.user?.username && 
      assignment.role === 'voice-over'
    )
  )

  const handleLogout = async () => {
    try {
      setIsLoggingOut(true)
      // Clear any client-side session data
      if (typeof window !== 'undefined') {
        window.localStorage.clear()
      }
      // Use direct redirect
      await signOut({ 
        redirect: true,
        callbackUrl: '/login'
      })
    } catch (error) {
      console.error('Error during signOut:', error)
      // Fallback redirect if signOut fails
      router.replace('/login')
    } finally {
      setIsLoggingOut(false)
    }
  }

  return (
    <div className="min-h-screen bg-background">
      <div className="max-w-7xl mx-auto px-4 py-6">
        <div className="flex justify-between items-center mb-6 w-full">
          <h1 className="text-2xl font-bold text-foreground">Your Projects</h1>
          <button 
            onClick={handleLogout}
            disabled={isLoggingOut}
            className={`z-50 px-4 py-2 rounded transition-colors ${
              isLoggingOut 
                ? 'bg-gray-400 cursor-not-allowed' 
                : 'bg-red-500 hover:bg-red-600'
            } text-white`}
          >
            {isLoggingOut ? 'Logging out...' : 'Logout'}
          </button>
        </div>

        {assignedProjects.length === 0 ? (
          <div className="text-center p-4">No projects assigned to you as a voice-over artist.</div>
        ) : (
          <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
            {assignedProjects.map((project) => (
              <div
                key={project._id}
                onClick={() => router.push(`/allDashboards/voice-over/${project._id}`)}
                className="bg-card rounded-lg shadow-lg p-6 cursor-pointer hover:shadow-xl transition-shadow"
              >
                <h2 className="text-xl font-semibold mb-2">{project.title}</h2>
                <p className="text-muted-foreground mb-4">{project.description}</p>
                <div className="text-sm text-muted-foreground">
                  <p>Source Language: {project.sourceLanguage}</p>
                  <p>Status: {project.status}</p>
                </div>
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  )
}


```

## File: components.json
```json
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "app/globals.css",
    "baseColor": "slate",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}
```

## File: hooks\useAudioRecording.ts
```ts
//useAudioRecording.ts

import { useState, useRef, useEffect, useCallback, useMemo } from 'react';
import { type Dialogue } from '../types/dialogue';
import { createWorker, createWavBlob, type AudioData } from '../utils/audio';

// Move constants outside component to prevent recreation
const AUDIO_CONFIG = {
  sampleRate: 48000,
  channelCount: 2,
  latencyHint: 'interactive' as const,
  echoCancellation: true,
  noiseSuppression: true,
  autoGainControl: false
} as const;

const logEvent = (message: string, data?: any) => {
  if (process.env.NODE_ENV === 'development') {
    const timestamp = new Date().toISOString();
    // console.log(`[${timestamp}] ${message}`, data ? data : '');
  }
};

export const useAudioRecording = (currentDialogue: Dialogue) => {
  // Add new state for processing and countdown
  const [processingState, setProcessingState] = useState({
    isProcessing: false,
    countdown: 0,
    isWaitingForVoice: false
  });

  // Group related states to reduce re-renders
  const [recordingState, setRecordingState] = useState({
    isRecording: false,
    duration: 0,
    isPlaying: false
  });

  const [audioState, setAudioState] = useState({
    blob: null as Blob | null,
    blobUrl: null as string | null,
    chunks: [] as AudioData[]
  });

  // Use refs for values that don't need to trigger re-renders
  const refs = useRef({
    recordingTimer: null as NodeJS.Timeout | null,
    audioContext: null as AudioContext | null,
    workletNode: null as AudioWorkletNode | null,
    sourceNode: null as MediaStreamAudioSourceNode | null,
    audioPlayer: null as HTMLAudioElement | null,
    maxDuration: 0,
    stream: null as MediaStream | null,
    cleanupInProgress: false,
    stoppingInProgress: false,
    countdownInterval: null as NodeJS.Timeout | null,
    maxDurationTimeout: null as NodeJS.Timeout | null
  });

  // Memoize parseTime function
  const parseTime = useMemo(() => {
    return (time: string): number => {
      const [hours, minutes, seconds, milliseconds] = time.split(':').map(Number);
      return (hours * 3600) + (minutes * 60) + seconds + (milliseconds / 1000);
    };
  }, []);

  // Memoize maxDuration calculation
  useEffect(() => {
    if (currentDialogue?.timeStart && currentDialogue?.timeEnd) {
      const startSeconds = parseTime(currentDialogue.timeStart);
      const endSeconds = parseTime(currentDialogue.timeEnd);
      refs.current.maxDuration = Number((endSeconds - startSeconds).toFixed(3));
    }
  }, [currentDialogue?.timeStart, currentDialogue?.timeEnd, parseTime]);

  const cleanup = useCallback(() => {
    if (refs.current.cleanupInProgress) return;
    refs.current.cleanupInProgress = true;
    
    try {
      logEvent('Cleaning up recording resources');
      
      // Clear timer
      if (refs.current.recordingTimer) {
        clearInterval(refs.current.recordingTimer);
        refs.current.recordingTimer = null;
      }

      // Stop audio playback
      if (refs.current.audioPlayer) {
        refs.current.audioPlayer.pause();
        refs.current.audioPlayer = null;
      }

      // Clean up blob URL
      if (audioState.blobUrl) {
        URL.revokeObjectURL(audioState.blobUrl);
        setAudioState(prev => ({ ...prev, blobUrl: null }));
      }

      // Stop and disconnect worklet
      if (refs.current.workletNode) {
        try {
          refs.current.workletNode.port.postMessage('stop');
          refs.current.workletNode.disconnect();
          refs.current.workletNode = null;
        } catch (error) {
          console.error('Error stopping worklet:', error);
        }
      }

      // Disconnect source
      if (refs.current.sourceNode) {
        try {
          refs.current.sourceNode.disconnect();
          refs.current.sourceNode = null;
        } catch (error) {
          console.error('Error disconnecting source:', error);
        }
      }

      // Stop media stream
      if (refs.current.stream) {
        try {
          refs.current.stream.getTracks().forEach(track => track.stop());
          refs.current.stream = null;
        } catch (error) {
          console.error('Error stopping media tracks:', error);
        }
      }

      // Close audio context
      if (refs.current.audioContext) {
        try {
          refs.current.audioContext.close();
          refs.current.audioContext = null;
        } catch (error) {
          console.error('Error closing audio context:', error);
        }
      }

      setRecordingState(prev => ({ ...prev, isRecording: false }));
      refs.current.stoppingInProgress = false;
    } catch (error) {
      console.error('Error during cleanup:', error);
    } finally {
      refs.current.cleanupInProgress = false;
    }
  }, [audioState.blobUrl]);

  const stopRecording = useCallback(() => {
    if (refs.current.stoppingInProgress) return;
    refs.current.stoppingInProgress = true;
    
    logEvent('Stopping recording', { chunksCount: audioState.chunks.length });
    
    if (refs.current.recordingTimer) {
      clearInterval(refs.current.recordingTimer);
      refs.current.recordingTimer = null;
    }

    if (refs.current.workletNode) {
      refs.current.workletNode.port.postMessage('stop');
    } else {
      cleanup();
    }
  }, [audioState.chunks.length, cleanup]);

  // Add countdown functionality
  const startCountdown = useCallback(() => {
    setProcessingState(prev => ({ ...prev, countdown: 3 }));
    
    refs.current.countdownInterval = setInterval(() => {
      setProcessingState(prev => {
        if (prev.countdown <= 1) {
          if (refs.current.countdownInterval) {
            clearInterval(refs.current.countdownInterval);
          }
          return { ...prev, countdown: 0 };
        }
        return { ...prev, countdown: prev.countdown - 1 };
      });
    }, 1000);
  }, []);

  const startRecording = useCallback(async () => {
    if (processingState.isProcessing) return;
    
    try {
      setProcessingState(prev => ({ ...prev, isProcessing: true }));
      cleanup();
      setAudioState(prev => ({ ...prev, chunks: [], blob: null }));

      // Start countdown
      startCountdown();
      await new Promise(resolve => setTimeout(resolve, 3000));

      setProcessingState(prev => ({ ...prev, isWaitingForVoice: true }));

      if (!window.AudioContext) {
        throw new Error('AudioContext not supported');
      }

      const stream = await navigator.mediaDevices.getUserMedia({ 
        audio: {
          echoCancellation: AUDIO_CONFIG.echoCancellation,
          noiseSuppression: AUDIO_CONFIG.noiseSuppression,
          sampleRate: AUDIO_CONFIG.sampleRate,
          channelCount: AUDIO_CONFIG.channelCount,
          autoGainControl: AUDIO_CONFIG.autoGainControl
        } 
      });
      
      refs.current.stream = stream;
      refs.current.audioContext = new AudioContext({
        sampleRate: AUDIO_CONFIG.sampleRate,
        latencyHint: AUDIO_CONFIG.latencyHint
      });

      // Create analyzer for voice detection
      const analyser = refs.current.audioContext.createAnalyser();
      analyser.fftSize = 256;
      const bufferLength = analyser.frequencyBinCount;
      const dataArray = new Uint8Array(bufferLength);
      
      const sourceNode = refs.current.audioContext.createMediaStreamSource(stream);
      sourceNode.connect(analyser);
      refs.current.sourceNode = sourceNode;

      // Wait for voice input
      await new Promise((resolve) => {
        const checkAudio = () => {
          analyser.getByteFrequencyData(dataArray);
          const average = dataArray.reduce((acc, value) => acc + value, 0) / bufferLength;
          
          if (average > 20) { // Threshold for voice detection
            setProcessingState(prev => ({ ...prev, isWaitingForVoice: false }));
            resolve(true);
          } else {
            requestAnimationFrame(checkAudio);
          }
        };
        checkAudio();
      });

      const workletNode = await createWorker(refs.current.audioContext);
      refs.current.workletNode = workletNode;

      // Set up recording chunks
      const recordingChunks = [] as AudioData[];

      workletNode.addEventListener('audiochunk', ((event: CustomEvent<AudioData>) => {
        const chunk = event.detail;
        recordingChunks.push(chunk);
        setAudioState(prev => ({ ...prev, chunks: [...prev.chunks, chunk] }));
      }) as EventListener);

      workletNode.addEventListener('stopped', () => {
        if (recordingChunks.length === 0) {
          cleanup();
          return;
        }

        try {
          const combinedAudioData = recordingChunks.reduce((acc: Float32Array[], chunk) => {
            if (!chunk.audioData?.length) return acc;
            
            chunk.audioData.forEach((channel, i) => {
              if (!channel?.length) return;
              
              if (!acc[i]) {
                acc[i] = new Float32Array(channel.length);
                acc[i].set(channel);
              } else {
                const newArray = new Float32Array(acc[i].length + channel.length);
                newArray.set(acc[i], 0);
                newArray.set(channel, acc[i].length);
                acc[i] = newArray;
              }
            });
            return acc;
          }, []);

          if (!combinedAudioData.length || !combinedAudioData[0]?.length) {
            throw new Error('No valid audio data recorded');
          }

          if (!refs.current.audioContext) {
            throw new Error('AudioContext is not available');
          }

          const wavBlob = createWavBlob(combinedAudioData, refs.current.audioContext.sampleRate);
          setAudioState(prev => ({ ...prev, blob: wavBlob, chunks: [] }));
        } catch (error) {
          console.error('Error processing audio:', error);
          throw error;
        } finally {
          recordingChunks.length = 0;
          cleanup();
        }
      });

      // Connect nodes for recording
      sourceNode.disconnect(); // Disconnect from analyzer
      sourceNode.connect(workletNode);
      workletNode.connect(refs.current.audioContext.destination);

      setRecordingState(prev => ({ ...prev, isRecording: true, duration: 0 }));
      
      // Set up max duration timeout
      refs.current.maxDurationTimeout = setTimeout(() => {
        stopRecording();
      }, refs.current.maxDuration * 1000);

      // Set up duration timer
      refs.current.recordingTimer = setInterval(() => {
        setRecordingState(prev => {
          const newDuration = Number((prev.duration + 0.01).toFixed(3));
          if (newDuration >= refs.current.maxDuration) {
            stopRecording();
            return { ...prev, duration: refs.current.maxDuration };
          }
          return { ...prev, duration: newDuration };
        });
      }, 10);

    } catch (error) {
      console.error('Recording failed:', error);
      cleanup();
      throw error;
    } finally {
      setProcessingState(prev => ({ 
        ...prev, 
        isProcessing: false,
        isWaitingForVoice: false 
      }));
    }
  }, [cleanup, stopRecording, startCountdown]);

  const handlePlayRecording = useCallback(() => {
    if (!audioState.blob) return;

    // If already playing, stop playback
    if (recordingState.isPlaying) {
      if (refs.current.audioPlayer) {
        refs.current.audioPlayer.pause();
        refs.current.audioPlayer = null;
      }
      setRecordingState(prev => ({ ...prev, isPlaying: false }));
      return;
    }

    let audioUrl: string | null = null;
    try {
      // Create new audio element and URL
      audioUrl = URL.createObjectURL(audioState.blob);
      const audio = new Audio(audioUrl);
      refs.current.audioPlayer = audio;

      // Set up event listeners
      const cleanup = () => {
        setRecordingState(prev => ({ ...prev, isPlaying: false }));
        refs.current.audioPlayer = null;
        if (audioUrl) {
          URL.revokeObjectURL(audioUrl);
          audioUrl = null;
        }
      };

      audio.addEventListener('ended', cleanup);
      audio.addEventListener('error', () => {
        console.error('Audio playback error');
        cleanup();
      });

      // Start playback
      audio.play()
        .then(() => {
          setRecordingState(prev => ({ ...prev, isPlaying: true }));
        })
        .catch(error => {
          console.error('Failed to play audio:', error);
          cleanup();
        });
    } catch (error) {
      console.error('Error setting up audio playback:', error);
      setRecordingState(prev => ({ ...prev, isPlaying: false }));
      if (refs.current.audioPlayer) {
        refs.current.audioPlayer = null;
      }
      if (audioUrl) {
        URL.revokeObjectURL(audioUrl);
      }
    }
  }, [audioState.blob, recordingState.isPlaying]);

  // Reset state when dialogue changes
  useEffect(() => {
    if (!currentDialogue?._id) return;
    cleanup();
    setRecordingState({ isRecording: false, duration: 0, isPlaying: false });
    setAudioState({ blob: null, blobUrl: null, chunks: [] });
  }, [currentDialogue?._id, cleanup]);

  // Add cleanup for countdown interval
  useEffect(() => {
    return () => {
      if (refs.current.countdownInterval) {
        clearInterval(refs.current.countdownInterval);
      }
      if (refs.current.maxDurationTimeout) {
        clearTimeout(refs.current.maxDurationTimeout);
      }
    };
  }, []);

  return {
    isRecording: recordingState.isRecording,
    recordingDuration: recordingState.duration,
    audioBlob: audioState.blob,
    isPlayingRecording: recordingState.isPlaying,
    isProcessing: processingState.isProcessing,
    countdown: processingState.countdown,
    isWaitingForVoice: processingState.isWaitingForVoice,
    startRecording,
    stopRecording,
    handlePlayRecording,
    hasRecording: !!audioState.blob || !!currentDialogue?.voiceOverUrl,
    setPlayingState: (isPlaying: boolean) => setRecordingState(prev => ({ ...prev, isPlaying })),
    audioStream: refs.current.stream
  };
}; 
```

## File: hooks\useDialogues.ts
```ts
import { useQuery } from '@tanstack/react-query'
import { type Dialogue } from '@/types/dialogue'
import { type Project } from '@/types/project'
import axios from 'axios'

// Maintain a record of logged projectIds
const loggedProjectIds = new Set<string>();

async function fetchDialogues(projectId: string): Promise<Dialogue[]> {
  // Only log once per projectId per session
  if (!loggedProjectIds.has(projectId)) {
    console.log('=== Dialogue Fetch Debug ===');
    console.log('Project ID:', projectId);
    console.log('Fetching URL:', `/api/dialogues?projectId=${projectId}`);
    loggedProjectIds.add(projectId);
  }

  try {
    const { data } = await axios.get(`/api/dialogues?projectId=${projectId}`);
    
    // Only log response data once per projectId
    if (loggedProjectIds.size === 1) {
      console.log('Response data:', data);
      console.log('=== End Debug ===');
    }
    
    return data.data || [];
  } catch (error) {
    console.error('Fetch error:', error);
    throw error;
  }
}

export function useDialogues(projectId: string) {
  return useQuery({
    queryKey: ['dialogues', projectId],
    queryFn: () => fetchDialogues(projectId),
    enabled: !!projectId,
    staleTime: 5 * 60 * 1000, // Consider data fresh for 5 minutes
    gcTime: 30 * 60 * 1000, // Keep unused data for 30 minutes
  });
} 
```

## File: hooks\useProject.ts
```ts
import { useQuery } from '@tanstack/react-query'
import { type Project } from '@/types/project'
import axios from 'axios'

async function fetchProject(projectId: string): Promise<Project> {
  console.log('=== Project Fetch Debug ===');
  console.log('Fetching project ID:', projectId);
  
  const url = `/api/projects/${projectId}`;
  console.log('Fetching URL:', url);

  try {
    const { data } = await axios.get(url);
    console.log('Project data:', data);
    console.log('=== End Debug ===');
    return data;
  } catch (error) {
    console.error('Fetch error:', error);
    throw error;
  }
}

export function useProject(projectId: string) {
  console.log('useProject hook called with projectId:', projectId);
  
  return useQuery({
    queryKey: ['project', projectId],
    queryFn: () => fetchProject(projectId),
    enabled: !!projectId,
    staleTime: 5 * 60 * 1000, // Consider data fresh for 5 minutes
    gcTime: 30 * 60 * 1000, // Keep unused data for 30 minutes
  });
} 
```

## File: hooks\useProjects.ts
```ts
import { useQuery } from '@tanstack/react-query'
import axios from 'axios'

interface Project {
  _id: string
  title: string
  description: string
  sourceLanguage: string
  targetLanguage: string
  status: string
  assignedTo: Array<{
    username: string
    role: string
  }>
}

// Track if initial fetch has been logged
let hasLoggedInitialFetch = false;

async function fetchProjects(): Promise<Project[]> {
  if (!hasLoggedInitialFetch) {
    console.log('=== Projects Fetch Debug ===');
    hasLoggedInitialFetch = true;
  }
  
  try {
    const { data } = await axios.get('/api/projects')
    
    if (!hasLoggedInitialFetch) {
      console.log('Projects data:', data);
      console.log('=== End Debug ===');
    }
    
    return data
  } catch (error) {
    console.error('Failed to fetch projects:', error)
    throw error
  }
}

export function useProjects() {
  return useQuery({
    queryKey: ['projects'],
    queryFn: fetchProjects,
    staleTime: 5 * 60 * 1000, // Consider data fresh for 5 minutes
    gcTime: 30 * 60 * 1000, // Keep unused data for 30 minutes
  })
} 
```

## File: jest.config.ts
```ts
import type { Config } from 'jest'
import nextJest from 'next/jest'

const createJestConfig = nextJest({
    dir: './',
})

const customJestConfig: Config = {
    preset: 'ts-jest',
    testEnvironment: 'jsdom',
    setupFilesAfterEnv: ['<rootDir>/jest.setup.ts'],
    moduleNameMapper: {
        '^@/(.*)$': '<rootDir>/$1',
    },
    testPathIgnorePatterns: [
        '<rootDir>/node_modules/',
        '<rootDir>/.next/',
        '<rootDir>/coverage/',
        '<rootDir>/dist/',
    ],
    coveragePathIgnorePatterns: [
        '<rootDir>/node_modules/',
        '<rootDir>/.next/',
        '<rootDir>/coverage/',
        '<rootDir>/dist/',
    ],
    transform: {
        '^.+\\.(ts|tsx)$': ['ts-jest', { tsconfig: 'tsconfig.test.json' }],
    },
    testMatch: ['**/__tests__/**/*.test.[jt]s?(x)'],
    moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx', 'json', 'node'],
    verbose: true,
    bail: false,
    passWithNoTests: true,
}

export default createJestConfig(customJestConfig) 
```

## File: jest.setup.ts
```ts
import '@testing-library/jest-dom'
import { TextEncoder, TextDecoder } from 'util'
import { jest } from '@jest/globals'

// Mock next/navigation
jest.mock('next/navigation', () => ({
  useRouter() {
    return {
      push: jest.fn(),
      replace: jest.fn(),
      prefetch: jest.fn(),
    }
  },
  useSearchParams() {
    return {
      get: jest.fn(),
    }
  },
}))

// Mock next-auth
jest.mock('next-auth/react', () => ({
  useSession() {
    return {
      data: {
        user: { role: 'transcriber' },
      },
      status: 'authenticated',
    }
  },
  signIn: jest.fn(),
  signOut: jest.fn(),
}))

// Mock react-query
jest.mock('@tanstack/react-query', () => ({
  useQuery: jest.fn(),
  useQueryClient: jest.fn(() => ({
    setQueryData: jest.fn(),
  })),
}))

// Set up DOM environment
Object.defineProperty(global, 'TextEncoder', {
  value: TextEncoder,
})

Object.defineProperty(global, 'TextDecoder', {
  value: TextDecoder,
})

// Mock window.URL
global.URL.createObjectURL = jest.fn(() => 'mock-url')
global.URL.revokeObjectURL = jest.fn()

// Mock MediaRecorder
class MockMediaRecorder {
  start = jest.fn()
  stop = jest.fn()
  pause = jest.fn()
  resume = jest.fn()
  addEventListener = jest.fn()
  removeEventListener = jest.fn()
  state = 'inactive'

  static isTypeSupported(type: string) {
    return true
  }
}

global.MediaRecorder = MockMediaRecorder as any

// Mock HTMLMediaElement
Object.defineProperty(window.HTMLMediaElement.prototype, 'play', {
  configurable: true,
  value: jest.fn(),
})

Object.defineProperty(window.HTMLMediaElement.prototype, 'pause', {
  configurable: true,
  value: jest.fn(),
})
```

## File: lib\auth.ts
```ts
import { NextAuthOptions } from 'next-auth'
import CredentialsProvider from 'next-auth/providers/credentials'
import { connectToDatabase } from './mongodb'
import bcrypt from 'bcryptjs'

export const authOptions: NextAuthOptions = {
  providers: [
    CredentialsProvider({
      name: 'Credentials',
      credentials: {
        username: { label: "Username", type: "text" },
        password: { label: "Password", type: "password" }
      },
      async authorize(credentials) {
        if (!credentials?.username || !credentials?.password) {
          throw new Error('Missing credentials')
        }

        const { db } = await connectToDatabase()
        const user = await db.collection('users').findOne({ username: credentials.username })

        if (!user) {
          throw new Error('User not found')
        }

        const isPasswordValid = await bcrypt.compare(credentials.password, user.password)

        if (!isPasswordValid) {
          throw new Error('Invalid password')
        }

        return {
          id: user._id.toString(),
          username: user.username,
          role: user.role,
          email: user.email
        }
      }
    })
  ],
  callbacks: {
    async jwt({ token, user }) {
      if (user) {
        token.username = user.username
        token.role = user.role
      }
      return token
    },
    async session({ session, token }) {
      if (token) {
        session.user = {
          ...session.user,
          username: token.username as string,
          role: token.role as string
        }
      }
      return session
    }
  },
  pages: {
    signIn: '/login',
    error: '/login'
  },
  session: {
    strategy: 'jwt',
    maxAge: 30 * 24 * 60 * 60 // 30 days
  }
} 
```

## File: lib\mongodb.ts
```ts
import { MongoClient } from 'mongodb'

if (!process.env.MONGODB_URI) {
  throw new Error('Invalid/Missing environment variable: "MONGODB_URI"')
}

if (!process.env.MONGODB_DB) {
  throw new Error('Invalid/Missing environment variable: "MONGODB_DB"')
}

// Ensure the URI has the correct protocol
const uri = process.env.MONGODB_URI.startsWith('mongodb://') || process.env.MONGODB_URI.startsWith('mongodb+srv://')
  ? process.env.MONGODB_URI
  : `mongodb+srv://${process.env.MONGODB_URI}`

const dbName = process.env.MONGODB_DB
const options = {
  maxPoolSize: 10,
  serverSelectionTimeoutMS: 5000,
  socketTimeoutMS: 45000,
}

let client: MongoClient
let clientPromise: Promise<MongoClient>

if (process.env.NODE_ENV === 'development') {
  // In development mode, use a global variable so that the value
  // is preserved across module reloads caused by HMR (Hot Module Replacement).
  const globalWithMongo = global as typeof globalThis & {
    _mongoClientPromise?: Promise<MongoClient>
  }

  if (!globalWithMongo._mongoClientPromise) {
    client = new MongoClient(uri, options)
    globalWithMongo._mongoClientPromise = client.connect()
  }
  clientPromise = globalWithMongo._mongoClientPromise
} else {
  // In production mode, it's best to not use a global variable.
  client = new MongoClient(uri, options)
  clientPromise = client.connect()
}

// Export a module-scoped MongoClient promise. By doing this in a
// separate module, the client can be shared across functions.
export default clientPromise

export async function connectToDatabase() {
  const client = await clientPromise
  const db = client.db(dbName)
  return { db, client }
}


```

## File: lib\seed.ts
```ts
import 'dotenv/config';
import { connectToDatabase } from './mongodb.js'
import bcrypt from 'bcryptjs'

const seed = async () => {
  const { db } = await connectToDatabase()

  // Clear existing users
  await db.collection('users').deleteMany({})

  // Create dummy users
  const users = [
    {
      username: 'transcriber1',
      email: 'transcriber1@email.com',
      password: await bcrypt.hash('trans123', 10),
      role: 'transcriber',
      lastLogin: null,
      lastLogout: null,
      sessionsLog: [],
      assignedProjects: []
    },
    {
      username: 'translator1',
      email: 'translator1@email.com',
      password: await bcrypt.hash('tran123', 10),
      role: 'translator',
      lastLogin: null,
      lastLogout: null,
      sessionsLog: [],
      assignedProjects: []
    },
    {
      username: 'voiceover1',
      email: 'voiceover1@email.com',
      password: await bcrypt.hash('voice123', 10),
      role: 'voice-over',
      lastLogin: null,
      lastLogout: null,
      sessionsLog: [],
      assignedProjects: []
    },
    {
      username: 'director1',
      email: 'director1@email.com',
      password: await bcrypt.hash('dir123', 10),
      role: 'director',
      lastLogin: null,
      lastLogout: null,
      sessionsLog: [],
      assignedProjects: []
    },
    {
      username: 'admin1',
      email: 'admin1@email.com',
      password: await bcrypt.hash('admin123', 10),
      role: 'admin',
      lastLogin: null,
      lastLogout: null,
      sessionsLog: [],
      assignedProjects: []
    }
  ]

  await db.collection('users').insertMany(users)
  console.log('Database seeded!')
}

seed().catch(console.error) 
```

## File: lib\utils.ts
```ts
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

```

## File: middleware.ts
```ts
import { getToken } from 'next-auth/jwt'
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'
import type { UserRole } from '@/types/project'

// Define role-based route mappings with proper typing
const ROLE_ROUTES: Record<UserRole, string[]> = {
  admin: ['/allDashboards/admin', '/api/admin'],
  director: ['/allDashboards/director'],
  voiceOver: ['/allDashboards/voice-over'],  // URL still uses kebab-case
  transcriber: ['/allDashboards/transcriber'],
  translator: ['/allDashboards/translator']
}

// Helper function to convert role to URL format
const roleToUrlPath = (role: UserRole): string => {
  return role === 'voiceOver' ? 'voice-over' : role
}

export async function middleware(request: NextRequest) {
  const token = await getToken({ req: request })
  const { pathname } = request.nextUrl

  // Public paths that don't require authentication
  if (pathname === '/login') {
    if (token) {
      // Redirect to role-specific dashboard if already authenticated
      const userRole = token.role as UserRole
      const roleRoute = ROLE_ROUTES[userRole]?.[0] || '/allDashboards'
      return NextResponse.redirect(new URL(roleRoute, request.url))
    }
    return NextResponse.next()
  }

  // Protected routes
  if (!token) {
    return NextResponse.redirect(new URL('/login', request.url))
  }

  // Handle root dashboard route
  if (pathname === '/allDashboards') {
    const userRole = token.role as UserRole
    const roleRoute = ROLE_ROUTES[userRole]?.[0] || '/allDashboards'
    return NextResponse.redirect(new URL(roleRoute, request.url))
  }

  // Role-based access control for both dashboard and project detail pages
  const userRole = token.role as UserRole
  for (const [role, paths] of Object.entries(ROLE_ROUTES)) {
    const isRoleRoute = paths.some(path => {
      // Check both the dashboard route and any project detail pages under it
      return pathname.startsWith(path) || pathname.match(new RegExp(`${path}/[^/]+`))
    })
    if (isRoleRoute && role !== userRole) {
      // Redirect to user's dashboard if trying to access unauthorized role-based route
      const correctPath = ROLE_ROUTES[userRole]?.[0] || '/allDashboards'
      return NextResponse.redirect(new URL(correctPath, request.url))
    }
  }

  return NextResponse.next()
}

export const config = {
  matcher: [
    '/allDashboards/:path*',
    '/api/admin/:path*',
    '/api/projects/:path*',
    '/api/dialogues/:path*',
    '/login'
  ]
} 
```

## File: next.config.mjs
```mjs
/** @type {import('next').NextConfig} */
const nextConfig = {
  webpack: (config, { isServer }) => {
    // Handle punycode deprecation
    if (!isServer) {
      config.resolve = {
        ...config.resolve,
        fallback: {
          ...config.resolve.fallback,
          punycode: false,
          querystring: false,
        },
        alias: {
          ...config.resolve.alias,
          punycode: false,
        }
      };
    }
    return config;
  },
};

export default nextConfig;

```

## File: package.json
```json
{
  "name": "qa-app",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "next dev",
    "dev:no-warnings": "node --no-warnings ./node_modules/.bin/next dev",
    "build:next": "next build",
    "build": "cross-env NODE_ENV=production npm run build:next && node scripts/build-success.js && npm run start",
    "start": "next start",
    "start:port": "next start -p",
    "lint": "next lint",
    "seed": "tsx scripts/seed.ts",
    "seed:users": "tsx scripts/seed-users.ts",
    "test": "cross-env NODE_ENV=test jest",
    "test:watch": "cross-env NODE_ENV=test jest --watch",
    "build:start": "cross-env NODE_ENV=production npm run build"
  },
  "dependencies": {
    "@aws-sdk/client-s3": "^3.709.0",
    "@tanstack/react-query": "^5.62.7",
    "@types/jsonwebtoken": "^9.0.7",
    "@vercel/blob": "^0.27.0",
    "@vercel/speed-insights": "^1.1.0",
    "axios": "^1.7.9",
    "bcryptjs": "^2.4.3",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "dotenv": "^16.4.7",
    "framer-motion": "^11.13.5",
    "ignore": "^7.0.0",
    "jsonwebtoken": "^9.0.2",
    "lucide-react": "^0.468.0",
    "mongodb": "^6.11.0",
    "next": "^14.2.23",
    "next-auth": "^4.24.11",
    "react": "^18",
    "react-dom": "^18",
    "react-swipeable": "^7.0.2",
    "tailwind-merge": "^2.5.5",
    "tailwindcss-animate": "^1.0.7"
  },
  "devDependencies": {
    "@testing-library/jest-dom": "^6.6.3",
    "@testing-library/react": "^14.3.1",
    "@testing-library/user-event": "^14.5.2",
    "@types/bcryptjs": "^2.4.6",
    "@types/jest": "^29.5.14",
    "@types/node": "^20",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "@typescript-eslint/eslint-plugin": "^8.18.0",
    "@typescript-eslint/parser": "^8.18.0",
    "chalk": "^5.3.0",
    "cross-env": "^7.0.3",
    "eslint": "^8",
    "eslint-config-next": "14.2.16",
    "eslint-plugin-jest": "^28.9.0",
    "eslint-plugin-testing-library": "^7.1.1",
    "jest": "^29.7.0",
    "jest-environment-jsdom": "^29.7.0",
    "mongodb-memory-server": "^9.5.0",
    "postcss": "^8",
    "tailwindcss": "^3.4.1",
    "ts-jest": "^29.2.5",
    "ts-node": "^10.9.2",
    "tsx": "^4.19.2",
    "typescript": "^5"
  }
}

```

## File: postcss.config.mjs
```mjs
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
  },
};

export default config;

```

## File: scripts\build-success.js
```js
import chalk from 'chalk';

// Function to create a visual separator
const separator = () => {
  console.log(chalk.gray('═'.repeat(80)));
};

// Function to display success message
const displayBuildSuccess = () => {
  separator();
  console.log(chalk.green.bold('🎉 Build Completed Successfully! 🎉'));
  console.log(chalk.green('✓ All tests passed'));
  console.log(chalk.green('✓ Next.js build completed'));
  console.log(chalk.green('✓ Application is ready for deployment'));
  separator();
};

// Function to display build summary
const displayBuildSummary = () => {
  console.log(chalk.cyan('\nBuild Summary:'));
  console.log(chalk.white('• Environment: Production'));
  console.log(chalk.white('• Test Coverage: Passed'));
  console.log(chalk.white('• Build Size: Optimized'));
  console.log(chalk.white('• Static Pages: Generated'));
  console.log(chalk.white('• API Routes: Configured\n'));
};

// Main execution
const main = async () => {
  try {
    displayBuildSuccess();
    displayBuildSummary();
  } catch (error) {
    console.error(chalk.red('Error during build process:', error));
    process.exit(1);
  }
};

main(); 
```

## File: scripts\seed-users.ts
```ts
import { MongoClient } from 'mongodb'
import bcrypt from 'bcryptjs'
import * as dotenv from 'dotenv'
import { resolve } from 'path'

// Load environment variables from .env.local if it exists, otherwise from .env
dotenv.config({ path: resolve(process.cwd(), '.env.local') })
dotenv.config({ path: resolve(process.cwd(), '.env') })

const MONGODB_URI = process.env.MONGODB_URI
const MONGODB_DB = process.env.MONGODB_DB

if (!MONGODB_URI) {
  throw new Error('Please define the MONGODB_URI environment variable')
}

if (!MONGODB_DB) {
  throw new Error('Please define the MONGODB_DB environment variable')
}

async function seedUsers() {
  console.log('Starting user seeding...')
  console.log('Using database:', MONGODB_DB)
  
  const client = new MongoClient(MONGODB_URI as string)

  try {
    await client.connect()
    console.log('Connected to MongoDB Atlas')
    
    const db = client.db(MONGODB_DB)

    // Drop existing users collection if it exists
    try {
      await db.collection('users').drop()
      console.log('Dropped existing users collection')
    } catch (error) {
      console.log('No existing users collection to drop')
    }

    // Create users collection
    const users = [
      {
        username: 'transcriber1',
        email: 'transcriber1@email.com',
        password: await bcrypt.hash('trans123', 10),
        role: 'transcriber',
        lastLogin: null,
        lastLogout: null,
        sessionsLog: [],
        assignedProjects: [],
        createdAt: new Date(),
        updatedAt: new Date()
      },
      {
        username: 'translator1',
        email: 'translator1@email.com',
        password: await bcrypt.hash('tran123', 10),
        role: 'translator',
        lastLogin: null,
        lastLogout: null,
        sessionsLog: [],
        assignedProjects: [],
        createdAt: new Date(),
        updatedAt: new Date()
      },
      {
        username: 'voiceover1',
        email: 'voiceover1@email.com',
        password: await bcrypt.hash('voice123', 10),
        role: 'voice-over',
        lastLogin: null,
        lastLogout: null,
        sessionsLog: [],
        assignedProjects: [],
        createdAt: new Date(),
        updatedAt: new Date()
      },
      {
        username: 'director1',
        email: 'director1@email.com',
        password: await bcrypt.hash('dir123', 10),
        role: 'director',
        lastLogin: null,
        lastLogout: null,
        sessionsLog: [],
        assignedProjects: [],
        createdAt: new Date(),
        updatedAt: new Date()
      },
      {
        username: 'admin1',
        email: 'admin1@email.com',
        password: await bcrypt.hash('admin123', 10),
        role: 'admin',
        lastLogin: null,
        lastLogout: null,
        sessionsLog: [],
        assignedProjects: [],
        createdAt: new Date(),
        updatedAt: new Date()
      }
    ]

    console.log('Creating users...')
    const result = await db.collection('users').insertMany(users)
    console.log(`Successfully inserted ${result.insertedCount} users`)

    // Create indexes
    console.log('Creating indexes...')
    await db.collection('users').createIndex({ email: 1 }, { unique: true })
    await db.collection('users').createIndex({ username: 1 }, { unique: true })
    console.log('Created indexes on email and username')

  } catch (error) {
    console.error('Error seeding users:', error)
    throw error
  } finally {
    await client.close()
    console.log('Database connection closed')
  }
}

// Run the seed function
seedUsers()
  .then(() => {
    console.log('Seeding completed successfully')
    process.exit(0)
  })
  .catch((error) => {
    console.error('Seeding failed:', error)
    process.exit(1)
  }) 
```

## File: scripts\seed.ts
```ts
import { MongoClient, ObjectId } from 'mongodb'
import { config } from 'dotenv'
import { fileURLToPath } from 'url'
import { dirname } from 'path'

const __filename = fileURLToPath(import.meta.url)
const __dirname = dirname(__filename)

config()

async function seed() {
  console.log('Starting database seeding...')
  const uri = process.env.MONGODB_URI || 'mongodb://localhost:27017/qa-app'
  const client = new MongoClient(uri)

  try {
    await client.connect()
    console.log('Connected to MongoDB')
    
    const db = client.db()

    // Update dialogues without valid projectId
    console.log('Updating dialogues without valid projectId...')
    const result = await db.collection('dialogues').updateMany(
      { 
        $or: [
          { projectId: null },
          { projectId: "null" },
          { projectId: { $exists: false } }
        ]
      },
      {
        $set: {
          projectId: new ObjectId("123456789123456789123456")
        }
      }
    )

    console.log(`Updated ${result.modifiedCount} dialogues with default projectId`)

  } catch (error) {
    console.error('Error during seeding:', error)
  } finally {
    await client.close()
    console.log('Database connection closed')
  }
}

seed().catch(console.error) 
```

## File: scripts\start-app.js
```js
import { exec } from 'child_process';
import chalk from 'chalk';
import { promisify } from 'util';
import net from 'net';

const execAsync = promisify(exec);

// Function to check if port is in use
const isPortInUse = async (port) => {
  return new Promise((resolve) => {
    const server = net.createServer()
      .once('error', () => resolve(true))
      .once('listening', () => {
        server.close();
        resolve(false);
      })
      .listen(port);
  });
};

// Function to find next available port
const findAvailablePort = async (startPort) => {
  let port = startPort;
  while (await isPortInUse(port)) {
    port++;
    if (port > startPort + 100) return null; // Limit search to 100 ports
  }
  return port;
};

// Function to get process info using port
const getProcessInfo = async (port) => {
  try {
    if (process.platform === 'win32') {
      const { stdout } = await execAsync(`netstat -ano | findstr :${port}`);
      const lines = stdout.split('\n').filter(line => line.includes(`:${port}`));
      if (lines.length > 0) {
        const processId = lines[0].split(' ').filter(Boolean).pop();
        if (processId) {
          const { stdout: processInfo } = await execAsync(`tasklist /FI "PID eq ${processId}"`);
          return { pid: processId, info: processInfo };
        }
      }
    }
    return null;
  } catch (error) {
    return null;
  }
};

// Function to kill process on port
const killProcess = async (port) => {
  try {
    if (process.platform === 'win32') {
      const processInfo = await getProcessInfo(port);
      if (processInfo) {
        console.log(chalk.yellow(`\nProcess using port ${port}:`));
        console.log(chalk.gray(processInfo.info));
        await execAsync(`taskkill /F /PID ${processInfo.pid}`);
        return true;
      }
    } else {
      await execAsync(`lsof -i :${port} -t | xargs kill -9`);
      return true;
    }
  } catch (error) {
    return false;
  }
  return false;
};

// Function to start the application
const startApp = async (port) => {
  const command = `npm run start:port ${port}`;
  console.log(chalk.cyan(`\nStarting application on port ${port}...`));
  
  const child = exec(command);
  
  child.stdout.on('data', (data) => {
    console.log(data);
  });

  child.stderr.on('data', (data) => {
    console.error(chalk.red(data));
  });

  child.on('close', (code) => {
    if (code !== 0) {
      console.log(chalk.red(`Process exited with code ${code}`));
    }
    process.exit(code);
  });
};

// Main execution
const main = async () => {
  const defaultPort = 3000;
  
  try {
    // Check if default port is in use
    if (await isPortInUse(defaultPort)) {
      console.log(chalk.yellow(`\nPort ${defaultPort} is in use.`));
      
      // Try to find next available port
      const nextPort = await findAvailablePort(defaultPort + 1);
      
      if (nextPort) {
        console.log(chalk.green(`Found available port: ${nextPort}`));
        await startApp(nextPort);
      } else {
        console.error(chalk.red('No available ports found. Please free up some ports and try again.'));
        process.exit(1);
      }
    } else {
      await startApp(defaultPort);
    }
  } catch (error) {
    console.error(chalk.red('Error starting application:', error));
    process.exit(1);
  }
};

// Start the application
main(); 
```

## File: src\types\dialogue.ts
```ts
export interface Dialogue {
  _id: string
  index: number
  timeStart: string
  timeEnd: string
  character: string
  videoUrl: string
  dialogue: {
    original: string
    translated: string
    adapted: string
  }
  emotions: {
    primary: {
      emotion: string
      intensity: number
    }
    secondary: {
      emotion: string
      intensity: number
    }
  }
  direction: string
  lipMovements: number
  sceneContext: string
  technicalNotes: string
  culturalNotes: string
  status: string
  recordingStatus: string
  projectId: string
  updatedAt: string
  updatedBy: string
  voiceOverUrl: string | null
}

export interface DialogueViewProps {
  dialogues: Dialogue[]
  projectId: string
} 
```

## File: tailwind.config.ts
```ts
import type { Config } from "tailwindcss";

const config: Config = {
    darkMode: ["class"],
    content: [
    "./pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./components/**/*.{js,ts,jsx,tsx,mdx}",
    "./app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
  	extend: {
  		colors: {
  			background: 'hsl(var(--background))',
  			foreground: 'hsl(var(--foreground))',
  			card: {
  				DEFAULT: 'hsl(var(--card))',
  				foreground: 'hsl(var(--card-foreground))'
  			},
  			popover: {
  				DEFAULT: 'hsl(var(--popover))',
  				foreground: 'hsl(var(--popover-foreground))'
  			},
  			primary: {
  				DEFAULT: 'hsl(var(--primary))',
  				foreground: 'hsl(var(--primary-foreground))'
  			},
  			secondary: {
  				DEFAULT: 'hsl(var(--secondary))',
  				foreground: 'hsl(var(--secondary-foreground))'
  			},
  			muted: {
  				DEFAULT: 'hsl(var(--muted))',
  				foreground: 'hsl(var(--muted-foreground))'
  			},
  			accent: {
  				DEFAULT: 'hsl(var(--accent))',
  				foreground: 'hsl(var(--accent-foreground))'
  			},
  			destructive: {
  				DEFAULT: 'hsl(var(--destructive))',
  				foreground: 'hsl(var(--destructive-foreground))'
  			},
  			border: 'hsl(var(--border))',
  			input: 'hsl(var(--input))',
  			ring: 'hsl(var(--ring))',
  			chart: {
  				'1': 'hsl(var(--chart-1))',
  				'2': 'hsl(var(--chart-2))',
  				'3': 'hsl(var(--chart-3))',
  				'4': 'hsl(var(--chart-4))',
  				'5': 'hsl(var(--chart-5))'
  			}
  		},
  		borderRadius: {
  			lg: 'var(--radius)',
  			md: 'calc(var(--radius) - 2px)',
  			sm: 'calc(var(--radius) - 4px)'
  		}
  	}
  },
  plugins: [require("tailwindcss-animate")],
};
export default config;

```

## File: Tools\copyandpaste.js
```js
import { readFileSync, writeFileSync, readdirSync, statSync } from 'fs';
import { join, resolve, relative } from 'path';
import { fileURLToPath } from 'url';
import { dirname } from 'path';
import ignore from 'ignore';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Read .gitignore and create ignore filter
const gitignorePath = join(process.cwd(), '.gitignore');
const ig = ignore();
// Always ignore .git directory and README.md
ig.add(['.git/**', 'README.md', 'package-lock.json', 'notes/**', '.cursorignore', '.cursorrules']);
try {
    const gitignoreContent = readFileSync(gitignorePath, 'utf8');
    ig.add(gitignoreContent);
} catch (err) {
    console.warn('No .gitignore file found, proceeding without ignore rules');
}

// Remove IGNORED_DIRS constant since we'll use .gitignore rules instead
const MAX_FILE_SIZE = 10240 * 1024; // 10MB limit per file

function getAllFiles(dirPath, arrayOfFiles = [], indent = '') {
    const files = readdirSync(dirPath);
    let content = '';

    for (const file of files) {
        const fullPath = join(dirPath, file);
        const relativePath = relative(process.cwd(), fullPath);
        
        // Skip files/directories that match .gitignore rules
        if (ig.ignores(relativePath)) {
            continue;
        }

        const stats = statSync(fullPath);
        
        if (stats.isDirectory()) {
            // Skip if any parent directory is .git
            if (fullPath.includes('/.git/') || fullPath.includes('\\.git\\')) {
                continue;
            }
            content += `${indent}📁 ${file}/\n`;
            // Recursively get contents of subdirectories
            const { fileList, fileContent } = getAllFiles(fullPath, arrayOfFiles, indent + '  ');
            content += fileContent;
            arrayOfFiles = fileList;
        } else {
            // Skip if file is in .git directory
            if (fullPath.includes('/.git/') || fullPath.includes('\\.git\\')) {
                continue;
            }
            // Add file name to structure
            content += `${indent}📄 ${file}`;
            
            // Skip large files
            if (stats.size > MAX_FILE_SIZE) {
                content += ` (file too large - ${(stats.size / 10240 / 1024).toFixed(2)}MB)\n`;
                continue;
            }

            // Skip binary files or files with specific extensions
            const ext = file.toLowerCase().split('.').pop();
            if (['jpg', 'jpeg', 'png', 'gif', 'ico', 'woff', 'woff2', 'ttf', 'eot', 'mp3', 'mp4', 'zip', 'pdf'].includes(ext)) {
                content += ' (binary file - skipped)\n';
                continue;
            }

            content += '\n';
            
            // Add file contents
            try {
                const fileContent = readFileSync(fullPath, 'utf8');
                arrayOfFiles.push({
                    path: relativePath,
                    content: fileContent
                });
            } catch (err) {
                console.error(`Error reading file ${fullPath}: ${err}`);
                content += `${indent}  (error reading file)\n`;
            }
        }
    }

    return { fileList: arrayOfFiles, fileContent: content };
}

function generateFileStructureAndContents() {
    const parentDir = resolve(__dirname, '..');
    const { fileList, fileContent } = getAllFiles(parentDir);
    
    let outputContent = '# Project Structure\n\n';
    outputContent += fileContent;
    outputContent += '\n\n# File Contents\n\n';

    fileList.forEach(file => {
        // Get file extension for proper code block formatting
        const ext = file.path.split('.').pop() || '';
        outputContent += `\n## File: ${file.path}\n\`\`\`${ext}\n${file.content}\n\`\`\`\n`;
    });

    // Write to output file
    const outputPath = join(__dirname, 'project_structure_and_contents.txt');
    writeFileSync(outputPath, outputContent);
    console.log(`File structure and contents have been saved to: ${outputPath}`);
}

// Execute the function
generateFileStructureAndContents();

```

## File: tsconfig.json
```json
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    },
    "types": [
      "@aws-sdk/client-s3"
    ],
    "baseUrl": "."
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}

```

## File: types\dialogue.ts
```ts
export interface Dialogue {
  _id: string;
  index: number;
  timeStart: string;
  timeEnd: string;
  character: string;
  videoUrl: string;
  dialogue: {
    original: string;
    translated: string;
    adapted: string;
  };
  emotions?: {
    primary: {
      emotion: string;
      intensity: number;
    };
    secondary?: {
      emotion: string;
      intensity: number;
    };
  };
  direction?: string;
  lipMovements?: string;
  sceneContext?: string;
  technicalNotes?: string;
  culturalNotes?: string;
  status: string;
  voiceOverUrl?: string;
  voiceOverNotes?: string;
  directorNotes?: string;
  recordingStatus?: string;
  projectId?: string;
  updatedAt?: string;
  updatedBy?: string;
} 
```

## File: types\next-auth.d.ts
```ts
import 'next-auth'
import { JWT } from 'next-auth/jwt'

declare module 'next-auth' {
  interface Session {
    user: {
      id: string
      username: string
      role: string
      email: string | null
      name?: string | null
      image?: string | null
    }
  }

  interface User {
    id: string
    username: string
    role: string
    email?: string | null
  }
}

declare module 'next-auth/jwt' {
  interface JWT {
    id: string
    username: string
    role: string
    email?: string | null
  }
} 
```

## File: types\project.ts
```ts
export type ProjectStatus = 'pending' | 'in-progress' | 'completed' | 'on-hold';

interface AssignedUser {
  username: string;
  role: string;
}

export interface Project {
  _id: string;
  title: string;
  description: string;
  sourceLanguage: string;
  targetLanguage: string;
  status: ProjectStatus;
  videoPath?: string;
  dialogue_collection: string;
  assignedTo: AssignedUser[];
  updatedAt: string | Date;
  createdAt?: string | Date;
  
  // Episode specific fields
  episodeNumber: number;
  seasonNumber?: number;
  seriesTitle?: string;
  duration?: number; // in minutes
  originalAirDate?: string | Date;
  subtitleDeadline?: string | Date;
} 

export type UserRole = 
  | 'admin'
  | 'director'
  | 'voiceOver'
  | 'transcriber'
  | 'translator'; 
```

## File: types\user.ts
```ts
export type UserRole = 'transcriber' | 'translator' | 'voice-over' | 'director' | 'admin';

interface SessionLog {
  loginTime: string | Date;
  userAgent: string;
}

export interface User {
  _id: string;
  username: string;
  email: string;
  password?: string;
  role: UserRole;
  lastLogin?: string | Date;
  lastLogout?: string | Date | null;
  sessionsLog: SessionLog[];
  assignedProjects: string[];
  isActive: boolean;
  createdAt: string | Date;
  updatedAt: string | Date;
} 
```

## File: utils\audio.ts
```ts
export type AudioData = {
  audioData: Float32Array[];
  peakLevel: number;
};

export const createWorker = async (audioContext: AudioContext) => {
  const workletCode = `
    class RecorderProcessor extends AudioWorkletProcessor {
      constructor() {
        super();
        this.isRecording = true;
        this.bufferSize = 4096;
        this.sampleRate = 48000;
        this.isProcessing = false;
        this.isStopping = false;
        
        // Initialize buffer for each channel
        this.buffers = [new Float32Array(this.bufferSize), new Float32Array(this.bufferSize)];
        this.bufferIndex = 0;
        
        this.port.onmessage = (event) => {
          if (event.data === 'stop' && !this.isStopping) {
            this.isStopping = true;
            this.isRecording = false;
            // Send any remaining buffered data
            if (this.bufferIndex > 0) {
              this.flush();
            }
            // Send end signal
            this.port.postMessage({ type: 'stopped' });
          }
        };
      }

      flush() {
        if (this.bufferIndex > 0 && !this.isProcessing) {
          this.isProcessing = true;
          
          const audioData = this.buffers.map(buffer => {
            const trimmedBuffer = new Float32Array(this.bufferIndex);
            trimmedBuffer.set(buffer.subarray(0, this.bufferIndex));
            return trimmedBuffer;
          });
          
          const peakLevel = Math.max(
            ...audioData.map(channel => 
              Math.max(...channel.map(Math.abs))
            )
          );

          this.port.postMessage({ 
            type: 'chunk',
            audioData, 
            peakLevel 
          });
          
          // Reset buffers
          this.buffers = [new Float32Array(this.bufferSize), new Float32Array(this.bufferSize)];
          this.bufferIndex = 0;
          this.isProcessing = false;
        }
      }

      process(inputs) {
        const input = inputs[0];
        if (!input || input.length === 0 || !this.isRecording || this.isProcessing) return true;

        // Process each channel
        input.forEach((channel, channelIndex) => {
          if (channel && channel.length > 0) {
            // Calculate remaining space in buffer
            const remainingSpace = this.bufferSize - this.bufferIndex;
            
            if (remainingSpace >= channel.length) {
              // If we have enough space, add samples directly
              for (let i = 0; i < channel.length; i++) {
                // Apply gain and normalize
                this.buffers[channelIndex][this.bufferIndex + i] = 
                  Math.max(-1, Math.min(1, channel[i] * 1.5)); // gainFactor = 1.5
              }
              
              // Only increment buffer index after processing last channel
              if (channelIndex === input.length - 1) {
                this.bufferIndex += channel.length;
                
                // If buffer is full or nearly full, flush it
                if (this.bufferIndex >= this.bufferSize - 128) {
                  this.flush();
                }
              }
            } else {
              // If not enough space, fill current buffer and create new one
              for (let i = 0; i < remainingSpace; i++) {
                this.buffers[channelIndex][this.bufferIndex + i] = 
                  Math.max(-1, Math.min(1, channel[i] * 1.5));
              }
              
              if (channelIndex === input.length - 1) {
                // Flush the full buffer
                this.flush();
                
                // Process remaining samples
                const remainingSamples = channel.length - remainingSpace;
                for (let i = 0; i < remainingSamples; i++) {
                  this.buffers[channelIndex][i] = 
                    Math.max(-1, Math.min(1, channel[remainingSpace + i] * 1.5));
                }
                this.bufferIndex = remainingSamples;
              }
            }
          }
        });

        return true;
      }
    }

    registerProcessor('recorder-processor', RecorderProcessor);
  `;

  const blob = new Blob([workletCode], { type: 'application/javascript' });
  const workletUrl = URL.createObjectURL(blob);

  try {
    await audioContext.audioWorklet.addModule(workletUrl);
    const workletNode = new AudioWorkletNode(audioContext, 'recorder-processor', {
      numberOfInputs: 1,
      numberOfOutputs: 1,
      channelCount: 2,
      processorOptions: {
        sampleRate: 48000,
        bufferSize: 4096
      }
    });

    // Add message type handling
    workletNode.port.onmessage = (event) => {
      if (event.data.type === 'chunk') {
        workletNode.dispatchEvent(new CustomEvent('audiochunk', {
          detail: {
            audioData: event.data.audioData,
            peakLevel: event.data.peakLevel
          }
        }));
      } else if (event.data.type === 'stopped') {
        workletNode.dispatchEvent(new CustomEvent('stopped'));
      }
    };

    // Clean up the URL
    URL.revokeObjectURL(workletUrl);

    return workletNode;
  } catch (error) {
    console.error('Failed to create audio worklet:', error);
    URL.revokeObjectURL(workletUrl);
    throw error;
  }
};

export const createWavBlob = (audioData: Float32Array[], sampleRate: number = 48000): Blob => {
  const numChannels = audioData.length;
  const length = audioData[0].length;
  const buffer = new ArrayBuffer(44 + length * numChannels * 2);
  const view = new DataView(buffer);

  const writeString = (view: DataView, offset: number, string: string) => {
    for (let i = 0; i < string.length; i++) {
      view.setUint8(offset + i, string.charCodeAt(i));
    }
  };

  // Write WAV header
  writeString(view, 0, 'RIFF');
  view.setUint32(4, 36 + length * numChannels * 2, true);
  writeString(view, 8, 'WAVE');
  writeString(view, 12, 'fmt ');
  view.setUint32(16, 16, true);
  view.setUint16(20, 1, true);
  view.setUint16(22, numChannels, true);
  view.setUint32(24, sampleRate, true);
  view.setUint32(28, sampleRate * numChannels * 2, true);
  view.setUint16(32, numChannels * 2, true);
  view.setUint16(34, 16, true);
  writeString(view, 36, 'data');
  view.setUint32(40, length * numChannels * 2, true);

  // Write audio data
  const offset = 44;
  for (let i = 0; i < length; i++) {
    for (let channel = 0; channel < numChannels; channel++) {
      const sample = Math.max(-1, Math.min(1, audioData[channel][i]));
      view.setInt16(offset + (i * numChannels + channel) * 2, sample * 0x7FFF, true);
    }
  }

  return new Blob([buffer], { type: 'audio/wav' });
}; 
```

## File: utils\cn.ts
```ts
import { clsx, type ClassValue } from 'clsx';
import { twMerge } from 'tailwind-merge';

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
} 
```

## File: utils\formatters.ts
```ts
export const getNumberValue = (mongoNumber: any): number => {
  if (typeof mongoNumber === 'object' && mongoNumber !== null) {
    if ('$numberInt' in mongoNumber) return Number(mongoNumber.$numberInt);
    if ('$numberDouble' in mongoNumber) return Number(mongoNumber.$numberDouble);
  }
  return Number(mongoNumber);
};

export const formatTime = (seconds: number): string => {
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  const secs = Math.floor(seconds % 60);
  const milliseconds = Math.floor((seconds % 1) * 1000);

  return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}:${milliseconds.toString().padStart(3, '0')}`;
};

export const calculateDuration = (timeStart: string, timeEnd: string): number => {
  const parseTime = (time: string): number => {
    const [hours, minutes, seconds, milliseconds] = time.split(':').map(Number);
    return (hours * 3600) + (minutes * 60) + seconds + (milliseconds / 1000);
  };
  
  const startSeconds = parseTime(timeStart);
  const endSeconds = parseTime(timeEnd);
  return Number((endSeconds - startSeconds).toFixed(3));
}; 
```

## File: __tests__\components\TranscriberDialogueView.test.tsx
```tsx
import { render, screen, fireEvent, waitFor } from '@testing-library/react'
import TranscriberDialogueView from '@/components/TranscriberDialogueView'
import { renderWithQuery } from '../testUtils'

// Mock framer-motion
jest.mock('framer-motion', () => ({
  motion: {
    div: ({ children, onDragEnd, ...props }) => (
      <div data-testid="motion-div" onClick={() => onDragEnd?.({}, { offset: { x: -150 } })} {...props}>
        {children}
      </div>
    )
  },
  useMotionValue: jest.fn(() => ({
    set: jest.fn(),
    get: jest.fn()
  })),
  useTransform: jest.fn(() => ({
    set: jest.fn(),
    get: jest.fn()
  })),
  useAnimation: jest.fn(() => ({
    start: jest.fn()
  }))
}))

const mockDialogues = [
  {
    _id: '1',
    index: 0,
    timeStart: '00:00.000',
    timeEnd: '00:05.000',
    character: 'Character 1',
    videoUrl: 'http://example.com/video1.mp4',
    dialogue: {
      original: 'Original text 1',
      translated: '',
      adapted: '',
    },
    status: 'pending',
  },
  {
    _id: '2',
    index: 1,
    timeStart: '00:05.000',
    timeEnd: '00:10.000',
    character: 'Character 2',
    videoUrl: 'http://example.com/video1.mp4',
    dialogue: {
      original: 'Original text 2',
      translated: '',
      adapted: '',
    },
    status: 'pending',
  },
]

// Mock fetch function
global.fetch = jest.fn()

describe('TranscriberDialogueView', () => {
  beforeEach(() => {
    jest.clearAllMocks()
  })

  it('renders without crashing', () => {
    renderWithQuery(<TranscriberDialogueView dialogues={mockDialogues} projectId="123" />)
    expect(screen.getByText('Character')).toBeInTheDocument()
  })

  it('displays "No dialogues available" when dialogues array is empty', () => {
    renderWithQuery(<TranscriberDialogueView dialogues={[]} projectId="123" />)
    expect(screen.getByText('No dialogues available')).toBeInTheDocument()
  })

  it('displays the first dialogue by default', () => {
    renderWithQuery(<TranscriberDialogueView dialogues={mockDialogues} projectId="123" />)
    expect(screen.getByDisplayValue('Character 1')).toBeInTheDocument()
    expect(screen.getByDisplayValue('Original text 1')).toBeInTheDocument()
  })

  it('updates character input', () => {
    renderWithQuery(<TranscriberDialogueView dialogues={mockDialogues} projectId="123" />)
    const characterInput = screen.getByLabelText('Character')
    fireEvent.change(characterInput, { target: { value: 'New Character' } })
    expect(characterInput.value).toBe('New Character')
  })

  it('updates transcription text', () => {
    renderWithQuery(<TranscriberDialogueView dialogues={mockDialogues} projectId="123" />)
    const transcriptionArea = screen.getByLabelText('Transcription')
    fireEvent.change(transcriptionArea, { target: { value: 'New transcription text' } })
    expect(transcriptionArea.value).toBe('New transcription text')
  })

  it('shows confirmation modal when trying to navigate with unsaved changes', () => {
    renderWithQuery(<TranscriberDialogueView dialogues={mockDialogues} projectId="123" />)
    
    // Make changes
    const characterInput = screen.getByLabelText('Character')
    fireEvent.change(characterInput, { target: { value: 'New Character' } })
    
    // Try to navigate using motion div
    const motionDiv = screen.getByTestId('motion-div')
    fireEvent.click(motionDiv)
    
    expect(screen.getByText('Unsaved Changes')).toBeInTheDocument()
    expect(screen.getByText('You have unsaved changes. What would you like to do?')).toBeInTheDocument()
  })

  it('saves changes successfully', async () => {
    // Mock successful API response
    const mockResponse = {
      ok: true,
      json: () => Promise.resolve(mockDialogues[0]),
    }
    ;(global.fetch as jest.Mock).mockResolvedValueOnce(mockResponse)

    renderWithQuery(<TranscriberDialogueView dialogues={mockDialogues} projectId="123" />)
    
    // Make changes
    const characterInput = screen.getByLabelText('Character')
    fireEvent.change(characterInput, { target: { value: 'New Character' } })
    
    // Save changes
    const saveButton = screen.getByText('Save Transcription')
    fireEvent.click(saveButton)
    
    await waitFor(() => {
      expect(screen.getByText('Transcription saved successfully!')).toBeInTheDocument()
    })
  })

  it('handles save error gracefully', async () => {
    // Mock failed API response
    const mockResponse = {
      ok: false,
      json: () => Promise.resolve({ error: 'Failed to save' }),
    }
    ;(global.fetch as jest.Mock).mockResolvedValueOnce(mockResponse)

    renderWithQuery(<TranscriberDialogueView dialogues={mockDialogues} projectId="123" />)
    
    // Make changes
    const characterInput = screen.getByLabelText('Character')
    fireEvent.change(characterInput, { target: { value: 'New Character' } })
    
    // Try to save
    const saveButton = screen.getByText('Save Transcription')
    fireEvent.click(saveButton)
    
    await waitFor(() => {
      expect(screen.getByText('Failed to save')).toBeInTheDocument()
    })
  })

  it('handles video playback controls', () => {
    renderWithQuery(<TranscriberDialogueView dialogues={mockDialogues} projectId="123" />)
    
    expect(screen.getByText('Play')).toBeInTheDocument()
    expect(screen.getByText('-5s')).toBeInTheDocument()
    expect(screen.getByText('Speed:')).toBeInTheDocument()
    expect(screen.getByText('1x')).toBeInTheDocument()
  })

  it('displays time values correctly', () => {
    const dialoguesWithTime = [{
      ...mockDialogues[0],
      timeStart: '00:30.500',
      timeEnd: '00:35.750'
    }]
    
    renderWithQuery(<TranscriberDialogueView dialogues={dialoguesWithTime} projectId="123" />)
    
    const startTime = screen.getByText('00:30.500')
    const endTime = screen.getByText('00:35.750')
    
    expect(startTime).toBeInTheDocument()
    expect(endTime).toBeInTheDocument()
  })

  it('displays default time format when times are not set', () => {
    const dialoguesWithoutTime = [{
      ...mockDialogues[0],
      timeStart: '',
      timeEnd: ''
    }]
    
    renderWithQuery(<TranscriberDialogueView dialogues={dialoguesWithoutTime} projectId="123" />)
    
    const defaultTime = screen.getAllByText('00:00.000')
    expect(defaultTime).toHaveLength(2) // Both start and end time show default
  })
}) 
```

## File: __tests__\components\TranscriberView.test.tsx
```tsx
import { render, screen, fireEvent, waitFor, act } from '@testing-library/react'
import { useSession, signOut } from 'next-auth/react'
import { useRouter } from 'next/navigation'
import TranscriberView from '@/components/TranscriberView'
import { Project } from '@/types/project'
import '@testing-library/jest-dom'

jest.mock('next-auth/react')
jest.mock('next/navigation', () => ({
  useRouter: jest.fn(),
}))

describe('TranscriberView', () => {
  const mockRouter = {
    push: jest.fn(),
    replace: jest.fn(),
  }

  const mockSession = {
    data: {
      user: { 
        role: 'transcriber' as const,
        username: 'testuser',
      },
    },
    status: 'authenticated' as const,
  }

  const mockProjects: Project[] = [{
    _id: 'project1',
    title: 'Test Project 1',
    description: 'Test Description 1',
    sourceLanguage: 'English',
    targetLanguage: 'Spanish',
    status: 'active',
    assignedTo: [{
      username: 'testuser',
      role: 'transcriber',
    }],
  }, {
    _id: 'project2',
    title: 'Test Project 2',
    description: 'Test Description 2',
    sourceLanguage: 'French',
    targetLanguage: 'German',
    status: 'pending',
    assignedTo: [{
      username: 'testuser',
      role: 'transcriber',
    }],
  }]

  beforeEach(() => {
    jest.clearAllMocks()
    ;(useSession as jest.Mock).mockReturnValue(mockSession)
    ;(useRouter as jest.Mock).mockReturnValue(mockRouter)
    ;(signOut as jest.Mock).mockImplementation(() => Promise.resolve())
    // Clear localStorage before each test
    if (typeof window !== 'undefined') {
      window.localStorage.clear()
    }
  })

  describe('Rendering', () => {
    it('renders project cards correctly', () => {
      render(<TranscriberView projects={mockProjects} />)
      
      expect(screen.getByText('Test Project 1')).toBeInTheDocument()
      expect(screen.getByText('Test Project 2')).toBeInTheDocument()
      expect(screen.getByText('Source Language: English')).toBeInTheDocument()
      expect(screen.getByText('Source Language: French')).toBeInTheDocument()
    })

    it('displays no projects message when user has no assignments', () => {
      const projectWithoutAssignments = [{
        ...mockProjects[0],
        assignedTo: [{
          username: 'otheruser',
          role: 'transcriber',
        }],
      }]

      render(<TranscriberView projects={projectWithoutAssignments} />)
      expect(screen.getByText('No projects assigned to you as a transcriber.')).toBeInTheDocument()
    })
  })

  describe('Navigation', () => {
    it('navigates to project details when clicking a project card', async () => {
      render(<TranscriberView projects={mockProjects} />)
      
      const projectCard = screen.getByText('Test Project 1').closest('div')
      expect(projectCard).toHaveAttribute('role', 'button')
      
      await act(async () => {
        fireEvent.click(projectCard!)
      })

      await waitFor(() => {
        expect(mockRouter.push).toHaveBeenCalledWith('/allDashboards/transcriber/project1')
      })
    })

    it('prevents navigation when project card is disabled', async () => {
      const disabledProjects = [{
        ...mockProjects[0],
        status: 'locked',
      }]

      render(<TranscriberView projects={disabledProjects} />)
      
      const projectCard = screen.getByText('Test Project 1').closest('div')
      expect(projectCard).toHaveAttribute('aria-disabled', 'true')
      
      await act(async () => {
        fireEvent.click(projectCard!)
      })
      
      expect(mockRouter.push).not.toHaveBeenCalled()
    })
  })

  describe('Authentication', () => {
    it('handles logout correctly', async () => {
      render(<TranscriberView projects={mockProjects} />)
      
      const logoutButton = screen.getByRole('button', { name: /logout/i })
      
      await act(async () => {
        fireEvent.click(logoutButton)
      })

      await waitFor(() => {
        expect(signOut).toHaveBeenCalledWith({ 
          redirect: true, 
          callbackUrl: '/login' 
        })
        expect(window.localStorage.length).toBe(0)
      })
    })

    it('handles failed logout', async () => {
      // Mock signOut to fail
      const mockError = new Error('Logout failed')
      ;(signOut as jest.Mock).mockRejectedValueOnce(mockError)

      render(<TranscriberView projects={mockProjects} />)
      
      const logoutButton = screen.getByRole('button', { name: /logout/i })
      
      await act(async () => {
        fireEvent.click(logoutButton)
      })

      await waitFor(() => {
        expect(mockRouter.replace).toHaveBeenCalledWith('/login')
      })
    })
  })

  describe('Edge Cases', () => {
    it('handles projects with empty assignedTo array', () => {
      const projectWithoutAssignedTo = [{
        ...mockProjects[0],
        assignedTo: [],
      }]

      render(<TranscriberView projects={projectWithoutAssignedTo} />)
      expect(screen.getByText('No projects assigned to you as a transcriber.')).toBeInTheDocument()
    })

    it('handles empty projects array', () => {
      render(<TranscriberView projects={[]} />)
      expect(screen.getByText('No projects assigned to you as a transcriber.')).toBeInTheDocument()
    })
  })

  describe('Accessibility', () => {
    it('has accessible buttons and links', () => {
      render(<TranscriberView projects={mockProjects} />)
      
      const logoutButton = screen.getByRole('button', { name: /logout/i })
      expect(logoutButton).toHaveAttribute('aria-label', 'Logout')
      
      const projectCards = screen.getAllByRole('button')
      expect(projectCards.length).toBeGreaterThan(0)
      projectCards.forEach(card => {
        expect(card).toHaveAttribute('aria-label')
      })
    })

    it('provides proper keyboard navigation', () => {
      render(<TranscriberView projects={mockProjects} />)
      
      const projectCards = screen.getAllByRole('button')
      projectCards.forEach(card => {
        expect(card).toHaveAttribute('tabIndex', '0')
      })
    })
  })
}) 
```

## File: __tests__\components\VoiceOverDialogueView.test.tsx
```tsx
import { render, screen, fireEvent, waitFor, act } from '@testing-library/react'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import VoiceOverDialogueView from '@/components/VoiceOverDialogueView'
import type { Dialogue } from '@/types/dialogue'
import '@testing-library/jest-dom'

// Mock framer-motion
jest.mock('framer-motion', () => ({
  motion: {
    div: ({ children, ...props }: { children: React.ReactNode; [key: string]: any }) => (
      <div {...props}>{children}</div>
    ),
  },
  useMotionValue: jest.fn(() => ({
    set: jest.fn(),
    get: jest.fn(),
  })),
  useTransform: jest.fn(),
  useAnimation: jest.fn(() => ({
    start: jest.fn(),
  })),
}))

interface MockMediaStream {
  getTracks: () => { stop: () => void }[];
}

interface MockMediaStreamSource {
  connect: jest.Mock;
  disconnect: jest.Mock;
  mediaStream: MockMediaStream;
}

interface MockGainNode {
  connect: jest.Mock;
  gain: { value: number };
}

// Mock Audio Context and related APIs
class MockAudioContext {
  createMediaStreamSource = jest.fn((): MockMediaStreamSource => ({
    connect: jest.fn(),
    disconnect: jest.fn(),
    mediaStream: {
      getTracks: () => [{
        stop: jest.fn(),
      }],
    },
  }))

  createGain = jest.fn((): MockGainNode => ({
    connect: jest.fn(),
    gain: { value: 1 },
  }))

  destination = {}
  sampleRate = 44100
  close = jest.fn()
  audioWorklet = {
    addModule: jest.fn().mockResolvedValue(undefined),
  }

  createBuffer = jest.fn(() => ({
    duration: 2,
    numberOfChannels: 2,
    sampleRate: 44100,
    getChannelData: jest.fn(() => new Float32Array([0, 0.1, -0.1])),
  }))

  createBufferSource = jest.fn(() => ({
    connect: jest.fn(),
    disconnect: jest.fn(),
    start: jest.fn(),
    stop: jest.fn(),
    buffer: null,
  }))
}

class MockAudioWorkletNode {
  connect = jest.fn()
  disconnect = jest.fn()
  port = {
    onmessage: jest.fn(),
    postMessage: jest.fn(),
  }
}

// Mock URL.createObjectURL
global.URL.createObjectURL = jest.fn(() => 'mock-url')
global.URL.revokeObjectURL = jest.fn()

global.AudioContext = MockAudioContext as any
global.AudioWorkletNode = MockAudioWorkletNode as any

// Mock HTMLMediaElement methods
Object.defineProperty(window.HTMLMediaElement.prototype, 'play', {
  configurable: true,
  value: jest.fn().mockResolvedValue(undefined),
})

Object.defineProperty(window.HTMLMediaElement.prototype, 'pause', {
  configurable: true,
  value: jest.fn(),
})

Object.defineProperty(window.HTMLMediaElement.prototype, 'load', {
  configurable: true,
  value: jest.fn(),
})

// Mock createWorker
jest.mock('@/utils/audio', () => ({
  createWorker: jest.fn().mockResolvedValue({
    connect: jest.fn(),
    disconnect: jest.fn(),
    port: {
      onmessage: jest.fn((event: (arg: { data: { audioData: Float32Array[] } }) => void) => {
        event({
          data: {
            audioData: [new Float32Array([0, 0.1, -0.1]), new Float32Array([0, 0.2, -0.2])],
          },
        })
      }),
      postMessage: jest.fn(),
    },
  }),
  createWavBlob: jest.fn().mockReturnValue(new Blob(['mock-audio-data'], { type: 'audio/wav' })),
}))

describe('VoiceOverDialogueView Component', () => {
  const mockDialogues: Dialogue[] = [
    {
      _id: 'dialogue1',
      index: 0,
      timeStart: '00:00:00:000',
      timeEnd: '00:00:02:000',
      character: 'Character 1',
      videoUrl: 'test-video-url-1',
      dialogue: {
        original: 'Original text 1',
        translated: 'Translated text 1',
        adapted: 'Adapted text 1',
      },
      emotions: {
        primary: {
          emotion: 'happy',
          intensity: 5,
        },
        secondary: {
          emotion: 'excited',
          intensity: 3,
        },
      },
      direction: 'Test direction',
      lipMovements: 2,
      sceneContext: 'Test scene context',
      technicalNotes: 'Test technical notes',
      culturalNotes: 'Test cultural notes',
      status: 'pending',
      recordingStatus: 'not-started',
      projectId: 'project1',
      updatedAt: '2024-01-01',
      updatedBy: 'user1',
      voiceOverUrl: undefined,
    },
    {
      _id: 'dialogue2',
      index: 1,
      timeStart: '00:00:02:000',
      timeEnd: '00:00:04:000',
      character: 'Character 2',
      videoUrl: 'test-video-url-2',
      dialogue: {
        original: 'Original text 2',
        translated: 'Translated text 2',
        adapted: 'Adapted text 2',
      },
      emotions: {
        primary: {
          emotion: 'sad',
          intensity: 4,
        },
        secondary: {
          emotion: 'worried',
          intensity: 2,
        },
      },
      direction: 'Test direction 2',
      lipMovements: 3,
      sceneContext: 'Test scene context 2',
      technicalNotes: 'Test technical notes 2',
      culturalNotes: 'Test cultural notes 2',
      status: 'pending',
      recordingStatus: 'not-started',
      projectId: 'project1',
      updatedAt: '2024-01-01',
      updatedBy: 'user1',
      voiceOverUrl: undefined,
    },
  ]

  const queryClient = new QueryClient({
    defaultOptions: {
      queries: {
        retry: false,
      },
    },
  })

  const renderComponent = () => {
    return render(
      <QueryClientProvider client={queryClient}>
        <VoiceOverDialogueView dialogues={mockDialogues as Dialogue[]} projectId="project1" />
      </QueryClientProvider>
    )
  }

  beforeEach(() => {
    jest.clearAllMocks()
    jest.useFakeTimers()
    // Mock getUserMedia
    Object.defineProperty(global.navigator, 'mediaDevices', {
      value: {
        getUserMedia: jest.fn().mockResolvedValue({
          getTracks: () => [{
            stop: jest.fn(),
          }],
        }),
      },
      writable: true,
    })

    // Mock fetch
    global.fetch = jest.fn().mockImplementation(() =>
      Promise.resolve({
        ok: true,
        json: () => Promise.resolve({ url: 'test-voice-over-url' }),
      })
    )

    // Reset URL.createObjectURL mock
    ;(global.URL.createObjectURL as jest.Mock).mockReset()
    ;(global.URL.createObjectURL as jest.Mock).mockReturnValue('mock-url')

    // Mock window.confirm
    window.confirm = jest.fn(() => true)
  })

  afterEach(() => {
    jest.clearAllMocks()
    jest.useRealTimers()
  })

  it('renders initial dialogue correctly', async () => {
    renderComponent()

    await waitFor(() => {
      expect(screen.getByText('Character 1')).toBeInTheDocument()
      expect(screen.getByText('Original text 1')).toBeInTheDocument()
      expect(screen.getByText('Translated text 1')).toBeInTheDocument()
      expect(screen.getByText('Adapted text 1')).toBeInTheDocument()
    })
  })

  it('handles recording start and stop', async () => {
    renderComponent()

    const startButton = screen.getByText('Start Recording')
    await act(async () => {
      fireEvent.click(startButton)
      // Wait for async operations
      await Promise.resolve()
    })

    await waitFor(() => {
      expect(navigator.mediaDevices.getUserMedia).toHaveBeenCalled()
    })

    // Wait for countdown
    await act(async () => {
      jest.advanceTimersByTime(4000)
      await Promise.resolve()
    })

    const stopButton = screen.getByText('Stop Recording')
    await act(async () => {
      fireEvent.click(stopButton)
      // Wait for async operations
      await Promise.resolve()
    })

    await waitFor(() => {
      expect(screen.getByText('Start Recording')).toBeInTheDocument()
    })
  })

  it('handles navigation between dialogues', async () => {
    renderComponent()

    // Check initial dialogue
    expect(screen.getByText('Character 1')).toBeInTheDocument()

    // Navigate to next dialogue
    const nextButton = screen.getByRole('button', { name: /next/i })
    await act(async () => {
      fireEvent.click(nextButton)
      // Wait for async operations
      await Promise.resolve()
    })

    await waitFor(() => {
      expect(screen.getByText('Character 2')).toBeInTheDocument()
      expect(screen.getByText('Original text 2')).toBeInTheDocument()
    })

    // Navigate back
    const prevButton = screen.getByRole('button', { name: /previous/i })
    await act(async () => {
      fireEvent.click(prevButton)
      // Wait for async operations
      await Promise.resolve()
    })

    await waitFor(() => {
      expect(screen.getByText('Character 1')).toBeInTheDocument()
      expect(screen.getByText('Original text 1')).toBeInTheDocument()
    })
  })

  it('shows confirmation dialog when navigating with unsaved changes', async () => {
    renderComponent()

    // Start and stop recording to create unsaved changes
    const startButton = screen.getByText('Start Recording')
    await act(async () => {
      fireEvent.click(startButton)
      // Wait for async operations
      await Promise.resolve()
    })

    // Wait for countdown
    await act(async () => {
      jest.advanceTimersByTime(1000)
      expect(screen.getByText('3')).toBeInTheDocument()
      jest.advanceTimersByTime(1000)
      expect(screen.getByText('2')).toBeInTheDocument()
      jest.advanceTimersByTime(1000)
      expect(screen.getByText('1')).toBeInTheDocument()
      jest.advanceTimersByTime(1000)
      // Wait for async operations
      await Promise.resolve()
    })

    const stopButton = screen.getByText('Stop Recording')
    await act(async () => {
      fireEvent.click(stopButton)
      // Wait for async operations
      await Promise.resolve()
    })

    // Try to navigate
    const nextButton = screen.getByText('Next')
    await act(async () => {
      fireEvent.click(nextButton)
      // Wait for async operations
      await Promise.resolve()
    })

    // Check for confirmation dialog
    expect(window.confirm).toHaveBeenCalled()
  })

  it('handles video playback controls', async () => {
    renderComponent()

    const video = screen.getByTestId('dialogue-video') as HTMLVideoElement
    
    // Test play/pause
    const playButton = screen.getByText('Play')
    await act(async () => {
      fireEvent.click(playButton)
      // Wait for async operations
      await Promise.resolve()
    })
    expect(video.play).toHaveBeenCalled()

    // Test rewind
    const rewindButton = screen.getByText('Rewind')
    await act(async () => {
      fireEvent.click(rewindButton)
      // Wait for async operations
      await Promise.resolve()
    })
    expect(video.currentTime).toBe(0)

    // Test playback rate
    const playbackRateButton = screen.getByText('1x')
    await act(async () => {
      fireEvent.click(playbackRateButton)
      // Wait for async operations
      await Promise.resolve()
    })
    expect(video.playbackRate).toBe(1.5)
  })

  it('handles save functionality', async () => {
    renderComponent()

    // Create a recording
    const startButton = screen.getByText('Start Recording')
    await act(async () => {
      fireEvent.click(startButton)
      // Wait for async operations
      await Promise.resolve()
    })

    // Wait for countdown
    await act(async () => {
      jest.advanceTimersByTime(4000)
      await Promise.resolve()
    })

    const stopButton = screen.getByText('Stop Recording')
    await act(async () => {
      fireEvent.click(stopButton)
      // Wait for async operations
      await Promise.resolve()
    })

    // Wait for audio processing
    await act(async () => {
      await Promise.resolve()
    })

    // Try to save
    const saveButton = screen.getByText('Add Voice-over')
    await act(async () => {
      fireEvent.click(saveButton)
      // Wait for async operations
      await Promise.resolve()
    })

    await waitFor(() => {
      expect(fetch).toHaveBeenCalledWith('/api/upload-voice-over', expect.any(Object))
      expect(screen.getByText(/saved successfully/i)).toBeInTheDocument()
    }, { timeout: 10000 })
  })

  it('handles recording errors', async () => {
    // Mock getUserMedia to fail
    Object.defineProperty(global.navigator, 'mediaDevices', {
      value: {
        getUserMedia: jest.fn().mockRejectedValue(new Error('Permission denied')),
      },
      writable: true,
    })

    renderComponent()

    const startButton = screen.getByText('Start Recording')
    await act(async () => {
      fireEvent.click(startButton)
    })

    await waitFor(() => {
      expect(screen.getByText(/permission denied/i)).toBeInTheDocument()
    })
  })

  it('handles save errors', async () => {
    // Mock fetch to fail
    global.fetch = jest.fn().mockImplementation(() =>
      Promise.resolve({
        ok: false,
        status: 500,
        statusText: 'Internal Server Error',
      })
    )

    renderComponent()

    // Create a recording
    const startButton = screen.getByText('Start Recording')
    await act(async () => {
      fireEvent.click(startButton)
      // Wait for async operations
      await Promise.resolve()
    })

    // Wait for countdown
    await act(async () => {
      jest.advanceTimersByTime(4000)
      await Promise.resolve()
    })

    const stopButton = screen.getByText('Stop Recording')
    await act(async () => {
      fireEvent.click(stopButton)
      // Wait for async operations
      await Promise.resolve()
    })

    // Wait for audio processing
    await act(async () => {
      await Promise.resolve()
    })

    // Try to save
    const saveButton = screen.getByText('Add Voice-over')
    await act(async () => {
      fireEvent.click(saveButton)
      // Wait for async operations
      await Promise.resolve()
    })

    await waitFor(() => {
      expect(screen.getByText(/failed to save/i)).toBeInTheDocument()
    }, { timeout: 10000 })
  })
}) 
```

## File: __tests__\components\VoiceOverView.test.tsx
```tsx
import { render, screen, fireEvent, waitFor, act } from '@testing-library/react'
import { useSession, signOut } from 'next-auth/react'
import { useRouter } from 'next/navigation'
import VoiceOverView from '@/components/VoiceOverView'
import { Project } from '@/types/project'
import '@testing-library/jest-dom'

jest.mock('next-auth/react')
jest.mock('next/navigation', () => ({
  useRouter: jest.fn(),
}))

describe('VoiceOverView', () => {
  const mockRouter = {
    push: jest.fn(),
    replace: jest.fn(),
  }

  const mockSession = {
    data: {
      user: { 
        role: 'voice-over' as const,
        username: 'testuser',
      },
    },
    status: 'authenticated' as const,
  }

  const mockProjects: Project[] = [{
    _id: 'project1',
    title: 'Test Project 1',
    description: 'Test Description 1',
    sourceLanguage: 'English',
    targetLanguage: 'Spanish',
    status: 'active',
    assignedTo: [{
      username: 'testuser',
      role: 'voice-over',
    }],
  }, {
    _id: 'project2',
    title: 'Test Project 2',
    description: 'Test Description 2',
    sourceLanguage: 'French',
    targetLanguage: 'German',
    status: 'pending',
    assignedTo: [{
      username: 'testuser',
      role: 'voice-over',
    }],
  }]

  beforeEach(() => {
    jest.clearAllMocks()
    ;(useSession as jest.Mock).mockReturnValue(mockSession)
    ;(useRouter as jest.Mock).mockReturnValue(mockRouter)
    ;(signOut as jest.Mock).mockImplementation(() => Promise.resolve())
    
    // Clear localStorage before each test
    if (typeof window !== 'undefined') {
      window.localStorage.clear()
    }
  })

  describe('Rendering', () => {
    it('renders project cards correctly', () => {
      render(<VoiceOverView projects={mockProjects} />)
      
      expect(screen.getByText('Test Project 1')).toBeInTheDocument()
      expect(screen.getByText('Test Project 2')).toBeInTheDocument()
      expect(screen.getByText('Source Language: English')).toBeInTheDocument()
      expect(screen.getByText('Source Language: French')).toBeInTheDocument()
    })

    it('displays no projects message when user has no assignments', () => {
      const projectWithoutAssignments = [{
        ...mockProjects[0],
        assignedTo: [{
          username: 'otheruser',
          role: 'voice-over',
        }],
      }]

      render(<VoiceOverView projects={projectWithoutAssignments} />)
      expect(screen.getByText('No projects assigned to you as a voice-over artist.')).toBeInTheDocument()
    })
  })

  describe('Navigation', () => {
    it('navigates to project details when clicking a project card', async () => {
      render(<VoiceOverView projects={mockProjects} />)
      
      const projectCard = screen.getByText('Test Project 1').closest('div')
      expect(projectCard).toHaveAttribute('role', 'button')
      
      await act(async () => {
        fireEvent.click(projectCard!)
      })

      await waitFor(() => {
        expect(mockRouter.push).toHaveBeenCalledWith('/allDashboards/voice-over/project1')
      })
    })

    it('prevents navigation when project card is disabled', async () => {
      const disabledProjects = [{
        ...mockProjects[0],
        status: 'locked',
      }]

      render(<VoiceOverView projects={disabledProjects} />)
      
      const projectCard = screen.getByText('Test Project 1').closest('div')
      expect(projectCard).toHaveAttribute('aria-disabled', 'true')
      
      await act(async () => {
        fireEvent.click(projectCard!)
      })
      
      expect(mockRouter.push).not.toHaveBeenCalled()
    })
  })

  describe('Authentication', () => {
    it('handles logout correctly', async () => {
      render(<VoiceOverView projects={mockProjects} />)
      
      const logoutButton = screen.getByRole('button', { name: /logout/i })
      
      await act(async () => {
        fireEvent.click(logoutButton)
      })

      await waitFor(() => {
        expect(signOut).toHaveBeenCalledWith({ 
          redirect: true, 
          callbackUrl: '/login' 
        })
        expect(window.localStorage.length).toBe(0)
      })
    })

    it('handles failed logout', async () => {
      // Mock signOut to fail
      const mockError = new Error('Logout failed')
      ;(signOut as jest.Mock).mockRejectedValueOnce(mockError)

      render(<VoiceOverView projects={mockProjects} />)
      
      const logoutButton = screen.getByRole('button', { name: /logout/i })
      
      await act(async () => {
        fireEvent.click(logoutButton)
      })

      await waitFor(() => {
        expect(mockRouter.replace).toHaveBeenCalledWith('/login')
      })
    })
  })

  describe('Edge Cases', () => {
    it('handles projects with empty assignedTo array', () => {
      const projectWithoutAssignedTo = [{
        ...mockProjects[0],
        assignedTo: [],
      }]

      render(<VoiceOverView projects={projectWithoutAssignedTo} />)
      expect(screen.getByText('No projects assigned to you as a voice-over artist.')).toBeInTheDocument()
    })

    it('handles empty projects array', () => {
      render(<VoiceOverView projects={[]} />)
      expect(screen.getByText('No projects assigned to you as a voice-over artist.')).toBeInTheDocument()
    })
  })

  describe('Accessibility', () => {
    it('has accessible buttons and links', () => {
      render(<VoiceOverView projects={mockProjects} />)
      
      const logoutButton = screen.getByRole('button', { name: /logout/i })
      expect(logoutButton).toHaveAttribute('aria-label', 'Logout')
      
      const projectCards = screen.getAllByRole('button')
      expect(projectCards.length).toBeGreaterThan(0)
      projectCards.forEach(card => {
        expect(card).toHaveAttribute('aria-label')
      })
    })

    it('provides proper keyboard navigation', () => {
      render(<VoiceOverView projects={mockProjects} />)
      
      const projectCards = screen.getAllByRole('button')
      projectCards.forEach(card => {
        expect(card).toHaveAttribute('tabIndex', '0')
      })
    })
  })
}) 
```

## File: __tests__\login.test.tsx
```tsx
import { render, screen, fireEvent, waitFor } from '@testing-library/react'
import { signIn } from 'next-auth/react'
import { useRouter } from 'next/navigation'
import Login from '@/app/login/page'

jest.mock('next-auth/react')
jest.mock('next/navigation', () => ({
  useRouter: jest.fn()
}))

describe('Login Page', () => {
  const mockSignIn = signIn as jest.Mock
  const mockPush = jest.fn()

  beforeEach(() => {
    mockSignIn.mockClear()
    mockPush.mockClear()
    ;(useRouter as jest.Mock).mockReturnValue({ push: mockPush })
  })

  it('renders login form', () => {
    render(<Login />)
    
    expect(screen.getByLabelText(/username/i)).toBeInTheDocument()
    expect(screen.getByLabelText(/password/i)).toBeInTheDocument()
    expect(screen.getByRole('button', { name: /log in/i })).toBeInTheDocument()
  })

  it('handles successful login', async () => {
    mockSignIn.mockResolvedValueOnce({ error: null })
    
    render(<Login />)
    
    fireEvent.change(screen.getByLabelText(/username/i), {
      target: { value: 'testuser' },
    })
    fireEvent.change(screen.getByLabelText(/password/i), {
      target: { value: 'password123' },
    })
    fireEvent.click(screen.getByRole('button', { name: /log in/i }))

    await waitFor(() => {
      expect(mockSignIn).toHaveBeenCalledWith('credentials', {
        username: 'testuser',
        password: 'password123',
        redirect: false,
      })
      expect(mockPush).toHaveBeenCalledWith('/dashboard')
    })
  })

  it('handles login error', async () => {
    const consoleErrorSpy = jest.spyOn(console, 'error').mockImplementation()
    mockSignIn.mockResolvedValueOnce({ error: 'Invalid credentials' })
    
    render(<Login />)
    
    fireEvent.change(screen.getByLabelText(/username/i), {
      target: { value: 'wronguser' },
    })
    fireEvent.change(screen.getByLabelText(/password/i), {
      target: { value: 'wrongpass' },
    })
    fireEvent.click(screen.getByRole('button', { name: /log in/i }))

    await waitFor(() => {
      expect(consoleErrorSpy).toHaveBeenCalledWith('Invalid credentials')
      expect(mockPush).not.toHaveBeenCalled()
    })

    consoleErrorSpy.mockRestore()
  })
}) 
```

## File: __tests__\mongodb.test.ts
```ts
// Mock MongoDB module before importing anything else
jest.mock('mongodb', () => ({
    MongoClient: jest.fn()
}));

import { Db, MongoClient } from 'mongodb';
import type { jest } from '@jest/globals';

interface MockDbConnection {
    client: MongoClient;
    db: Db;
}

// Mock the mongodb.ts module
jest.mock('../lib/mongodb', () => {
    const mockCollection = {
        find: jest.fn().mockReturnValue({
            toArray: jest.fn().mockResolvedValue([])
        }),
        findOne: jest.fn()
    };

    const mockDb = {
        collection: jest.fn().mockReturnValue(mockCollection)
    } as unknown as Db;

    const mockClient = {
        connect: jest.fn(),
        db: jest.fn()
    } as unknown as MongoClient;

    return {
        connectToDatabase: jest.fn().mockResolvedValue({
            client: mockClient,
            db: mockDb
        } as MockDbConnection),
        getDb: jest.fn().mockReturnValue(mockDb)
    };
});

import { connectToDatabase, getDb } from '../lib/mongodb';

describe('MongoDB Connection and Data Fetching', () => {
    beforeEach(() => {
        jest.clearAllMocks();
    });

    describe('Database Connection', () => {
        it('should successfully connect to the database', async () => {
            const result = await connectToDatabase();
            expect(result).toBeDefined();
            expect(result.client).toBeDefined();
            expect(result.db).toBeDefined();
            expect(result.db.collection).toBeDefined();
        });
    });

    describe('Database Access', () => {
        it('should return the database instance', async () => {
            const db = getDb();
            expect(db).toBeDefined();
            expect(db.collection).toBeDefined();
        });

        it('should allow collection access', async () => {
            const db = getDb();
            const collection = db.collection('test');
            expect(collection).toBeDefined();
            expect(collection.find).toBeDefined();
            expect(collection.findOne).toBeDefined();
        });
    });
}); 
```
